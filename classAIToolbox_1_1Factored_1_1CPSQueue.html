<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>AIToolbox: AIToolbox::Factored::CPSQueue Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">AIToolbox
   </div>
   <div id="projectbrief">A library that offers tools for AI problem solving.</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespaceAIToolbox.html">AIToolbox</a></li><li class="navelem"><a class="el" href="namespaceAIToolbox_1_1Factored.html">Factored</a></li><li class="navelem"><a class="el" href="classAIToolbox_1_1Factored_1_1CPSQueue.html">CPSQueue</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="classAIToolbox_1_1Factored_1_1CPSQueue-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">AIToolbox::Factored::CPSQueue Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>This class is used as the priority queue for CooperativePrioritizedSweeping.  
 <a href="classAIToolbox_1_1Factored_1_1CPSQueue.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="CPSQueue_8hpp_source.html">CPSQueue.hpp</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a43537fb861ebaa66686e5d81ff3637df"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAIToolbox_1_1Factored_1_1CPSQueue.html#a43537fb861ebaa66686e5d81ff3637df">CPSQueue</a> (const <a class="el" href="namespaceAIToolbox_1_1Factored.html#af81c44d64cf98377be56973db15d0ede">DDNGraph</a> &amp;graph)</td></tr>
<tr class="memdesc:a43537fb861ebaa66686e5d81ff3637df"><td class="mdescLeft">&#160;</td><td class="mdescRight">Basic constructor.  <a href="#a43537fb861ebaa66686e5d81ff3637df">More...</a><br /></td></tr>
<tr class="separator:a43537fb861ebaa66686e5d81ff3637df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1c4aa1250e5520d60c28ff8688e0bfe1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAIToolbox_1_1Factored_1_1CPSQueue.html#a1c4aa1250e5520d60c28ff8688e0bfe1">update</a> (size_t i, size_t a, size_t s, double p)</td></tr>
<tr class="memdesc:a1c4aa1250e5520d60c28ff8688e0bfe1"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function updates the probability of the input parent set.  <a href="#a1c4aa1250e5520d60c28ff8688e0bfe1">More...</a><br /></td></tr>
<tr class="separator:a1c4aa1250e5520d60c28ff8688e0bfe1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a29d49dc985d33f56c0804552200911fa"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAIToolbox_1_1Factored_1_1CPSQueue.html#a29d49dc985d33f56c0804552200911fa">reconstruct</a> (<a class="el" href="namespaceAIToolbox_1_1Factored.html#a597904bffe91df4e1b0d8d11f17f3620">State</a> &amp;s, <a class="el" href="namespaceAIToolbox_1_1Factored.html#aa30fc73167a9c8e913053059e23f9692">Action</a> &amp;a)</td></tr>
<tr class="memdesc:a29d49dc985d33f56c0804552200911fa"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function sets the input State and Action with the highest priority combination.  <a href="#a29d49dc985d33f56c0804552200911fa">More...</a><br /></td></tr>
<tr class="separator:a29d49dc985d33f56c0804552200911fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa72d15e3cb8b695182245324035210de"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAIToolbox_1_1Factored_1_1CPSQueue.html#aa72d15e3cb8b695182245324035210de">getNodeMaxPriority</a> (size_t i) const</td></tr>
<tr class="memdesc:aa72d15e3cb8b695182245324035210de"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function returns the priority of the highest parent set of the selected node.  <a href="#aa72d15e3cb8b695182245324035210de">More...</a><br /></td></tr>
<tr class="separator:aa72d15e3cb8b695182245324035210de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa582890a648aa197d53c3f7574b9560b"><td class="memItemLeft" align="right" valign="top">unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAIToolbox_1_1Factored_1_1CPSQueue.html#aa582890a648aa197d53c3f7574b9560b">getNonZeroPriorities</a> () const</td></tr>
<tr class="memdesc:aa582890a648aa197d53c3f7574b9560b"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function returns how many non-zero priority parent sets there are.  <a href="#aa582890a648aa197d53c3f7574b9560b">More...</a><br /></td></tr>
<tr class="separator:aa582890a648aa197d53c3f7574b9560b"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>This class is used as the priority queue for CooperativePrioritizedSweeping. </p>
<p>This class performs a similar work as that done by Tries, but in a much more constrained way, so that it can be as fast as possible.</p>
<p>This class assumes keys are always the parent sets of some variable as represented in a DDN.</p>
<p>When doing the reconstruction, we select a single rule from each node, since all nodes's parents are by definition incompatible with each other. We always the best possible rule, and then randomly iterate over nodes, either picking their best possible rule if compatible or the best available alternative after picking a random local action. </p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a43537fb861ebaa66686e5d81ff3637df"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a43537fb861ebaa66686e5d81ff3637df">&#9670;&nbsp;</a></span>CPSQueue()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">AIToolbox::Factored::CPSQueue::CPSQueue </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceAIToolbox_1_1Factored.html#af81c44d64cf98377be56973db15d0ede">DDNGraph</a> &amp;&#160;</td>
          <td class="paramname"><em>graph</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Basic constructor. </p>
<p>This constructor uses the inputs to construct the internal representation for priority rules, following the structure of the ddn.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">graph</td><td>The ddn of the transition function of the problem. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="aa72d15e3cb8b695182245324035210de"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa72d15e3cb8b695182245324035210de">&#9670;&nbsp;</a></span>getNodeMaxPriority()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double AIToolbox::Factored::CPSQueue::getNodeMaxPriority </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function returns the priority of the highest parent set of the selected node. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">i</td><td>The id of the selected node.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The priority of the highest parent set. </dd></dl>

</div>
</div>
<a id="aa582890a648aa197d53c3f7574b9560b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa582890a648aa197d53c3f7574b9560b">&#9670;&nbsp;</a></span>getNonZeroPriorities()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned AIToolbox::Factored::CPSQueue::getNonZeroPriorities </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function returns how many non-zero priority parent sets there are. </p>
<p>The result is pre-computed during updates and reconstructions, so calling this function is always fast.</p>
<dl class="section return"><dt>Returns</dt><dd>The number of current non-zero priority rules. </dd></dl>

</div>
</div>
<a id="a29d49dc985d33f56c0804552200911fa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a29d49dc985d33f56c0804552200911fa">&#9670;&nbsp;</a></span>reconstruct()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void AIToolbox::Factored::CPSQueue::reconstruct </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceAIToolbox_1_1Factored.html#a597904bffe91df4e1b0d8d11f17f3620">State</a> &amp;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceAIToolbox_1_1Factored.html#aa30fc73167a9c8e913053059e23f9692">Action</a> &amp;&#160;</td>
          <td class="paramname"><em>a</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function sets the input State and Action with the highest priority combination. </p>
<p>The highest priority parent set is always picked. Then, we randomly iterate over nodes, either picking their best possible rule if compatible or the best available alternative after picking a random local action.</p>
<p>This is the best we can do, as picking the true highest combination is NP-hard, and we want this to be as fast as possible so we can do many batch updates in CooperativePrioritizedSweeping.</p>
<p>Note that some elements may not be picked. These will be left with the value of the size of their respective space (so you can find them and decide what to do with them).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>The State to output, preallocated. </td></tr>
    <tr><td class="paramname">a</td><td>The Action to output, preallocated.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A set of Entry that match the input and each other, the Factors obtained by combining the input with the returned set. </dd></dl>

</div>
</div>
<a id="a1c4aa1250e5520d60c28ff8688e0bfe1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1c4aa1250e5520d60c28ff8688e0bfe1">&#9670;&nbsp;</a></span>update()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void AIToolbox::Factored::CPSQueue::update </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function updates the probability of the input parent set. </p>
<p>This function takes ids directly to avoid having to pass through the <a class="el" href="namespaceAIToolbox_1_1Factored.html#aff18e60ac68a11f3951487b8171e6e9c" title="This function converts the input factor in the input space to an unique index. ">toIndexPartial()</a> function.</p>
<p>It increases the priority of the rule by 'p', and if necessary updates the maxes for the associated action/node so they can be more easily found later.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">i</td><td>The id of the node. </td></tr>
    <tr><td class="paramname">a</td><td>The id of the local joint action. </td></tr>
    <tr><td class="paramname">s</td><td>The id of the local parent states. </td></tr>
    <tr><td class="paramname">p</td><td>The priority to add. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>include/AIToolbox/Factored/MDP/Algorithms/Utils/<a class="el" href="CPSQueue_8hpp_source.html">CPSQueue.hpp</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Fri Mar 6 2020 12:58:21 for AIToolbox by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
