<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.17"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>AIToolbox: Extending AI Toolbox</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">AIToolbox
   </div>
   <div id="projectbrief">A library that offers tools for AI problem solving.</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.17 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('extendingaitoolbox.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="PageDoc"><div class="header">
  <div class="headertitle">
<div class="title">Extending AI Toolbox </div>  </div>
</div><!--header-->
<div class="contents">
<div class="toc"><h3>Table of Contents</h3>
<ul><li class="level1"><a href="#intro">Introduction</a><ul><li class="level2"><a href="#org">Code Organization</a></li>
<li class="level2"><a href="#types">Types</a></li>
<li class="level2"><a href="#utils">Utilities</a></li>
<li class="level2"><a href="#algopol">What are Algorithms and Policies?</a></li>
<li class="level2"><a href="#inherit">Mostly Templates</a></li>
</ul>
</li>
<li class="level1"><a href="#int">Interfaces</a><ul><li class="level2"><a href="#expint">Experience Interfaces</a><ul><li class="level3"><a href="#exp">Standard Experience</a></li>
<li class="level3"><a href="#eigexp">Eigen Experience Interface</a></li>
</ul>
</li>
<li class="level2"><a href="#modint">Model Interfaces</a><ul><li class="level3"><a href="#genmod">Generative MDP Model</a></li>
<li class="level3"><a href="#mod">Standard MDP Model</a></li>
<li class="level3"><a href="#eigmod">Eigen MDP Model</a></li>
</ul>
</li>
<li class="level2"><a href="#algoint">Algorithm Interfaces</a></li>
<li class="level2"><a href="#polint">Policy Interfaces</a></li>
</ul>
</li>
</ul>
</div>
<div class="textblock"><h1><a class="anchor" id="intro"></a>
Introduction</h1>
<p>This page tries to give a brief description of the concepts behind <a class="el" href="namespaceAIToolbox.html">AIToolbox</a> and how its code is organized, to help you orient yourself if you want to extend the library for your specific goals.</p>
<h2><a class="anchor" id="org"></a>
Code Organization</h2>
<p>Organizing AI algorithms into a consistent interface is not always an easy task, as the field is extremely diverse, and every algorithm tends to have specific and unique quirks.</p>
<p>We significantly use the folder structure of the project to group files that are logically close, and to group algorithms depending on their features. This hierarchy is somewhat arbitrary, but still better than nothing.</p>
<p>For example, here is (part of) the structure made by the first few levels of folders/files inside <code>include/AIToolbox</code>:</p>
<div class="fragment"><div class="line">- Types.hpp</div>
<div class="line">- Utils</div>
<div class="line">- Bandit</div>
<div class="line">    - Policies</div>
<div class="line">    - Types.hpp</div>
<div class="line">- MDP</div>
<div class="line">    - Algorithms</div>
<div class="line">    - Policies</div>
<div class="line">    - Types.hpp</div>
<div class="line">    - Utils.hpp</div>
<div class="line">- POMDP</div>
<div class="line">    - Algorithms</div>
<div class="line">    - Policies</div>
<div class="line">    - Types.hpp</div>
<div class="line">    - Utils.hpp</div>
</div><!-- fragment --><h2><a class="anchor" id="types"></a>
Types</h2>
<p><code>Types.hpp</code> files describe the types used in the library, with nested files describing types that are mostly used in a specific context. <a class="el" href="namespaceAIToolbox.html">AIToolbox</a> tries to rely standard types (for example <code>std::vector</code>) as much as possible, only resorting to types of external libraries when absolutely necessary.</p>
<h2><a class="anchor" id="utils"></a>
Utilities</h2>
<p><code>Utils</code> files and folders contain pure free functions and data-structures that are (mostly) independent of anything else in the library, aside from types. These files contain the most common functionality, which is shared between algorithms and methods, and are grouped together depending on their topic.</p>
<p>For example, in the <code>include/AIToolbox/Utils</code> folder one may find utilities for combinatorics (<code><a class="el" href="Combinatorics_8hpp.html">Combinatorics.hpp</a></code>), probabilities (<code><a class="el" href="Probability_8hpp.html">Probability.hpp</a></code>), polytopes (<code><a class="el" href="Polytope_8hpp.html">Polytope.hpp</a></code>), linear programming (<code><a class="el" href="LP_8hpp.html">LP.hpp</a></code>), pruning (<code><a class="el" href="Prune_8hpp.html">Prune.hpp</a></code>), etc. More domain-specific utilities can be found in subfolders throughout the library.</p>
<p>Free functions try to accept standard types where possible, while otherwise they accept <a class="el" href="namespaceAIToolbox.html">AIToolbox</a> specific types. Using these functions does not have any additional code requirements, so they should be easy to use.</p>
<h2><a class="anchor" id="algopol"></a>
What are Algorithms and Policies?</h2>
<p>One of the major distinctions in <a class="el" href="namespaceAIToolbox.html">AIToolbox</a> is between policies and algorithms, which are stored in separate folders. In simple terms, we denote as policies all the classes that can directly provide sampling utilities and probability distributions over actions. Whether they do it by maximizing over a QFunction or because they are implementing an actor-only method does not matter. We consider algorithms all other methods.</p>
<p>The reason for this split is that policies have a special place in <a class="el" href="namespaceAIToolbox.html">AIToolbox</a>'s hierarchy, as they are the only classes that are organized using inheritance. This is because we design policies to be composable: many algorithms that output policies tend to have other policies as inputs, which makes the idea of composing arbitrary methods together very attractive. Doing this with templates becomes burdensome very quickly (as nested type names start growing), so we use virtual dispatching to be able to pass arbitrary policies around, and to keep their overall API consistent with virtual interfaces.</p>
<p>On the other hand, in general, algorithms don't have a unified API (although we do try to keep consistency between similar methods where possible), as they tend to behave very uniquely.</p>
<h2><a class="anchor" id="inherit"></a>
Mostly Templates</h2>
<p>Aside from policies, we mostly do not introduce inheritance relationships between classes. Each class is kept as simple and monolithic as possible, preferring "owns-a" relationships rather than "is-a". Code is sometimes duplicated between two classes if they are not related (when it can't be made into a free function), rather than forcing awkward child-parent relationships for the sake of saving few lines of code. Generalization is achieved using templates.</p>
<p>This is true for models, algorithms, data structures etc.</p>
<p>Template interfaces are described and checked using template code (which will hopefully be converted into simpler Concepts as C++20 is released). They mostly describe the methods that models should have, as the library needs to be able to feed arbitrary models to algorithms.</p>
<hr  />
<h1><a class="anchor" id="int"></a>
Interfaces</h1>
<p>This section lists interfaces that you can implement in your own code to interoperate with <a class="el" href="namespaceAIToolbox.html">AIToolbox</a> own classes and methods.</p>
<p>Keep in mind that these interfaces must be implemented exactly, down to the exact type that must be taken/returned; no implicit conversions are allowed. If these interfaces are not respected, your code will fail to compile.</p>
<h2><a class="anchor" id="expint"></a>
Experience Interfaces</h2>
<p>If you are doing RL and want to store experience data in your own class, you can implement the following methods in your class to use <a class="el" href="namespaceAIToolbox.html">AIToolbox</a> RL models with it (for example <a class="el" href="classAIToolbox_1_1MDP_1_1MaximumLikelihoodModel.html" title="This class models Experience as a Markov Decision Process using Maximum Likelihood.">AIToolbox::MDP::MaximumLikelihoodModel</a>).</p>
<p>You do not need to inherit from any class to implement these interfaces.</p>
<h3><a class="anchor" id="exp"></a>
Standard Experience</h3>
<p>The basic Experience interface requires you to report the number of seen transitions, and statistics on the obtained rewards for all state-action pairs.</p>
<div class="fragment"><div class="line"><span class="keywordtype">long</span> <span class="keywordtype">unsigned</span> getVisits(<span class="keywordtype">size_t</span> s,<span class="keywordtype">size_t</span> a,<span class="keywordtype">size_t</span> s1) <span class="keyword">const</span>; <span class="comment">// Returns the number of seen transitions for the input</span></div>
<div class="line"><span class="keywordtype">long</span> <span class="keywordtype">unsigned</span> getVisitsSum(<span class="keywordtype">size_t</span> s,<span class="keywordtype">size_t</span> a) <span class="keyword">const</span>;        <span class="comment">// Returns the sum of transition seen from the input state-action pair</span></div>
<div class="line"><span class="keywordtype">double</span> getReward(<span class="keywordtype">size_t</span> s,<span class="keywordtype">size_t</span> a) <span class="keyword">const</span>;                  <span class="comment">// Returns the average reward seen for the specified state-action pair</span></div>
<div class="line"><span class="keywordtype">double</span> getM2(<span class="keywordtype">size_t</span> s,<span class="keywordtype">size_t</span> a) <span class="keyword">const</span>;                      <span class="comment">// Returns the M2 statistic for the specified state-action pair</span></div>
</div><!-- fragment --><h3><a class="anchor" id="eigexp"></a>
Eigen Experience Interface</h3>
<p>It's possible to return <a class="el" href="namespaceEigen.html">Eigen</a> matrices containing the experience data in order to speed up the calculations done to update transition and reward functions in RL models.</p>
<div class="fragment"><div class="line"><span class="keyword">const</span> M &amp; getVisitsTable(<span class="keywordtype">size_t</span>) <span class="keyword">const</span>; <span class="comment">// Returns an SxS Eigen matrix containing the seen transitions using that action</span></div>
<div class="line"><span class="keyword">const</span> M &amp; getRewardMatrix() <span class="keyword">const</span>;      <span class="comment">// Returns an SxA Eigen matrix containing all average rewards</span></div>
<div class="line"><span class="keyword">const</span> M &amp; getM2Matrix() <span class="keyword">const</span>;          <span class="comment">// Returns an SxA Eigen matrix containing all M2 values</span></div>
</div><!-- fragment --><h2><a class="anchor" id="modint"></a>
Model Interfaces</h2>
<p>In <a class="el" href="namespaceAIToolbox.html">AIToolbox</a> models are glorified data structures. The most complicated thing they can do is provide an API for sampling, and are otherwise simple wrappers around transition and reward functions.</p>
<p>Implementing a new model does not require you to inherit from any class in the library. However, algorithms expect a certain set of methods and parameters to be accessible.</p>
<h3><a class="anchor" id="genmod"></a>
Generative MDP Model</h3>
<p>The most basic basic MDP model interface the generative model, i.e. a model which we only use to sample new transitions, but where we don't have access to the underlying transition and reward functions. A simulator would be an excellent candidate for a generative model.</p>
<p>Here are the methods which you need to implement for your class to be compatible with algorithms that expect a generative model:</p>
<div class="fragment"><div class="line"><span class="keywordtype">size_t</span> getS() <span class="keyword">const</span>;                                            <span class="comment">// Returns the size of the state space</span></div>
<div class="line"><span class="keywordtype">size_t</span> getA() <span class="keyword">const</span>;                                            <span class="comment">// Returns the size of the action space</span></div>
<div class="line"><span class="keywordtype">double</span> getDiscount() <span class="keyword">const</span>;                                     <span class="comment">// Returns the discount factor of the MDP</span></div>
<div class="line">std::tuple&lt;size_t, double&gt; sampleSR(<span class="keywordtype">size_t</span> s,<span class="keywordtype">size_t</span> a) <span class="keyword">const</span>;   <span class="comment">// From a state-action pair, return a new state-reward pair.</span></div>
<div class="line"><span class="keywordtype">bool</span> isTerminal(<span class="keywordtype">size_t</span> s) <span class="keyword">const</span>;                                <span class="comment">// Return whether a given state is terminal</span></div>
</div><!-- fragment --><h3><a class="anchor" id="mod"></a>
Standard MDP Model</h3>
<p>Planning algorithms usually require a more strict interface than a generative model, as they may need access to the underlying transition and reward functions of your model. In that case, you will need to implement the following <em>additional</em> functions:</p>
<div class="fragment"><div class="line"><span class="keywordtype">double</span> getTransitionProbability(<span class="keywordtype">size_t</span> s,<span class="keywordtype">size_t</span> a,<span class="keywordtype">size_t</span> s1) <span class="keyword">const</span>; <span class="comment">// Returns the probability of transitioning from s and a to s1.</span></div>
<div class="line"><span class="keywordtype">double</span> getExpectedReward(<span class="keywordtype">size_t</span> s,<span class="keywordtype">size_t</span> a,<span class="keywordtype">size_t</span> s1) <span class="keyword">const</span>;        <span class="comment">// Returns the expected reward of the input transition.</span></div>
</div><!-- fragment --><h3><a class="anchor" id="eigmod"></a>
Eigen MDP Model</h3>
<p>An additional set of functions can be implemented in order to unlock optimizations within the code that leverage the <a class="el" href="namespaceEigen.html">Eigen</a> library. This can significantly speed up certain algorithms, and may be required for others.</p>
<div class="fragment"><div class="line"><span class="keyword">const</span> M &amp; getTransitionFunction(<span class="keywordtype">size_t</span> a) <span class="keyword">const</span>; <span class="comment">// Returns an SxS Eigen matrix containing the transition probabilities for action a;</span></div>
<div class="line"><span class="keyword">const</span> M &amp; getRewardFunction() <span class="keyword">const</span>;             <span class="comment">// Returns an SxA Eigen matrix containing expected rewards for all state-action pairs.</span></div>
</div><!-- fragment --><h2><a class="anchor" id="algoint"></a>
Algorithm Interfaces</h2>
<p>As we mentioned above, algorithms do not generally have a common interface, nor they inherit from some common ancestor. If you want to implement your own algorithm, or extend any <a class="el" href="namespaceAIToolbox.html">AIToolbox</a> ones, you have basically complete free rein on what you want to do.</p>
<h2><a class="anchor" id="polint"></a>
Policy Interfaces</h2>
<p>In general, if you want to simply implement your own policy using <a class="el" href="namespaceAIToolbox.html">AIToolbox</a> types, there is nothing special you need to do. You can implement your policy, use it in your code, and be done.</p>
<p>However, if you need to feed your policy to some algorithm/other policy in the library, you will have to inherit from one of the interface policy classes, and implement their virtual methods.</p>
<p>The root of the policy hierarchy is the <a class="el" href="classAIToolbox_1_1PolicyInterface.html" title="This class represents the base interface for policies.">AIToolbox::PolicyInterface</a> class. This is a template class, which contains a generic interface that can use arbitrary types for state and actions (which can be useful for multi-agent environments).</p>
<p>If you are working with MDPs, you can directly inherit its specialized, more friendly interface: <a class="el" href="classAIToolbox_1_1MDP_1_1PolicyInterface.html" title="Simple typedef for most of MDP&#39;s policy needs.">AIToolbox::MDP::PolicyInterface</a>. Once you implement its virtual functions, you are ready to use the class and don't have to do anything else.</p>
<p>If your policy takes a QFunction to produce its policy you may want to inherit from <a class="el" href="classAIToolbox_1_1MDP_1_1QPolicyInterface.html" title="This class is an interface to specify a policy through a QFunction.">AIToolbox::MDP::QPolicyInterface</a>, which already initializes the QFunction for you. This is however not required, it's just for convenience. </p>
</div></div><!-- contents -->
</div><!-- PageDoc -->
</div><!-- doc-content -->
<!-- HTML footer for doxygen 1.8.17-->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
</div>
</body>
</html>
