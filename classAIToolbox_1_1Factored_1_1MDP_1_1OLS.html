<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>AIToolbox: AIToolbox::Factored::MDP::OLS Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">AIToolbox
   </div>
   <div id="projectbrief">A library that offers tools for AI problem solving.</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespaceAIToolbox.html">AIToolbox</a></li><li class="navelem"><a class="el" href="namespaceAIToolbox_1_1Factored.html">Factored</a></li><li class="navelem"><a class="el" href="namespaceAIToolbox_1_1Factored_1_1MDP.html">MDP</a></li><li class="navelem"><a class="el" href="classAIToolbox_1_1Factored_1_1MDP_1_1OLS.html">OLS</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="classAIToolbox_1_1Factored_1_1MDP_1_1OLS-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">AIToolbox::Factored::MDP::OLS Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>This class represents the LinearSupport algorithm.  
 <a href="classAIToolbox_1_1Factored_1_1MDP_1_1OLS.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="OLS_8hpp_source.html">OLS.hpp</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a7351b60a084af4db2a4a20c59fb75036"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAIToolbox_1_1Factored_1_1MDP_1_1OLS.html#a7351b60a084af4db2a4a20c59fb75036">OLS</a> (unsigned horizon, double tolerance)</td></tr>
<tr class="memdesc:a7351b60a084af4db2a4a20c59fb75036"><td class="mdescLeft">&#160;</td><td class="mdescRight">Basic constructor.  <a href="#a7351b60a084af4db2a4a20c59fb75036">More...</a><br /></td></tr>
<tr class="separator:a7351b60a084af4db2a4a20c59fb75036"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a56f6b25e107c3b6f93aa0a28462508bb"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAIToolbox_1_1Factored_1_1MDP_1_1OLS.html#a56f6b25e107c3b6f93aa0a28462508bb">setTolerance</a> (double tolerance)</td></tr>
<tr class="memdesc:a56f6b25e107c3b6f93aa0a28462508bb"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function sets the tolerance parameter.  <a href="#a56f6b25e107c3b6f93aa0a28462508bb">More...</a><br /></td></tr>
<tr class="separator:a56f6b25e107c3b6f93aa0a28462508bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a48b853e558c5fe1d0c3520849ea3f22e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAIToolbox_1_1Factored_1_1MDP_1_1OLS.html#a48b853e558c5fe1d0c3520849ea3f22e">setHorizon</a> (unsigned h)</td></tr>
<tr class="memdesc:a48b853e558c5fe1d0c3520849ea3f22e"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function allows setting the horizon parameter.  <a href="#a48b853e558c5fe1d0c3520849ea3f22e">More...</a><br /></td></tr>
<tr class="separator:a48b853e558c5fe1d0c3520849ea3f22e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ed34a2bde683e477f1b9dd00f241fb3"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAIToolbox_1_1Factored_1_1MDP_1_1OLS.html#a9ed34a2bde683e477f1b9dd00f241fb3">getTolerance</a> () const</td></tr>
<tr class="memdesc:a9ed34a2bde683e477f1b9dd00f241fb3"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function will return the currently set tolerance parameter.  <a href="#a9ed34a2bde683e477f1b9dd00f241fb3">More...</a><br /></td></tr>
<tr class="separator:a9ed34a2bde683e477f1b9dd00f241fb3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abf7411e7c18609cf2673b6ea5cb20a90"><td class="memItemLeft" align="right" valign="top">unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAIToolbox_1_1Factored_1_1MDP_1_1OLS.html#abf7411e7c18609cf2673b6ea5cb20a90">getHorizon</a> () const</td></tr>
<tr class="memdesc:abf7411e7c18609cf2673b6ea5cb20a90"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function returns the currently set horizon parameter.  <a href="#abf7411e7c18609cf2673b6ea5cb20a90">More...</a><br /></td></tr>
<tr class="separator:abf7411e7c18609cf2673b6ea5cb20a90"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4099da3a3355540b2c62135c3bbb772f"><td class="memTemplParams" colspan="2">template&lt;typename M , typename  = std::enable_if_t&lt;is_model_v&lt;M&gt;&gt;&gt; </td></tr>
<tr class="memitem:a4099da3a3355540b2c62135c3bbb772f"><td class="memTemplItemLeft" align="right" valign="top">std::tuple&lt; double, <a class="el" href="structAIToolbox_1_1MDP_1_1ValueFunction.html">SMDP::ValueFunction</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classAIToolbox_1_1Factored_1_1MDP_1_1OLS.html#a4099da3a3355540b2c62135c3bbb772f">operator()</a> (const M &amp;model)</td></tr>
<tr class="memdesc:a4099da3a3355540b2c62135c3bbb772f"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function solves a <a class="el" href="classAIToolbox_1_1POMDP_1_1Model.html" title="This class represents a Partially Observable Markov Decision Process. ">POMDP::Model</a> completely.  <a href="#a4099da3a3355540b2c62135c3bbb772f">More...</a><br /></td></tr>
<tr class="separator:a4099da3a3355540b2c62135c3bbb772f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a85a8b7503eb7fce6f547742039f791dd"><td class="memTemplParams" colspan="2">template&lt;typename M , typename &gt; </td></tr>
<tr class="memitem:a85a8b7503eb7fce6f547742039f791dd"><td class="memTemplItemLeft" align="right" valign="top">std::tuple&lt; double, <a class="el" href="structAIToolbox_1_1Factored_1_1MDP_1_1ValueFunction.html">ValueFunction</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classAIToolbox_1_1Factored_1_1MDP_1_1OLS.html#a85a8b7503eb7fce6f547742039f791dd">operator()</a> (const M &amp;model)</td></tr>
<tr class="separator:a85a8b7503eb7fce6f547742039f791dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>This class represents the LinearSupport algorithm. </p>
<p>This method is similar in spirit to Witness. The idea is that we look at certain belief points, and we try to find the best alphavectors in those points. Rather than looking for them though, the idea here is that we <em>know</em> where they are, if there are any at all.</p>
<p>As the <a class="el" href="structAIToolbox_1_1Factored_1_1MDP_1_1ValueFunction.html" title="This struct represents a factored ValueFunction. ">ValueFunction</a> is piecewise linear and convex, if there's any other hyperplane that we can add to improve it, the improvements are going to be maximal at one of the vertices of the original surface.</p>
<p>The idea thus is the following: first we compute the set of alphavectors for the corners, so we can be sure about them. Then we find all vertices that those alphavectors create, and we compute the error between the true <a class="el" href="structAIToolbox_1_1Factored_1_1MDP_1_1ValueFunction.html" title="This struct represents a factored ValueFunction. ">ValueFunction</a> and their current values.</p>
<p>If the error is greater than a certain amount, we allow their supporting alphavector to join the <a class="el" href="structAIToolbox_1_1Factored_1_1MDP_1_1ValueFunction.html" title="This struct represents a factored ValueFunction. ">ValueFunction</a>, and we increase the size of the vertex set by adding all new vertices that are created by adding the new surface (and removing the ones that are made useless by it).</p>
<p>We repeat until we have checked all available vertices, and at that point we are done.</p>
<p>While this can be a very inefficient algorithm, the fact that vertices are checked in an orderly fashion, from highest error to lowest, allows if one needs it to convert this algorithm into an anytime algorithm. Even if there is limited time to compute the solution, the algorithm is guaranteed to work in the areas with high error first, allowing one to compute good approximations even without a lot of resources. </p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a7351b60a084af4db2a4a20c59fb75036"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7351b60a084af4db2a4a20c59fb75036">&#9670;&nbsp;</a></span>OLS()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">AIToolbox::Factored::MDP::OLS::OLS </td>
          <td>(</td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>horizon</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>tolerance</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Basic constructor. </p>
<p>This constructor sets the default horizon used to solve a <a class="el" href="classAIToolbox_1_1POMDP_1_1Model.html" title="This class represents a Partially Observable Markov Decision Process. ">POMDP::Model</a>.</p>
<p>The tolerance parameter must be &gt;= 0.0, otherwise the constructor will throw an std::runtime_error. The tolerance parameter sets the convergence criterion. A tolerance of 0.0 forces LinearSupport to perform a number of iterations equal to the horizon specified. Otherwise, LinearSupport will stop as soon as the difference between two iterations is less than the tolerance specified.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">h</td><td>The horizon chosen. </td></tr>
    <tr><td class="paramname">tolerance</td><td>The tolerance factor to stop the value iteration loop. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="abf7411e7c18609cf2673b6ea5cb20a90"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abf7411e7c18609cf2673b6ea5cb20a90">&#9670;&nbsp;</a></span>getHorizon()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned AIToolbox::Factored::MDP::OLS::getHorizon </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function returns the currently set horizon parameter. </p>
<dl class="section return"><dt>Returns</dt><dd>The current horizon. </dd></dl>

</div>
</div>
<a id="a9ed34a2bde683e477f1b9dd00f241fb3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9ed34a2bde683e477f1b9dd00f241fb3">&#9670;&nbsp;</a></span>getTolerance()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double AIToolbox::Factored::MDP::OLS::getTolerance </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function will return the currently set tolerance parameter. </p>
<dl class="section return"><dt>Returns</dt><dd>The currently set tolerance parameter. </dd></dl>

</div>
</div>
<a id="a4099da3a3355540b2c62135c3bbb772f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4099da3a3355540b2c62135c3bbb772f">&#9670;&nbsp;</a></span>operator()() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename M , typename  = std::enable_if_t&lt;is_model_v&lt;M&gt;&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::tuple&lt;double, <a class="el" href="structAIToolbox_1_1MDP_1_1ValueFunction.html">SMDP::ValueFunction</a>&gt; AIToolbox::Factored::MDP::OLS::operator() </td>
          <td>(</td>
          <td class="paramtype">const M &amp;&#160;</td>
          <td class="paramname"><em>model</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function solves a <a class="el" href="classAIToolbox_1_1POMDP_1_1Model.html" title="This class represents a Partially Observable Markov Decision Process. ">POMDP::Model</a> completely. </p>
<p>This function is pretty expensive (as are possibly all <a class="el" href="namespaceAIToolbox_1_1POMDP.html">POMDP</a> solvers). It evaluates all vertices in the <a class="el" href="structAIToolbox_1_1Factored_1_1MDP_1_1ValueFunction.html" title="This struct represents a factored ValueFunction. ">ValueFunction</a> surface in order to determine whether it is complete, otherwise it improves it incrementally.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">M</td><td>The type of <a class="el" href="namespaceAIToolbox_1_1POMDP.html">POMDP</a> model that needs to be solved.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">model</td><td>The <a class="el" href="namespaceAIToolbox_1_1POMDP.html">POMDP</a> model that needs to be solved.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A tuple containing the maximum variation for the <a class="el" href="structAIToolbox_1_1Factored_1_1MDP_1_1ValueFunction.html" title="This struct represents a factored ValueFunction. ">ValueFunction</a> and the computed <a class="el" href="structAIToolbox_1_1Factored_1_1MDP_1_1ValueFunction.html" title="This struct represents a factored ValueFunction. ">ValueFunction</a>. </dd></dl>

</div>
</div>
<a id="a85a8b7503eb7fce6f547742039f791dd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a85a8b7503eb7fce6f547742039f791dd">&#9670;&nbsp;</a></span>operator()() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename M , typename &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::tuple&lt;double, <a class="el" href="structAIToolbox_1_1Factored_1_1MDP_1_1ValueFunction.html">ValueFunction</a>&gt; AIToolbox::Factored::MDP::OLS::operator() </td>
          <td>(</td>
          <td class="paramtype">const M &amp;&#160;</td>
          <td class="paramname"><em>model</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a48b853e558c5fe1d0c3520849ea3f22e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a48b853e558c5fe1d0c3520849ea3f22e">&#9670;&nbsp;</a></span>setHorizon()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void AIToolbox::Factored::MDP::OLS::setHorizon </td>
          <td>(</td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>h</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function allows setting the horizon parameter. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">h</td><td>The new horizon parameter. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a56f6b25e107c3b6f93aa0a28462508bb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a56f6b25e107c3b6f93aa0a28462508bb">&#9670;&nbsp;</a></span>setTolerance()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void AIToolbox::Factored::MDP::OLS::setTolerance </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>tolerance</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function sets the tolerance parameter. </p>
<p>The tolerance parameter must be &gt;= 0.0, otherwise the constructor will throw an std::runtime_error. The tolerance parameter sets the convergence criterion. A tolerance of 0.0 forces LinearSupport to perform a number of iterations equal to the horizon specified. Otherwise, LinearSupport will stop as soon as the difference between two iterations is less than the tolerance specified.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tolerance</td><td>The new tolerance parameter. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>include/AIToolbox/Factored/MDP/Algorithms/<a class="el" href="OLS_8hpp_source.html">OLS.hpp</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Fri Feb 1 2019 11:06:11 for AIToolbox by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
