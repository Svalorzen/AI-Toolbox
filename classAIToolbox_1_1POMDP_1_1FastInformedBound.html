<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.17"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>AIToolbox: AIToolbox::POMDP::FastInformedBound Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">AIToolbox
   </div>
   <div id="projectbrief">A library that offers tools for AI problem solving.</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.17 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('classAIToolbox_1_1POMDP_1_1FastInformedBound.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="classAIToolbox_1_1POMDP_1_1FastInformedBound-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">AIToolbox::POMDP::FastInformedBound Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>This class implements the Fast Informed Bound algorithm.  
 <a href="classAIToolbox_1_1POMDP_1_1FastInformedBound.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="FastInformedBound_8hpp_source.html">AIToolbox/POMDP/Algorithms/FastInformedBound.hpp</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:ab120caa9f9999d82a7c99bd47e091ad3"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAIToolbox_1_1POMDP_1_1FastInformedBound.html#ab120caa9f9999d82a7c99bd47e091ad3">FastInformedBound</a> (unsigned horizon, double tolerance=0.001)</td></tr>
<tr class="memdesc:ab120caa9f9999d82a7c99bd47e091ad3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Basic constructor.  <a href="classAIToolbox_1_1POMDP_1_1FastInformedBound.html#ab120caa9f9999d82a7c99bd47e091ad3">More...</a><br /></td></tr>
<tr class="separator:ab120caa9f9999d82a7c99bd47e091ad3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa1fdb3fce3a82514c8b9d7cb8f3a39ae"><td class="memTemplParams" colspan="2">template&lt;IsModel M&gt; </td></tr>
<tr class="memitem:aa1fdb3fce3a82514c8b9d7cb8f3a39ae"><td class="memTemplItemLeft" align="right" valign="top">std::tuple&lt; double, <a class="el" href="namespaceAIToolbox_1_1MDP.html#a7511ad35cec2e20bf392458125e28ebc">MDP::QFunction</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classAIToolbox_1_1POMDP_1_1FastInformedBound.html#aa1fdb3fce3a82514c8b9d7cb8f3a39ae">operator()</a> (const M &amp;m, const <a class="el" href="namespaceAIToolbox_1_1MDP.html#a7511ad35cec2e20bf392458125e28ebc">MDP::QFunction</a> &amp;oldQ={})</td></tr>
<tr class="memdesc:aa1fdb3fce3a82514c8b9d7cb8f3a39ae"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function computes the Fast Informed Bound for the input <a class="el" href="namespaceAIToolbox_1_1POMDP.html">POMDP</a>.  <a href="classAIToolbox_1_1POMDP_1_1FastInformedBound.html#aa1fdb3fce3a82514c8b9d7cb8f3a39ae">More...</a><br /></td></tr>
<tr class="separator:aa1fdb3fce3a82514c8b9d7cb8f3a39ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a975d7ce35e99840cacaf01380dc93fd7"><td class="memTemplParams" colspan="2">template&lt;IsModel M, typename SOSA &gt; </td></tr>
<tr class="memitem:a975d7ce35e99840cacaf01380dc93fd7"><td class="memTemplItemLeft" align="right" valign="top">std::tuple&lt; double, <a class="el" href="namespaceAIToolbox_1_1MDP.html#a7511ad35cec2e20bf392458125e28ebc">MDP::QFunction</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classAIToolbox_1_1POMDP_1_1FastInformedBound.html#a975d7ce35e99840cacaf01380dc93fd7">operator()</a> (const M &amp;m, const SOSA &amp;sosa, <a class="el" href="namespaceAIToolbox_1_1MDP.html#a7511ad35cec2e20bf392458125e28ebc">MDP::QFunction</a> oldQ={})</td></tr>
<tr class="memdesc:a975d7ce35e99840cacaf01380dc93fd7"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function computes the Fast Informed Bound for the input <a class="el" href="namespaceAIToolbox_1_1POMDP.html">POMDP</a>.  <a href="classAIToolbox_1_1POMDP_1_1FastInformedBound.html#a975d7ce35e99840cacaf01380dc93fd7">More...</a><br /></td></tr>
<tr class="separator:a975d7ce35e99840cacaf01380dc93fd7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abdf4512027ca14b1c4f2063f33cd7ea3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAIToolbox_1_1POMDP_1_1FastInformedBound.html#abdf4512027ca14b1c4f2063f33cd7ea3">setTolerance</a> (double tolerance)</td></tr>
<tr class="memdesc:abdf4512027ca14b1c4f2063f33cd7ea3"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function sets the tolerance parameter.  <a href="classAIToolbox_1_1POMDP_1_1FastInformedBound.html#abdf4512027ca14b1c4f2063f33cd7ea3">More...</a><br /></td></tr>
<tr class="separator:abdf4512027ca14b1c4f2063f33cd7ea3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a06d15668e1edc5ae8e00674cdfc9bd01"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAIToolbox_1_1POMDP_1_1FastInformedBound.html#a06d15668e1edc5ae8e00674cdfc9bd01">setHorizon</a> (unsigned h)</td></tr>
<tr class="memdesc:a06d15668e1edc5ae8e00674cdfc9bd01"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function sets the horizon parameter.  <a href="classAIToolbox_1_1POMDP_1_1FastInformedBound.html#a06d15668e1edc5ae8e00674cdfc9bd01">More...</a><br /></td></tr>
<tr class="separator:a06d15668e1edc5ae8e00674cdfc9bd01"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aab6754603040a68c2f2746be246c9fd6"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAIToolbox_1_1POMDP_1_1FastInformedBound.html#aab6754603040a68c2f2746be246c9fd6">getTolerance</a> () const</td></tr>
<tr class="memdesc:aab6754603040a68c2f2746be246c9fd6"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function returns the currently set tolerance parameter.  <a href="classAIToolbox_1_1POMDP_1_1FastInformedBound.html#aab6754603040a68c2f2746be246c9fd6">More...</a><br /></td></tr>
<tr class="separator:aab6754603040a68c2f2746be246c9fd6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a981a6d10ccf887130463957eb2ad8a29"><td class="memItemLeft" align="right" valign="top">unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAIToolbox_1_1POMDP_1_1FastInformedBound.html#a981a6d10ccf887130463957eb2ad8a29">getHorizon</a> () const</td></tr>
<tr class="memdesc:a981a6d10ccf887130463957eb2ad8a29"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function returns the current horizon parameter.  <a href="classAIToolbox_1_1POMDP_1_1FastInformedBound.html#a981a6d10ccf887130463957eb2ad8a29">More...</a><br /></td></tr>
<tr class="separator:a981a6d10ccf887130463957eb2ad8a29"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>This class implements the Fast Informed Bound algorithm. </p>
<p>This class is useful in order to obtain a very simple upper bound for a <a class="el" href="namespaceAIToolbox_1_1POMDP.html">POMDP</a>.</p>
<p>This upper bound is computed as a simplification over the true ValueFunction <a class="el" href="namespaceAIToolbox_1_1POMDP.html">POMDP</a> update (via Bellman Equation).</p>
<p>I'm going to go through the whole derivation from scratch here since to somebody reading it might turn out useful (and I have spent some time trying to understand it so might as well write it up).</p>
<p>We first start the derivation through the basic Bellman Equation for POMDPs: </p><pre class="fragment">Q(b,a) = Sum_s R(s,a) * b(s) + gamma * Sum_o P(b'|b,a) * V(b')
Q(b,a) = Sum_s R(s,a) * b(s) + gamma * Sum_o P(o|b,a) * V(b')
</pre><p>This should be pretty self-explanatory: the value of a belief and an action is equal to the reward you get by acting, plus the future discounted rewards of whatever belief you end up in, times the probability of ending up there.</p>
<p>From here I just consider the second part (after gamma), since that's the interesting stuff anyway. The rest remains the same. </p><pre class="fragment">Sum_o P(o|b,a) * V(b')
Sum_o Sum_s P(o|s,a) * b(s) * V(b')
</pre><p>Here b' is implied since it can be computed from b,a,o.</p>
<p>So at this point we'd normally be done, but the thing is that this to work this formula requires V(b) to be defined in every belief, and we'd have to update it for every belief. This is kind of hard since there's infinite beliefs to go over.</p>
<p>So the trick is that we know that the ValueFunction is piecewise-linear and convex, so we change the formula a bit in order to be able to use the previous-step alphavectors to do the update. </p><pre class="fragment">Sum_o max_prev_alpha Sum_s' [ Sum_s P(s',o|s,a) * b(s) ] * prev_alpha(s')
</pre><p>Here P(o|s,a) became P(s',o|s,a) simply because it has ended up inside the Sum_s', to keep its value the same (this is probability math).</p>
<p>So now instead of V, we look, for each observation, inside the best previous alpha we can find for it, and sum over all its values (since it's a vector).</p>
<p>Now to the Fast Informed Bound. What we do is a simple shuffling of terms, which increases the value: </p><pre class="fragment">Sum_o Sum_s max_prev_alpha Sum_s' [ P(s',o|s,a) * b(s) ] * prev_alpha(s')
</pre><p>By moving the max inside the Sum_s, we increase the value of the formula. From here on it's just algebra: </p><pre class="fragment">Sum_s b(s) Sum_o max_prev_alpha Sum_s' P(s',o|s,a) * prev_alpha(s')
Q(b,a) = Sum_s b(s) * [ R(s,a) + gamma * Sum_o max_prev_alpha Sum_s' P(s',o|s,a) * prev_alpha(s') ]
</pre><p>Finally, since with this method you produce Q(b,a), it means you'll always produce A alphavectors. So you can write that as: </p><pre class="fragment">Q(b,a) = Sum_s b(s) * [ R(s,a) + gamma * Sum_o max_a' Sum_s' P(s',o|s,a) * Q(s',a') ]
Q(s,a) = R(s,a) + gamma * Sum_o max_a' Sum_s' P(s',o|s,a) * Q(s',a')
</pre><p>Which is the update we're doing in the code. </p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="ab120caa9f9999d82a7c99bd47e091ad3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab120caa9f9999d82a7c99bd47e091ad3">&#9670;&nbsp;</a></span>FastInformedBound()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">AIToolbox::POMDP::FastInformedBound::FastInformedBound </td>
          <td>(</td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>horizon</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>tolerance</em> = <code>0.001</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Basic constructor. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">horizon</td><td>The maximum number of iterations to perform. </td></tr>
    <tr><td class="paramname">tolerance</td><td>The tolerance factor to stop the value iteration loop. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a981a6d10ccf887130463957eb2ad8a29"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a981a6d10ccf887130463957eb2ad8a29">&#9670;&nbsp;</a></span>getHorizon()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned AIToolbox::POMDP::FastInformedBound::getHorizon </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function returns the current horizon parameter. </p>
<dl class="section return"><dt>Returns</dt><dd>The currently set horizon parameter. </dd></dl>

</div>
</div>
<a id="aab6754603040a68c2f2746be246c9fd6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aab6754603040a68c2f2746be246c9fd6">&#9670;&nbsp;</a></span>getTolerance()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double AIToolbox::POMDP::FastInformedBound::getTolerance </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function returns the currently set tolerance parameter. </p>
<dl class="section return"><dt>Returns</dt><dd>The currently set tolerance parameter. </dd></dl>

</div>
</div>
<a id="aa1fdb3fce3a82514c8b9d7cb8f3a39ae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa1fdb3fce3a82514c8b9d7cb8f3a39ae">&#9670;&nbsp;</a></span>operator()() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;IsModel M&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::tuple&lt; double, <a class="el" href="namespaceAIToolbox_1_1MDP.html#a7511ad35cec2e20bf392458125e28ebc">MDP::QFunction</a> &gt; AIToolbox::POMDP::FastInformedBound::operator() </td>
          <td>(</td>
          <td class="paramtype">const M &amp;&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceAIToolbox_1_1MDP.html#a7511ad35cec2e20bf392458125e28ebc">MDP::QFunction</a> &amp;&#160;</td>
          <td class="paramname"><em>oldQ</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function computes the Fast Informed Bound for the input <a class="el" href="namespaceAIToolbox_1_1POMDP.html">POMDP</a>. </p>
<p>This function returns a QFunction since it's easier to work with. If you want to use it to act within a <a class="el" href="namespaceAIToolbox_1_1POMDP.html">POMDP</a>, check out <a class="el" href="classAIToolbox_1_1POMDP_1_1QMDP.html" title="This class implements the QMDP algorithm.">QMDP</a> which can transform it into a VList, and from there into a ValueFunction.</p>
<p>This method creates a SOSA matrix for the input model, and uses it to create the bound.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">m</td><td>The <a class="el" href="namespaceAIToolbox_1_1POMDP.html">POMDP</a> to be solved. </td></tr>
    <tr><td class="paramname">oldQ</td><td>The QFunction to start iterating from.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A tuple containing the maximum variation for the QFunction and the computed QFunction. </dd></dl>

</div>
</div>
<a id="a975d7ce35e99840cacaf01380dc93fd7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a975d7ce35e99840cacaf01380dc93fd7">&#9670;&nbsp;</a></span>operator()() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;IsModel M, typename SOSA &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::tuple&lt; double, <a class="el" href="namespaceAIToolbox_1_1MDP.html#a7511ad35cec2e20bf392458125e28ebc">MDP::QFunction</a> &gt; AIToolbox::POMDP::FastInformedBound::operator() </td>
          <td>(</td>
          <td class="paramtype">const M &amp;&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const SOSA &amp;&#160;</td>
          <td class="paramname"><em>sosa</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceAIToolbox_1_1MDP.html#a7511ad35cec2e20bf392458125e28ebc">MDP::QFunction</a>&#160;</td>
          <td class="paramname"><em>oldQ</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function computes the Fast Informed Bound for the input <a class="el" href="namespaceAIToolbox_1_1POMDP.html">POMDP</a>. </p>
<p>Internally, this method uses a SOSA matrix to improve its speed, since otherwise it'd need to multiply the transition and observation matrices over and over.</p>
<p>Since we don't usually store SOSA matrices, the other operator() computes it on the fly.</p>
<p>In case you already have a <a class="el" href="namespaceAIToolbox_1_1POMDP.html">POMDP</a> with a pre-computed SOSA matrix and don't need to recompute it, you can call this method directly.</p>
<p>You can use both sparse and dense Matrix4D for this method.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">m</td><td>The <a class="el" href="namespaceAIToolbox_1_1POMDP.html">POMDP</a> to be solved. </td></tr>
    <tr><td class="paramname">sosa</td><td>The SOSA matrix of the input <a class="el" href="namespaceAIToolbox_1_1POMDP.html">POMDP</a>. </td></tr>
    <tr><td class="paramname">oldQ</td><td>The QFunction to start iterating from.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A tuple containing the maximum variation for the QFunction and the computed QFunction. </dd></dl>

</div>
</div>
<a id="a06d15668e1edc5ae8e00674cdfc9bd01"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a06d15668e1edc5ae8e00674cdfc9bd01">&#9670;&nbsp;</a></span>setHorizon()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void AIToolbox::POMDP::FastInformedBound::setHorizon </td>
          <td>(</td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>h</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function sets the horizon parameter. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">h</td><td>The new horizon parameter. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="abdf4512027ca14b1c4f2063f33cd7ea3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abdf4512027ca14b1c4f2063f33cd7ea3">&#9670;&nbsp;</a></span>setTolerance()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void AIToolbox::POMDP::FastInformedBound::setTolerance </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>tolerance</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function sets the tolerance parameter. </p>
<p>The tolerance parameter must be &gt;= 0.0, otherwise the function will throw an std::invalid_argument. The tolerance parameter sets the convergence criterion. A tolerance of 0.0 forces the internal loop to perform a number of iterations equal to the horizon specified. Otherwise, <a class="el" href="classAIToolbox_1_1POMDP_1_1FastInformedBound.html" title="This class implements the Fast Informed Bound algorithm.">FastInformedBound</a> will stop as soon as the difference between two iterations is less than the tolerance specified.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tolerance</td><td>The new tolerance parameter. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>include/AIToolbox/POMDP/Algorithms/<a class="el" href="FastInformedBound_8hpp_source.html">FastInformedBound.hpp</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- HTML footer for doxygen 1.8.17-->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
</div>
</body>
</html>
