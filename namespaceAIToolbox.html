<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.17"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>AIToolbox: AIToolbox Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">AIToolbox
   </div>
   <div id="projectbrief">A library that offers tools for AI problem solving.</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.17 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('namespaceAIToolbox.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#namespaces">Namespaces</a> &#124;
<a href="#nested-classes">Classes</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle">
<div class="title">AIToolbox Namespace Reference</div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="namespaces"></a>
Namespaces</h2></td></tr>
<tr class="memitem:namespaceAIToolbox_1_1Bandit"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceAIToolbox_1_1Bandit.html">Bandit</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespaceAIToolbox_1_1Factored"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceAIToolbox_1_1Factored.html">Factored</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespaceAIToolbox_1_1Impl"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceAIToolbox_1_1Impl.html">Impl</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespaceAIToolbox_1_1MDP"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceAIToolbox_1_1MDP.html">MDP</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespaceAIToolbox_1_1POMDP"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceAIToolbox_1_1POMDP.html">POMDP</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structAIToolbox_1_1copy__const.html">copy_const</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This struct is used to copy constness from one type to another.  <a href="structAIToolbox_1_1copy__const.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAIToolbox_1_1EpsilonPolicyInterface.html">EpsilonPolicyInterface</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class is a policy wrapper for epsilon action choice.  <a href="classAIToolbox_1_1EpsilonPolicyInterface.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAIToolbox_1_1EpsilonPolicyInterface_3_01void_00_01void_00_01Action_01_4.html">EpsilonPolicyInterface&lt; void, void, Action &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class represents the base interface for epsilon policies in games and bandits.  <a href="classAIToolbox_1_1EpsilonPolicyInterface_3_01void_00_01void_00_01Action_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structAIToolbox_1_1identity.html">identity</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Equivalent of C++20 std::identity.  <a href="structAIToolbox_1_1identity.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAIToolbox_1_1IndexMap.html">IndexMap</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class is an iterable construct on a list of ids on a given container.  <a href="classAIToolbox_1_1IndexMap.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAIToolbox_1_1IndexMapIterator.html">IndexMapIterator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class is a simple iterator to iterate over a container with the specified ids.  <a href="classAIToolbox_1_1IndexMapIterator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAIToolbox_1_1IndexSkipMap.html">IndexSkipMap</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class is an iterable construct on a list of ids on a given container.  <a href="classAIToolbox_1_1IndexSkipMap.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAIToolbox_1_1IndexSkipMapIterator.html">IndexSkipMapIterator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class is a simple iterator to iterate over a container without the specified ids.  <a href="classAIToolbox_1_1IndexSkipMapIterator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAIToolbox_1_1LP.html">LP</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class presents a common interface for solving Linear Programming problems.  <a href="classAIToolbox_1_1LP.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structAIToolbox_1_1NoCheck.html">NoCheck</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is used to tag functions that avoid runtime checks.  <a href="structAIToolbox_1_1NoCheck.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAIToolbox_1_1PolicyInterface.html">PolicyInterface</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class represents the base interface for policies.  <a href="classAIToolbox_1_1PolicyInterface.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAIToolbox_1_1PolicyInterface_3_01void_00_01void_00_01Action_01_4.html">PolicyInterface&lt; void, void, Action &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class represents the base interface for policies in games and bandits.  <a href="classAIToolbox_1_1PolicyInterface_3_01void_00_01void_00_01Action_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAIToolbox_1_1Pruner.html">Pruner</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class offers pruning facilities for non-parsimonious ValueFunction sets.  <a href="classAIToolbox_1_1Pruner.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structAIToolbox_1_1remove__cv__ref.html">remove_cv_ref</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This struct is used to both remove references and all cv qualifiers.  <a href="structAIToolbox_1_1remove__cv__ref.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAIToolbox_1_1Statistics.html">Statistics</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class registers sets of data and computes statistics about it.  <a href="classAIToolbox_1_1Statistics.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAIToolbox_1_1SubsetEnumerator.html">SubsetEnumerator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class enumerates all possible vectors of finite subsets over N elements.  <a href="classAIToolbox_1_1SubsetEnumerator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAIToolbox_1_1VoseAliasSampler.html">VoseAliasSampler</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class represents the Alias sampling method.  <a href="classAIToolbox_1_1VoseAliasSampler.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAIToolbox_1_1WitnessLP.html">WitnessLP</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class implements an easy interface to do Witness discovery through linear programming.  <a href="classAIToolbox_1_1WitnessLP.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:af6eb1f8c89dcca62cbe9912b6ec77d33"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceAIToolbox.html#af6eb1f8c89dcca62cbe9912b6ec77d33">AILoggerFun</a> = void(int, const char *)</td></tr>
<tr class="separator:af6eb1f8c89dcca62cbe9912b6ec77d33"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a09b5db736a97adb3698ffa04ea3f4aa4"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceAIToolbox.html#a09b5db736a97adb3698ffa04ea3f4aa4">RandomEngine</a> = std::mt19937</td></tr>
<tr class="separator:a09b5db736a97adb3698ffa04ea3f4aa4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e6976de7a0159cd1630c4f2553fc9f3"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceAIToolbox.html#a1e6976de7a0159cd1630c4f2553fc9f3">Vector</a> = Eigen::Matrix&lt; double, Eigen::Dynamic, 1 &gt;</td></tr>
<tr class="separator:a1e6976de7a0159cd1630c4f2553fc9f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d66d3e9eba8d23aeef6c6b865b6965a"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceAIToolbox.html#a9d66d3e9eba8d23aeef6c6b865b6965a">Matrix2D</a> = Eigen::Matrix&lt; double, Eigen::Dynamic, Eigen::Dynamic, Eigen::RowMajor|Eigen::AutoAlign &gt;</td></tr>
<tr class="separator:a9d66d3e9eba8d23aeef6c6b865b6965a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab00da5abb5609a6454852aa726d67161"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceAIToolbox.html#ab00da5abb5609a6454852aa726d67161">SparseMatrix2D</a> = Eigen::SparseMatrix&lt; double, Eigen::RowMajor &gt;</td></tr>
<tr class="separator:ab00da5abb5609a6454852aa726d67161"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae816d088c18d4f3e13c83ae29904ef94"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceAIToolbox.html#ae816d088c18d4f3e13c83ae29904ef94">Matrix3D</a> = std::vector&lt; <a class="el" href="namespaceAIToolbox.html#a9d66d3e9eba8d23aeef6c6b865b6965a">Matrix2D</a> &gt;</td></tr>
<tr class="separator:ae816d088c18d4f3e13c83ae29904ef94"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a92d1ba8e10537e996faadb65f9c1fa77"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceAIToolbox.html#a92d1ba8e10537e996faadb65f9c1fa77">SparseMatrix3D</a> = std::vector&lt; <a class="el" href="namespaceAIToolbox.html#ab00da5abb5609a6454852aa726d67161">SparseMatrix2D</a> &gt;</td></tr>
<tr class="separator:a92d1ba8e10537e996faadb65f9c1fa77"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaa7541eece4eef765b312dc4b686852d"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceAIToolbox.html#aaa7541eece4eef765b312dc4b686852d">Matrix4D</a> = boost::multi_array&lt; <a class="el" href="namespaceAIToolbox.html#a9d66d3e9eba8d23aeef6c6b865b6965a">Matrix2D</a>, 2 &gt;</td></tr>
<tr class="separator:aaa7541eece4eef765b312dc4b686852d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5615bfca915406da608cea51152cfe5b"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceAIToolbox.html#a5615bfca915406da608cea51152cfe5b">SparseMatrix4D</a> = boost::multi_array&lt; <a class="el" href="namespaceAIToolbox.html#ab00da5abb5609a6454852aa726d67161">SparseMatrix2D</a>, 2 &gt;</td></tr>
<tr class="separator:a5615bfca915406da608cea51152cfe5b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab5ae42e63414014882288d00516e35da"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceAIToolbox.html#ab5ae42e63414014882288d00516e35da">Table2D</a> = Eigen::Matrix&lt; unsigned long, Eigen::Dynamic, Eigen::Dynamic, Eigen::RowMajor|Eigen::AutoAlign &gt;</td></tr>
<tr class="separator:ab5ae42e63414014882288d00516e35da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd8213c615b634fba0a8c8e250138ca2"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceAIToolbox.html#acd8213c615b634fba0a8c8e250138ca2">Table3D</a> = std::vector&lt; <a class="el" href="namespaceAIToolbox.html#ab5ae42e63414014882288d00516e35da">Table2D</a> &gt;</td></tr>
<tr class="separator:acd8213c615b634fba0a8c8e250138ca2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa05a760a56af0c357a5403b89474f7bc"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceAIToolbox.html#aa05a760a56af0c357a5403b89474f7bc">SparseTable2D</a> = Eigen::SparseMatrix&lt; unsigned long, Eigen::RowMajor &gt;</td></tr>
<tr class="separator:aa05a760a56af0c357a5403b89474f7bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4306fdf1fdec30a935c45405fee5af67"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceAIToolbox.html#a4306fdf1fdec30a935c45405fee5af67">SparseTable3D</a> = std::vector&lt; <a class="el" href="namespaceAIToolbox.html#aa05a760a56af0c357a5403b89474f7bc">SparseTable2D</a> &gt;</td></tr>
<tr class="separator:a4306fdf1fdec30a935c45405fee5af67"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af4149b71e91dee03ad9d0c8c207eddf0"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceAIToolbox.html#af4149b71e91dee03ad9d0c8c207eddf0">ProbabilityVector</a> = <a class="el" href="namespaceAIToolbox.html#a1e6976de7a0159cd1630c4f2553fc9f3">Vector</a></td></tr>
<tr class="separator:af4149b71e91dee03ad9d0c8c207eddf0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a65287c6295dc70f91a7ad827746f5ebe"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceAIToolbox.html#a65287c6295dc70f91a7ad827746f5ebe">DumbMatrix2D</a> = boost::multi_array&lt; double, 2 &gt;</td></tr>
<tr class="separator:a65287c6295dc70f91a7ad827746f5ebe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa09bff0da64cdd264561fe009fa85812"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceAIToolbox.html#aa09bff0da64cdd264561fe009fa85812">DumbMatrix3D</a> = boost::multi_array&lt; double, 3 &gt;</td></tr>
<tr class="separator:aa09bff0da64cdd264561fe009fa85812"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab88c33edbf6ebbfa144ef8800af259ce"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceAIToolbox.html#ab88c33edbf6ebbfa144ef8800af259ce">DumbTable2D</a> = boost::multi_array&lt; unsigned long, 2 &gt;</td></tr>
<tr class="separator:ab88c33edbf6ebbfa144ef8800af259ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8aeef0560c20679980ff9a21d7ade242"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceAIToolbox.html#a8aeef0560c20679980ff9a21d7ade242">DumbTable3D</a> = boost::multi_array&lt; unsigned long, 3 &gt;</td></tr>
<tr class="separator:a8aeef0560c20679980ff9a21d7ade242"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a967d7ac0afaa61470bc00b04df196dca"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceAIToolbox.html#a967d7ac0afaa61470bc00b04df196dca">Hyperplane</a> = <a class="el" href="namespaceAIToolbox.html#a1e6976de7a0159cd1630c4f2553fc9f3">Vector</a></td></tr>
<tr class="memdesc:a967d7ac0afaa61470bc00b04df196dca"><td class="mdescLeft">&#160;</td><td class="mdescRight">Defines a plane in a simplex where each value is the height at that corner.  <a href="namespaceAIToolbox.html#a967d7ac0afaa61470bc00b04df196dca">More...</a><br /></td></tr>
<tr class="separator:a967d7ac0afaa61470bc00b04df196dca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a917e72df43c1ed5e15caa4e8d8b80552"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceAIToolbox.html#a917e72df43c1ed5e15caa4e8d8b80552">Point</a> = <a class="el" href="namespaceAIToolbox.html#af4149b71e91dee03ad9d0c8c207eddf0">ProbabilityVector</a></td></tr>
<tr class="memdesc:a917e72df43c1ed5e15caa4e8d8b80552"><td class="mdescLeft">&#160;</td><td class="mdescRight">Defines a point inside a simplex. Coordinates sum to 1.  <a href="namespaceAIToolbox.html#a917e72df43c1ed5e15caa4e8d8b80552">More...</a><br /></td></tr>
<tr class="separator:a917e72df43c1ed5e15caa4e8d8b80552"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5baa50917e25aabd8cb3e292ce37d040"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceAIToolbox.html#a5baa50917e25aabd8cb3e292ce37d040">PointSurface</a> = std::pair&lt; std::vector&lt; <a class="el" href="namespaceAIToolbox.html#a917e72df43c1ed5e15caa4e8d8b80552">Point</a> &gt;, std::vector&lt; double &gt; &gt;</td></tr>
<tr class="memdesc:a5baa50917e25aabd8cb3e292ce37d040"><td class="mdescLeft">&#160;</td><td class="mdescRight">A surface within a simplex defined by points and their height. Should not contain the corners.  <a href="namespaceAIToolbox.html#a5baa50917e25aabd8cb3e292ce37d040">More...</a><br /></td></tr>
<tr class="separator:a5baa50917e25aabd8cb3e292ce37d040"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a196a2986a1edf009b2c2f057aae24b71"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceAIToolbox.html#a196a2986a1edf009b2c2f057aae24b71">CompactHyperplanes</a> = <a class="el" href="namespaceAIToolbox.html#a9d66d3e9eba8d23aeef6c6b865b6965a">Matrix2D</a></td></tr>
<tr class="memdesc:a196a2986a1edf009b2c2f057aae24b71"><td class="mdescLeft">&#160;</td><td class="mdescRight">A compact set of (probably |A|) hyperplanes, one per column (probably |S| rows). This is generally used with PointSurface; otherwise we use a vector&lt;Hyperplane&gt;.  <a href="namespaceAIToolbox.html#a196a2986a1edf009b2c2f057aae24b71">More...</a><br /></td></tr>
<tr class="separator:a196a2986a1edf009b2c2f057aae24b71"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae1f932b6473be1c052e5f14aa85180d0"><td class="memTemplParams" colspan="2">template&lt;typename CopiedType , typename ConstReference &gt; </td></tr>
<tr class="memitem:ae1f932b6473be1c052e5f14aa85180d0"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceAIToolbox.html#ae1f932b6473be1c052e5f14aa85180d0">copy_const_t</a> = typename <a class="el" href="structAIToolbox_1_1copy__const.html">copy_const</a>&lt; CopiedType, ConstReference &gt;::type</td></tr>
<tr class="separator:ae1f932b6473be1c052e5f14aa85180d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a03f42a5910cd868eb0af71b7491d420d"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a03f42a5910cd868eb0af71b7491d420d"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceAIToolbox.html#a03f42a5910cd868eb0af71b7491d420d">remove_cv_ref_t</a> = typename <a class="el" href="structAIToolbox_1_1remove__cv__ref.html">remove_cv_ref</a>&lt; T &gt;::type</td></tr>
<tr class="separator:a03f42a5910cd868eb0af71b7491d420d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a6ca50b6d2585387be42d0ae76205f34a"><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceAIToolbox.html#a6ca50b6d2585387be42d0ae76205f34a">operator&lt;&lt;</a> (std::ostream &amp;os, const <a class="el" href="classAIToolbox_1_1Statistics.html">Statistics</a> &amp;rh)</td></tr>
<tr class="memdesc:a6ca50b6d2585387be42d0ae76205f34a"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function writes the output of the <a class="el" href="classAIToolbox_1_1Statistics.html" title="This class registers sets of data and computes statistics about it.">Statistics</a> to the stream.  <a href="namespaceAIToolbox.html#a6ca50b6d2585387be42d0ae76205f34a">More...</a><br /></td></tr>
<tr class="separator:a6ca50b6d2585387be42d0ae76205f34a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ade5a791c00b531a438fd130591ee0809"><td class="memItemLeft" align="right" valign="top">unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceAIToolbox.html#ade5a791c00b531a438fd130591ee0809">nChooseK</a> (unsigned n, unsigned k)</td></tr>
<tr class="memdesc:ade5a791c00b531a438fd130591ee0809"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns (n k); i.e. n choose k.  <a href="namespaceAIToolbox.html#ade5a791c00b531a438fd130591ee0809">More...</a><br /></td></tr>
<tr class="separator:ade5a791c00b531a438fd130591ee0809"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acc2c6fcda7af327c205dae20fc162d35"><td class="memItemLeft" align="right" valign="top">unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceAIToolbox.html#acc2c6fcda7af327c205dae20fc162d35">starsBars</a> (unsigned stars, unsigned bars)</td></tr>
<tr class="memdesc:acc2c6fcda7af327c205dae20fc162d35"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of stars/bars combinations.  <a href="namespaceAIToolbox.html#acc2c6fcda7af327c205dae20fc162d35">More...</a><br /></td></tr>
<tr class="separator:acc2c6fcda7af327c205dae20fc162d35"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f6c1c85280fc7a2d5c2cf96c72ca770"><td class="memItemLeft" align="right" valign="top">unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceAIToolbox.html#a9f6c1c85280fc7a2d5c2cf96c72ca770">ballsBins</a> (unsigned balls, unsigned bins)</td></tr>
<tr class="memdesc:a9f6c1c85280fc7a2d5c2cf96c72ca770"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of balls/bins combinations.  <a href="namespaceAIToolbox.html#a9f6c1c85280fc7a2d5c2cf96c72ca770">More...</a><br /></td></tr>
<tr class="separator:a9f6c1c85280fc7a2d5c2cf96c72ca770"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a089de7e55bbd13310ce6f3d5296932af"><td class="memItemLeft" align="right" valign="top">unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceAIToolbox.html#a089de7e55bbd13310ce6f3d5296932af">nonZeroStarsBars</a> (unsigned stars, unsigned bars)</td></tr>
<tr class="memdesc:a089de7e55bbd13310ce6f3d5296932af"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of stars/bars combinations.  <a href="namespaceAIToolbox.html#a089de7e55bbd13310ce6f3d5296932af">More...</a><br /></td></tr>
<tr class="separator:a089de7e55bbd13310ce6f3d5296932af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaecaab4f7eee1001fa0c46fb93c98201"><td class="memItemLeft" align="right" valign="top">unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceAIToolbox.html#aaecaab4f7eee1001fa0c46fb93c98201">nonZeroBallsBins</a> (unsigned balls, unsigned bins)</td></tr>
<tr class="memdesc:aaecaab4f7eee1001fa0c46fb93c98201"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of balls/bins combinations.  <a href="namespaceAIToolbox.html#aaecaab4f7eee1001fa0c46fb93c98201">More...</a><br /></td></tr>
<tr class="separator:aaecaab4f7eee1001fa0c46fb93c98201"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a59fe3a76d13567f94fde660335fff93b"><td class="memItemLeft" align="right" valign="top">unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceAIToolbox.html#a59fe3a76d13567f94fde660335fff93b">ceil</a> (unsigned x, unsigned y)</td></tr>
<tr class="memdesc:a59fe3a76d13567f94fde660335fff93b"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function returns a fast ceiling between two unsigned ints.  <a href="namespaceAIToolbox.html#a59fe3a76d13567f94fde660335fff93b">More...</a><br /></td></tr>
<tr class="separator:a59fe3a76d13567f94fde660335fff93b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a164ff36d8475927a491a18c990a9e199"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceAIToolbox.html#a164ff36d8475927a491a18c990a9e199">checkEqualSmall</a> (const double a, const double b)</td></tr>
<tr class="memdesc:a164ff36d8475927a491a18c990a9e199"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function checks if two doubles near [0,1] are reasonably equal.  <a href="namespaceAIToolbox.html#a164ff36d8475927a491a18c990a9e199">More...</a><br /></td></tr>
<tr class="separator:a164ff36d8475927a491a18c990a9e199"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:add1da51b88333c412b0978a7e95581f1"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceAIToolbox.html#add1da51b88333c412b0978a7e95581f1">checkDifferentSmall</a> (const double a, const double b)</td></tr>
<tr class="memdesc:add1da51b88333c412b0978a7e95581f1"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function checks if two doubles near [0,1] are reasonably different.  <a href="namespaceAIToolbox.html#add1da51b88333c412b0978a7e95581f1">More...</a><br /></td></tr>
<tr class="separator:add1da51b88333c412b0978a7e95581f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1cb49a3d6b7ce2588edec044a541e88e"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceAIToolbox.html#a1cb49a3d6b7ce2588edec044a541e88e">checkEqualGeneral</a> (const double a, const double b)</td></tr>
<tr class="memdesc:a1cb49a3d6b7ce2588edec044a541e88e"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function checks if two doubles are reasonably equal.  <a href="namespaceAIToolbox.html#a1cb49a3d6b7ce2588edec044a541e88e">More...</a><br /></td></tr>
<tr class="separator:a1cb49a3d6b7ce2588edec044a541e88e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a67f283ebe30cd11e1eead7a814057945"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceAIToolbox.html#a67f283ebe30cd11e1eead7a814057945">checkDifferentGeneral</a> (const double a, const double b)</td></tr>
<tr class="memdesc:a67f283ebe30cd11e1eead7a814057945"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function checks if two doubles are reasonably different.  <a href="namespaceAIToolbox.html#a67f283ebe30cd11e1eead7a814057945">More...</a><br /></td></tr>
<tr class="separator:a67f283ebe30cd11e1eead7a814057945"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a18765a780a9488b129cb8334e16e370a"><td class="memTemplParams" colspan="2">template&lt;typename V &gt; </td></tr>
<tr class="memitem:a18765a780a9488b129cb8334e16e370a"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceAIToolbox.html#a18765a780a9488b129cb8334e16e370a">checkEqualSmall</a> (const V &amp;v, const double d)</td></tr>
<tr class="memdesc:a18765a780a9488b129cb8334e16e370a"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function checks whether a given vector only contains the stated value.  <a href="namespaceAIToolbox.html#a18765a780a9488b129cb8334e16e370a">More...</a><br /></td></tr>
<tr class="separator:a18765a780a9488b129cb8334e16e370a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6797db6216af3a252546a74690bda979"><td class="memTemplParams" colspan="2">template&lt;typename V &gt; </td></tr>
<tr class="memitem:a6797db6216af3a252546a74690bda979"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceAIToolbox.html#a6797db6216af3a252546a74690bda979">checkDifferentSmall</a> (const V &amp;v, const double d)</td></tr>
<tr class="memdesc:a6797db6216af3a252546a74690bda979"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function checks whether a given vector does not contain only the stated value.  <a href="namespaceAIToolbox.html#a6797db6216af3a252546a74690bda979">More...</a><br /></td></tr>
<tr class="separator:a6797db6216af3a252546a74690bda979"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a71946ca7560a469505d9e449841b40d1"><td class="memTemplParams" colspan="2">template&lt;typename V &gt; </td></tr>
<tr class="memitem:a71946ca7560a469505d9e449841b40d1"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceAIToolbox.html#a71946ca7560a469505d9e449841b40d1">checkEqualGeneral</a> (const V &amp;v, const double d)</td></tr>
<tr class="memdesc:a71946ca7560a469505d9e449841b40d1"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function checks whether a given vector only contains the stated value.  <a href="namespaceAIToolbox.html#a71946ca7560a469505d9e449841b40d1">More...</a><br /></td></tr>
<tr class="separator:a71946ca7560a469505d9e449841b40d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a65413c83ea777c89684f5d901ea33679"><td class="memTemplParams" colspan="2">template&lt;typename V &gt; </td></tr>
<tr class="memitem:a65413c83ea777c89684f5d901ea33679"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceAIToolbox.html#a65413c83ea777c89684f5d901ea33679">checkDifferentGeneral</a> (const V &amp;v, const double d)</td></tr>
<tr class="memdesc:a65413c83ea777c89684f5d901ea33679"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function checks whether a given vector does not contain only the stated value.  <a href="namespaceAIToolbox.html#a65413c83ea777c89684f5d901ea33679">More...</a><br /></td></tr>
<tr class="separator:a65413c83ea777c89684f5d901ea33679"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a111282b4c465f34023497869fdeecd58"><td class="memTemplParams" colspan="2">template&lt;typename V &gt; </td></tr>
<tr class="memitem:a111282b4c465f34023497869fdeecd58"><td class="memTemplItemLeft" align="right" valign="top">int&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceAIToolbox.html#a111282b4c465f34023497869fdeecd58">veccmp</a> (const V &amp;lhs, const V &amp;rhs)</td></tr>
<tr class="memdesc:a111282b4c465f34023497869fdeecd58"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function compares two general vectors of equal size lexicographically.  <a href="namespaceAIToolbox.html#a111282b4c465f34023497869fdeecd58">More...</a><br /></td></tr>
<tr class="separator:a111282b4c465f34023497869fdeecd58"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad0927a8f10c7aa36aa7d341fab1834fc"><td class="memTemplParams" colspan="2">template&lt;typename V &gt; </td></tr>
<tr class="memitem:ad0927a8f10c7aa36aa7d341fab1834fc"><td class="memTemplItemLeft" align="right" valign="top">int&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceAIToolbox.html#ad0927a8f10c7aa36aa7d341fab1834fc">veccmpSmall</a> (const V &amp;lhs, const V &amp;rhs)</td></tr>
<tr class="memdesc:ad0927a8f10c7aa36aa7d341fab1834fc"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function compares two general vectors of equal size lexicographically.  <a href="namespaceAIToolbox.html#ad0927a8f10c7aa36aa7d341fab1834fc">More...</a><br /></td></tr>
<tr class="separator:ad0927a8f10c7aa36aa7d341fab1834fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ad90c42f9cf72812707724c6a669161"><td class="memTemplParams" colspan="2">template&lt;typename V &gt; </td></tr>
<tr class="memitem:a2ad90c42f9cf72812707724c6a669161"><td class="memTemplItemLeft" align="right" valign="top">int&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceAIToolbox.html#a2ad90c42f9cf72812707724c6a669161">veccmpGeneral</a> (const V &amp;lhs, const V &amp;rhs)</td></tr>
<tr class="memdesc:a2ad90c42f9cf72812707724c6a669161"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function compares two general vectors of equal size lexicographically.  <a href="namespaceAIToolbox.html#a2ad90c42f9cf72812707724c6a669161">More...</a><br /></td></tr>
<tr class="separator:a2ad90c42f9cf72812707724c6a669161"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:add1a336767c8dd3b7999237a1149818a"><td class="memTemplParams" colspan="2">template&lt;typename It &gt; </td></tr>
<tr class="memitem:add1a336767c8dd3b7999237a1149818a"><td class="memTemplItemLeft" align="right" valign="top">It&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceAIToolbox.html#add1a336767c8dd3b7999237a1149818a">sequential_sorted_find</a> (It begin, It end, const typename std::iterator_traits&lt; It &gt;::value_type &amp;elem)</td></tr>
<tr class="memdesc:add1a336767c8dd3b7999237a1149818a"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function returns an iterator to the position where the input should be in a sorted range, via sequential scan.  <a href="namespaceAIToolbox.html#add1a336767c8dd3b7999237a1149818a">More...</a><br /></td></tr>
<tr class="separator:add1a336767c8dd3b7999237a1149818a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae70933a8434d22f0d888527a5d72e5ad"><td class="memTemplParams" colspan="2">template&lt;typename It &gt; </td></tr>
<tr class="memitem:ae70933a8434d22f0d888527a5d72e5ad"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceAIToolbox.html#ae70933a8434d22f0d888527a5d72e5ad">sequential_sorted_contains</a> (It begin, It end, const typename std::iterator_traits&lt; It &gt;::value_type &amp;elem)</td></tr>
<tr class="memdesc:ae70933a8434d22f0d888527a5d72e5ad"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function returns whether a sorted range contains a given element, via sequential scan.  <a href="namespaceAIToolbox.html#ae70933a8434d22f0d888527a5d72e5ad">More...</a><br /></td></tr>
<tr class="separator:ae70933a8434d22f0d888527a5d72e5ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb9131cfadf0600e435b545dbf0b5fc9"><td class="memTemplParams" colspan="2">template&lt;typename V &gt; </td></tr>
<tr class="memitem:acb9131cfadf0600e435b545dbf0b5fc9"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceAIToolbox.html#acb9131cfadf0600e435b545dbf0b5fc9">sequential_sorted_contains</a> (const V &amp;v, const V &amp;elems)</td></tr>
<tr class="memdesc:acb9131cfadf0600e435b545dbf0b5fc9"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function returns whether a sorted range contains another sorted range, via sequential scan.  <a href="namespaceAIToolbox.html#acb9131cfadf0600e435b545dbf0b5fc9">More...</a><br /></td></tr>
<tr class="separator:acb9131cfadf0600e435b545dbf0b5fc9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a68e4594e4010a8d2e5d731f94a33c2fb"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a68e4594e4010a8d2e5d731f94a33c2fb"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceAIToolbox.html#a68e4594e4010a8d2e5d731f94a33c2fb">set_union_inplace</a> (std::vector&lt; T &gt; &amp;lhs, const std::vector&lt; T &gt; &amp;rhs)</td></tr>
<tr class="memdesc:a68e4594e4010a8d2e5d731f94a33c2fb"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function performs an inplace union of two sorted sets.  <a href="namespaceAIToolbox.html#a68e4594e4010a8d2e5d731f94a33c2fb">More...</a><br /></td></tr>
<tr class="separator:a68e4594e4010a8d2e5d731f94a33c2fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ae0c23572526182d5fd984223c580c4"><td class="memTemplParams" colspan="2">template&lt;typename It , typename F &gt; </td></tr>
<tr class="memitem:a2ae0c23572526182d5fd984223c580c4"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceAIToolbox.html#a2ae0c23572526182d5fd984223c580c4">max_element_unary</a> (It begin, const It end, F unary_converter)</td></tr>
<tr class="memdesc:a2ae0c23572526182d5fd984223c580c4"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function is equivalent to std::max_element, but takes a unary function.  <a href="namespaceAIToolbox.html#a2ae0c23572526182d5fd984223c580c4">More...</a><br /></td></tr>
<tr class="separator:a2ae0c23572526182d5fd984223c580c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ef6c271697802b01b05562715052bf4"><td class="memTemplParams" colspan="2">template&lt;typename T , typename U &gt; </td></tr>
<tr class="memitem:a2ef6c271697802b01b05562715052bf4"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceAIToolbox.html#a2ef6c271697802b01b05562715052bf4">copyDumb3D</a> (const T &amp;in, U &amp;out, const size_t d1, const size_t d2, const size_t d3)</td></tr>
<tr class="memdesc:a2ef6c271697802b01b05562715052bf4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies a 3d container into another 3d container.  <a href="namespaceAIToolbox.html#a2ef6c271697802b01b05562715052bf4">More...</a><br /></td></tr>
<tr class="separator:a2ef6c271697802b01b05562715052bf4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc040c10bbec513dac4ee154328d799f"><td class="memTemplParams" colspan="2">template&lt;class T , class Container &gt; </td></tr>
<tr class="memitem:afc040c10bbec513dac4ee154328d799f"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceAIToolbox.html#afc040c10bbec513dac4ee154328d799f">IndexMap</a> (std::initializer_list&lt; T &gt; i, Container c) -&gt; <a class="el" href="classAIToolbox_1_1IndexMap.html">IndexMap</a>&lt; std::vector&lt; T &gt;, Container &gt;</td></tr>
<tr class="separator:afc040c10bbec513dac4ee154328d799f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0ad1be4bb3c810a6b25373d91a28038e"><td class="memTemplParams" colspan="2">template&lt;class T , class Container &gt; </td></tr>
<tr class="memitem:a0ad1be4bb3c810a6b25373d91a28038e"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceAIToolbox.html#a0ad1be4bb3c810a6b25373d91a28038e">IndexSkipMap</a> (std::initializer_list&lt; T &gt; i, Container c) -&gt; <a class="el" href="classAIToolbox_1_1IndexSkipMap.html">IndexSkipMap</a>&lt; std::vector&lt; T &gt;, Container &gt;</td></tr>
<tr class="separator:a0ad1be4bb3c810a6b25373d91a28038e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa6c3c00a1d06d54b24559c996972183"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceAIToolbox.html#afa6c3c00a1d06d54b24559c996972183">dominates</a> (const <a class="el" href="namespaceAIToolbox.html#a967d7ac0afaa61470bc00b04df196dca">Hyperplane</a> &amp;lhs, const <a class="el" href="namespaceAIToolbox.html#a967d7ac0afaa61470bc00b04df196dca">Hyperplane</a> &amp;rhs)</td></tr>
<tr class="memdesc:afa6c3c00a1d06d54b24559c996972183"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function checks whether an Hyperplane dominates another.  <a href="namespaceAIToolbox.html#afa6c3c00a1d06d54b24559c996972183">More...</a><br /></td></tr>
<tr class="separator:afa6c3c00a1d06d54b24559c996972183"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b4429b1f3771a012553ce96c2760f8a"><td class="memTemplParams" colspan="2">template&lt;typename Iterator , typename P  = identity&gt; </td></tr>
<tr class="memitem:a1b4429b1f3771a012553ce96c2760f8a"><td class="memTemplItemLeft" align="right" valign="top">Iterator&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceAIToolbox.html#a1b4429b1f3771a012553ce96c2760f8a">findBestAtPoint</a> (const <a class="el" href="namespaceAIToolbox.html#a917e72df43c1ed5e15caa4e8d8b80552">Point</a> &amp;point, Iterator begin, Iterator end, double *value=nullptr, P p=P{})</td></tr>
<tr class="memdesc:a1b4429b1f3771a012553ce96c2760f8a"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function returns an iterator pointing to the best Hyperplane for the specified point.  <a href="namespaceAIToolbox.html#a1b4429b1f3771a012553ce96c2760f8a">More...</a><br /></td></tr>
<tr class="separator:a1b4429b1f3771a012553ce96c2760f8a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc68b38e82940ad0963445f1a44ce64a"><td class="memTemplParams" colspan="2">template&lt;typename Iterator , typename P  = identity&gt; </td></tr>
<tr class="memitem:afc68b38e82940ad0963445f1a44ce64a"><td class="memTemplItemLeft" align="right" valign="top">Iterator&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceAIToolbox.html#afc68b38e82940ad0963445f1a44ce64a">findBestAtSimplexCorner</a> (const size_t corner, Iterator begin, Iterator end, double *value=nullptr, P p=P{})</td></tr>
<tr class="memdesc:afc68b38e82940ad0963445f1a44ce64a"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function returns an iterator pointing to the best Hyperplane for the specified corner of the simplex space.  <a href="namespaceAIToolbox.html#afc68b38e82940ad0963445f1a44ce64a">More...</a><br /></td></tr>
<tr class="separator:afc68b38e82940ad0963445f1a44ce64a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9c125f5564ca7a035861f4bad13f59b1"><td class="memTemplParams" colspan="2">template&lt;typename Iterator , typename P  = identity&gt; </td></tr>
<tr class="memitem:a9c125f5564ca7a035861f4bad13f59b1"><td class="memTemplItemLeft" align="right" valign="top">Iterator&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceAIToolbox.html#a9c125f5564ca7a035861f4bad13f59b1">findBestDeltaDominated</a> (const <a class="el" href="namespaceAIToolbox.html#a917e72df43c1ed5e15caa4e8d8b80552">Point</a> &amp;point, const <a class="el" href="namespaceAIToolbox.html#a967d7ac0afaa61470bc00b04df196dca">Hyperplane</a> &amp;plane, double delta, Iterator begin, Iterator end, P p=P{})</td></tr>
<tr class="memdesc:a9c125f5564ca7a035861f4bad13f59b1"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function returns, if it exists, an iterator to the highest Hyperplane that delta-dominates the input one.  <a href="namespaceAIToolbox.html#a9c125f5564ca7a035861f4bad13f59b1">More...</a><br /></td></tr>
<tr class="separator:a9c125f5564ca7a035861f4bad13f59b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0cda3496f7e84c8247fc3c7fac1c93f2"><td class="memTemplParams" colspan="2">template&lt;typename Iterator , typename P  = identity&gt; </td></tr>
<tr class="memitem:a0cda3496f7e84c8247fc3c7fac1c93f2"><td class="memTemplItemLeft" align="right" valign="top">Iterator&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceAIToolbox.html#a0cda3496f7e84c8247fc3c7fac1c93f2">extractBestAtPoint</a> (const <a class="el" href="namespaceAIToolbox.html#a917e72df43c1ed5e15caa4e8d8b80552">Point</a> &amp;point, Iterator begin, Iterator bound, Iterator end, P p=P{})</td></tr>
<tr class="memdesc:a0cda3496f7e84c8247fc3c7fac1c93f2"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function finds and moves the Hyperplane with the highest value for the given point at the beginning of the specified range.  <a href="namespaceAIToolbox.html#a0cda3496f7e84c8247fc3c7fac1c93f2">More...</a><br /></td></tr>
<tr class="separator:a0cda3496f7e84c8247fc3c7fac1c93f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac8ff7b74b51c088cda28e9371e4c2988"><td class="memTemplParams" colspan="2">template&lt;typename Iterator , typename P  = identity&gt; </td></tr>
<tr class="memitem:ac8ff7b74b51c088cda28e9371e4c2988"><td class="memTemplItemLeft" align="right" valign="top">Iterator&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceAIToolbox.html#ac8ff7b74b51c088cda28e9371e4c2988">extractBestAtSimplexCorners</a> (const size_t S, Iterator begin, Iterator bound, Iterator end, P p=P{})</td></tr>
<tr class="memdesc:ac8ff7b74b51c088cda28e9371e4c2988"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function finds and moves all best Hyperplanes in the simplex corners at the beginning of the specified range.  <a href="namespaceAIToolbox.html#ac8ff7b74b51c088cda28e9371e4c2988">More...</a><br /></td></tr>
<tr class="separator:ac8ff7b74b51c088cda28e9371e4c2988"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac4875f77e08a1ef6b4828279ac74aa23"><td class="memTemplParams" colspan="2">template&lt;typename PIterator , typename VIterator , typename P  = identity&gt; </td></tr>
<tr class="memitem:ac4875f77e08a1ef6b4828279ac74aa23"><td class="memTemplItemLeft" align="right" valign="top">PIterator&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceAIToolbox.html#ac4875f77e08a1ef6b4828279ac74aa23">extractBestUsefulPoints</a> (PIterator pbegin, PIterator pend, VIterator begin, VIterator end, P p=P{})</td></tr>
<tr class="memdesc:ac4875f77e08a1ef6b4828279ac74aa23"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function finds and moves all non-useful points at the end of the input range.  <a href="namespaceAIToolbox.html#ac4875f77e08a1ef6b4828279ac74aa23">More...</a><br /></td></tr>
<tr class="separator:ac4875f77e08a1ef6b4828279ac74aa23"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af8ab0db4b1347fdd3a0b383a185b9f98"><td class="memTemplParams" colspan="2">template&lt;typename NewIt , typename OldIt , typename P1  = identity, typename P2  = identity&gt; </td></tr>
<tr class="memitem:af8ab0db4b1347fdd3a0b383a185b9f98"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespaceAIToolbox.html#a5baa50917e25aabd8cb3e292ce37d040">PointSurface</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceAIToolbox.html#af8ab0db4b1347fdd3a0b383a185b9f98">findVerticesNaive</a> (NewIt beginNew, NewIt endNew, OldIt alphasBegin, OldIt alphasEnd, P1 p1=P1{}, P2 p2=P2{})</td></tr>
<tr class="memdesc:af8ab0db4b1347fdd3a0b383a185b9f98"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function implements a naive vertex enumeration algorithm.  <a href="namespaceAIToolbox.html#af8ab0db4b1347fdd3a0b383a185b9f98">More...</a><br /></td></tr>
<tr class="separator:af8ab0db4b1347fdd3a0b383a185b9f98"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a92a200c6c709aad831698f2bf145d7c1"><td class="memTemplParams" colspan="2">template&lt;typename Range , typename P  = identity&gt; </td></tr>
<tr class="memitem:a92a200c6c709aad831698f2bf145d7c1"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespaceAIToolbox.html#a5baa50917e25aabd8cb3e292ce37d040">PointSurface</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceAIToolbox.html#a92a200c6c709aad831698f2bf145d7c1">findVerticesNaive</a> (const Range &amp;range, P p=P{})</td></tr>
<tr class="memdesc:a92a200c6c709aad831698f2bf145d7c1"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function returns all vertices for a given range of planes.  <a href="namespaceAIToolbox.html#a92a200c6c709aad831698f2bf145d7c1">More...</a><br /></td></tr>
<tr class="separator:a92a200c6c709aad831698f2bf145d7c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b0abfe5d76cd15d737279e7955cbea6"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceAIToolbox.html#a6b0abfe5d76cd15d737279e7955cbea6">computeOptimisticValue</a> (const <a class="el" href="namespaceAIToolbox.html#a917e72df43c1ed5e15caa4e8d8b80552">Point</a> &amp;p, const std::vector&lt; <a class="el" href="namespaceAIToolbox.html#a917e72df43c1ed5e15caa4e8d8b80552">Point</a> &gt; &amp;points, const std::vector&lt; double &gt; &amp;values)</td></tr>
<tr class="memdesc:a6b0abfe5d76cd15d737279e7955cbea6"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function computes the optimistic value of a point given known vertices and values.  <a href="namespaceAIToolbox.html#a6b0abfe5d76cd15d737279e7955cbea6">More...</a><br /></td></tr>
<tr class="separator:a6b0abfe5d76cd15d737279e7955cbea6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab6541804d91ba3c11903fd8d29f34bcc"><td class="memItemLeft" align="right" valign="top">std::tuple&lt; double, <a class="el" href="namespaceAIToolbox.html#a1e6976de7a0159cd1630c4f2553fc9f3">Vector</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceAIToolbox.html#ab6541804d91ba3c11903fd8d29f34bcc">LPInterpolation</a> (const <a class="el" href="namespaceAIToolbox.html#a917e72df43c1ed5e15caa4e8d8b80552">Point</a> &amp;p, const <a class="el" href="namespaceAIToolbox.html#a196a2986a1edf009b2c2f057aae24b71">CompactHyperplanes</a> &amp;ubQ, const <a class="el" href="namespaceAIToolbox.html#a5baa50917e25aabd8cb3e292ce37d040">PointSurface</a> &amp;ubV)</td></tr>
<tr class="memdesc:ab6541804d91ba3c11903fd8d29f34bcc"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function computes the exact value of the input Point w.r.t. the given surfaces.  <a href="namespaceAIToolbox.html#ab6541804d91ba3c11903fd8d29f34bcc">More...</a><br /></td></tr>
<tr class="separator:ab6541804d91ba3c11903fd8d29f34bcc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3aec9476bc80e36874b755a4cf111dce"><td class="memItemLeft" align="right" valign="top">std::tuple&lt; double, <a class="el" href="namespaceAIToolbox.html#a1e6976de7a0159cd1630c4f2553fc9f3">Vector</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceAIToolbox.html#a3aec9476bc80e36874b755a4cf111dce">sawtoothInterpolation</a> (const <a class="el" href="namespaceAIToolbox.html#a917e72df43c1ed5e15caa4e8d8b80552">Point</a> &amp;p, const <a class="el" href="namespaceAIToolbox.html#a196a2986a1edf009b2c2f057aae24b71">CompactHyperplanes</a> &amp;ubQ, const <a class="el" href="namespaceAIToolbox.html#a5baa50917e25aabd8cb3e292ce37d040">PointSurface</a> &amp;ubV)</td></tr>
<tr class="memdesc:a3aec9476bc80e36874b755a4cf111dce"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function computes an approximate, but quick, upper bound on the surface value at the input point.  <a href="namespaceAIToolbox.html#a3aec9476bc80e36874b755a4cf111dce">More...</a><br /></td></tr>
<tr class="separator:a3aec9476bc80e36874b755a4cf111dce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa33180c05494468c0f7afa2262384ce7"><td class="memItemLeft" align="right" valign="top">static std::uniform_real_distribution&lt; double &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceAIToolbox.html#aa33180c05494468c0f7afa2262384ce7">probabilityDistribution</a> (0.0, 1.0)</td></tr>
<tr class="separator:aa33180c05494468c0f7afa2262384ce7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5d4052078699d21068b648273ec9dcf6"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a5d4052078699d21068b648273ec9dcf6"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceAIToolbox.html#a5d4052078699d21068b648273ec9dcf6">isProbability</a> (const size_t d, const T &amp;in)</td></tr>
<tr class="memdesc:a5d4052078699d21068b648273ec9dcf6"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function checks whether the supplied vector is a correct probability vector.  <a href="namespaceAIToolbox.html#a5d4052078699d21068b648273ec9dcf6">More...</a><br /></td></tr>
<tr class="separator:a5d4052078699d21068b648273ec9dcf6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad73352f6ce65aa95f76b7399cf0d2cb0"><td class="memTemplParams" colspan="2">template&lt;typename T , typename G &gt; </td></tr>
<tr class="memitem:ad73352f6ce65aa95f76b7399cf0d2cb0"><td class="memTemplItemLeft" align="right" valign="top">size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceAIToolbox.html#ad73352f6ce65aa95f76b7399cf0d2cb0">sampleProbability</a> (const size_t d, const T &amp;in, G &amp;generator)</td></tr>
<tr class="memdesc:ad73352f6ce65aa95f76b7399cf0d2cb0"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function samples an index from a probability vector.  <a href="namespaceAIToolbox.html#ad73352f6ce65aa95f76b7399cf0d2cb0">More...</a><br /></td></tr>
<tr class="separator:ad73352f6ce65aa95f76b7399cf0d2cb0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a31fb7fd3eb6b455f39a1bd388a5fd264"><td class="memTemplParams" colspan="2">template&lt;typename G &gt; </td></tr>
<tr class="memitem:a31fb7fd3eb6b455f39a1bd388a5fd264"><td class="memTemplItemLeft" align="right" valign="top">size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceAIToolbox.html#a31fb7fd3eb6b455f39a1bd388a5fd264">sampleProbability</a> (const size_t d, const SparseMatrix2D::ConstRowXpr &amp;in, G &amp;generator)</td></tr>
<tr class="memdesc:a31fb7fd3eb6b455f39a1bd388a5fd264"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function samples an index from a sparse probability vector.  <a href="namespaceAIToolbox.html#a31fb7fd3eb6b455f39a1bd388a5fd264">More...</a><br /></td></tr>
<tr class="separator:a31fb7fd3eb6b455f39a1bd388a5fd264"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2a0814792b2a6cf30eaa196d4571bd9b"><td class="memTemplParams" colspan="2">template&lt;typename G &gt; </td></tr>
<tr class="memitem:a2a0814792b2a6cf30eaa196d4571bd9b"><td class="memTemplItemLeft" align="right" valign="top">double&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceAIToolbox.html#a2a0814792b2a6cf30eaa196d4571bd9b">sampleBetaDistribution</a> (double a, double b, G &amp;generator)</td></tr>
<tr class="memdesc:a2a0814792b2a6cf30eaa196d4571bd9b"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function samples from a Beta distribution.  <a href="namespaceAIToolbox.html#a2a0814792b2a6cf30eaa196d4571bd9b">More...</a><br /></td></tr>
<tr class="separator:a2a0814792b2a6cf30eaa196d4571bd9b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a74fd0fb7396717f9f2751bf2f3121dc0"><td class="memTemplParams" colspan="2">template&lt;typename TIn , typename G &gt; </td></tr>
<tr class="memitem:a74fd0fb7396717f9f2751bf2f3121dc0"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespaceAIToolbox.html#af4149b71e91dee03ad9d0c8c207eddf0">ProbabilityVector</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceAIToolbox.html#a74fd0fb7396717f9f2751bf2f3121dc0">sampleDirichletDistribution</a> (const TIn &amp;params, G &amp;generator)</td></tr>
<tr class="memdesc:a74fd0fb7396717f9f2751bf2f3121dc0"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function samples from the input Dirichlet distribution.  <a href="namespaceAIToolbox.html#a74fd0fb7396717f9f2751bf2f3121dc0">More...</a><br /></td></tr>
<tr class="separator:a74fd0fb7396717f9f2751bf2f3121dc0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9fe13af882ae35ca664adbb08663e2ad"><td class="memTemplParams" colspan="2">template&lt;typename TIn , typename TOut , typename G &gt; </td></tr>
<tr class="memitem:a9fe13af882ae35ca664adbb08663e2ad"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceAIToolbox.html#a9fe13af882ae35ca664adbb08663e2ad">sampleDirichletDistribution</a> (const TIn &amp;params, G &amp;generator, TOut &amp;&amp;out)</td></tr>
<tr class="memdesc:a9fe13af882ae35ca664adbb08663e2ad"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function samples from the input Dirichlet distribution inline.  <a href="namespaceAIToolbox.html#a9fe13af882ae35ca664adbb08663e2ad">More...</a><br /></td></tr>
<tr class="separator:a9fe13af882ae35ca664adbb08663e2ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a476a8ac48b42df366183a01594f78dac"><td class="memTemplParams" colspan="2">template&lt;typename G &gt; </td></tr>
<tr class="memitem:a476a8ac48b42df366183a01594f78dac"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespaceAIToolbox.html#af4149b71e91dee03ad9d0c8c207eddf0">ProbabilityVector</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceAIToolbox.html#a476a8ac48b42df366183a01594f78dac">makeRandomProbability</a> (const size_t S, G &amp;generator)</td></tr>
<tr class="memdesc:a476a8ac48b42df366183a01594f78dac"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function generates a random probability vector.  <a href="namespaceAIToolbox.html#a476a8ac48b42df366183a01594f78dac">More...</a><br /></td></tr>
<tr class="separator:a476a8ac48b42df366183a01594f78dac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e60a055a590bbd22deb801d1a0121a6"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceAIToolbox.html#a0e60a055a590bbd22deb801d1a0121a6">checkEqualProbability</a> (const <a class="el" href="namespaceAIToolbox.html#af4149b71e91dee03ad9d0c8c207eddf0">ProbabilityVector</a> &amp;lhs, const <a class="el" href="namespaceAIToolbox.html#af4149b71e91dee03ad9d0c8c207eddf0">ProbabilityVector</a> &amp;rhs)</td></tr>
<tr class="memdesc:a0e60a055a590bbd22deb801d1a0121a6"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function checks whether two input ProbabilityVector are equal.  <a href="namespaceAIToolbox.html#a0e60a055a590bbd22deb801d1a0121a6">More...</a><br /></td></tr>
<tr class="separator:a0e60a055a590bbd22deb801d1a0121a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0560565550b4432765a4b9126aa770e6"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceAIToolbox.html#a0560565550b4432765a4b9126aa770e6">getEntropy</a> (const <a class="el" href="namespaceAIToolbox.html#af4149b71e91dee03ad9d0c8c207eddf0">ProbabilityVector</a> &amp;v)</td></tr>
<tr class="memdesc:a0560565550b4432765a4b9126aa770e6"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function returns the entropy of the input ProbabilityVector.  <a href="namespaceAIToolbox.html#a0560565550b4432765a4b9126aa770e6">More...</a><br /></td></tr>
<tr class="separator:a0560565550b4432765a4b9126aa770e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b76378b9a911994f2f3c237e94997bc"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceAIToolbox.html#a4b76378b9a911994f2f3c237e94997bc">getEntropyBase2</a> (const <a class="el" href="namespaceAIToolbox.html#af4149b71e91dee03ad9d0c8c207eddf0">ProbabilityVector</a> &amp;v)</td></tr>
<tr class="memdesc:a4b76378b9a911994f2f3c237e94997bc"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function returns the entropy of the input ProbabilityVector computed using log2.  <a href="namespaceAIToolbox.html#a4b76378b9a911994f2f3c237e94997bc">More...</a><br /></td></tr>
<tr class="separator:a4b76378b9a911994f2f3c237e94997bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad1d02a7b4abada909d8d0b620496d381"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceAIToolbox.html#af4149b71e91dee03ad9d0c8c207eddf0">ProbabilityVector</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceAIToolbox.html#ad1d02a7b4abada909d8d0b620496d381">projectToProbability</a> (const <a class="el" href="namespaceAIToolbox.html#a1e6976de7a0159cd1630c4f2553fc9f3">Vector</a> &amp;v)</td></tr>
<tr class="memdesc:ad1d02a7b4abada909d8d0b620496d381"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function projects the input vector to a valid probability space.  <a href="namespaceAIToolbox.html#ad1d02a7b4abada909d8d0b620496d381">More...</a><br /></td></tr>
<tr class="separator:ad1d02a7b4abada909d8d0b620496d381"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad460c77a4bf9eb827a0bf62ed09266df"><td class="memTemplParams" colspan="2">template&lt;typename Iterator , typename P  = identity&gt; </td></tr>
<tr class="memitem:ad460c77a4bf9eb827a0bf62ed09266df"><td class="memTemplItemLeft" align="right" valign="top">Iterator&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceAIToolbox.html#ad460c77a4bf9eb827a0bf62ed09266df">extractDominated</a> (Iterator begin, Iterator end, P p=P{})</td></tr>
<tr class="memdesc:ad460c77a4bf9eb827a0bf62ed09266df"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function finds and moves all Hyperplanes in the range that are dominated by others.  <a href="namespaceAIToolbox.html#ad460c77a4bf9eb827a0bf62ed09266df">More...</a><br /></td></tr>
<tr class="separator:ad460c77a4bf9eb827a0bf62ed09266df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a63d2a6f73c7f817403ec9ffb6d2a2ab2"><td class="memTemplParams" colspan="2">template&lt;typename Iterator , typename P  = identity&gt; </td></tr>
<tr class="memitem:a63d2a6f73c7f817403ec9ffb6d2a2ab2"><td class="memTemplItemLeft" align="right" valign="top">std::tuple&lt; Iterator, Iterator, Iterator &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceAIToolbox.html#a63d2a6f73c7f817403ec9ffb6d2a2ab2">extractDominatedIncremental</a> (Iterator begin, Iterator newBegin, Iterator end, P p=P{})</td></tr>
<tr class="memdesc:a63d2a6f73c7f817403ec9ffb6d2a2ab2"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function finds and moves all Hyperplanes in the range that are dominated by others.  <a href="namespaceAIToolbox.html#a63d2a6f73c7f817403ec9ffb6d2a2ab2">More...</a><br /></td></tr>
<tr class="separator:a63d2a6f73c7f817403ec9ffb6d2a2ab2"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:a7ac7114c76d8082333e9222fd1aac187"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceAIToolbox.html#af6eb1f8c89dcca62cbe9912b6ec77d33">AILoggerFun</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceAIToolbox.html#a7ac7114c76d8082333e9222fd1aac187">AILogger</a> = nullptr</td></tr>
<tr class="memdesc:a7ac7114c76d8082333e9222fd1aac187"><td class="mdescLeft">&#160;</td><td class="mdescRight">This pointer defines the function used to log.  <a href="namespaceAIToolbox.html#a7ac7114c76d8082333e9222fd1aac187">More...</a><br /></td></tr>
<tr class="separator:a7ac7114c76d8082333e9222fd1aac187"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab17c75e0097c109e4737f2c1215c2dd6"><td class="memItemLeft" align="right" valign="top">struct <a class="el" href="structAIToolbox_1_1NoCheck.html">AIToolbox::NoCheck</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceAIToolbox.html#ab17c75e0097c109e4737f2c1215c2dd6">NO_CHECK</a></td></tr>
<tr class="separator:ab17c75e0097c109e4737f2c1215c2dd6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a395f82018bc6d027736805fec404d482"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceAIToolbox.html#a395f82018bc6d027736805fec404d482">equalToleranceSmall</a> = 0.000001</td></tr>
<tr class="memdesc:a395f82018bc6d027736805fec404d482"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is the max absolute difference for which two values can be considered equal.  <a href="namespaceAIToolbox.html#a395f82018bc6d027736805fec404d482">More...</a><br /></td></tr>
<tr class="separator:a395f82018bc6d027736805fec404d482"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad6fe7471894e7e26ec5a51003997d258"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceAIToolbox.html#ad6fe7471894e7e26ec5a51003997d258">equalToleranceGeneral</a> = 0.00000000001</td></tr>
<tr class="separator:ad6fe7471894e7e26ec5a51003997d258"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Typedef Documentation</h2>
<a id="af6eb1f8c89dcca62cbe9912b6ec77d33"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af6eb1f8c89dcca62cbe9912b6ec77d33">&#9670;&nbsp;</a></span>AILoggerFun</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceAIToolbox.html#af6eb1f8c89dcca62cbe9912b6ec77d33">AIToolbox::AILoggerFun</a> = typedef void(int, const char *)</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a196a2986a1edf009b2c2f057aae24b71"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a196a2986a1edf009b2c2f057aae24b71">&#9670;&nbsp;</a></span>CompactHyperplanes</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceAIToolbox.html#a196a2986a1edf009b2c2f057aae24b71">AIToolbox::CompactHyperplanes</a> = typedef <a class="el" href="namespaceAIToolbox.html#a9d66d3e9eba8d23aeef6c6b865b6965a">Matrix2D</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A compact set of (probably |A|) hyperplanes, one per column (probably |S| rows). This is generally used with PointSurface; otherwise we use a vector&lt;Hyperplane&gt;. </p>

</div>
</div>
<a id="ae1f932b6473be1c052e5f14aa85180d0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae1f932b6473be1c052e5f14aa85180d0">&#9670;&nbsp;</a></span>copy_const_t</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename CopiedType , typename ConstReference &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceAIToolbox.html#ae1f932b6473be1c052e5f14aa85180d0">AIToolbox::copy_const_t</a> = typedef typename <a class="el" href="structAIToolbox_1_1copy__const.html">copy_const</a>&lt;CopiedType, ConstReference&gt;::type</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a65287c6295dc70f91a7ad827746f5ebe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a65287c6295dc70f91a7ad827746f5ebe">&#9670;&nbsp;</a></span>DumbMatrix2D</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceAIToolbox.html#a65287c6295dc70f91a7ad827746f5ebe">AIToolbox::DumbMatrix2D</a> = typedef boost::multi_array&lt;double, 2&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aa09bff0da64cdd264561fe009fa85812"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa09bff0da64cdd264561fe009fa85812">&#9670;&nbsp;</a></span>DumbMatrix3D</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceAIToolbox.html#aa09bff0da64cdd264561fe009fa85812">AIToolbox::DumbMatrix3D</a> = typedef boost::multi_array&lt;double, 3&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ab88c33edbf6ebbfa144ef8800af259ce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab88c33edbf6ebbfa144ef8800af259ce">&#9670;&nbsp;</a></span>DumbTable2D</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceAIToolbox.html#ab88c33edbf6ebbfa144ef8800af259ce">AIToolbox::DumbTable2D</a> = typedef boost::multi_array&lt;unsigned long, 2&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a8aeef0560c20679980ff9a21d7ade242"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8aeef0560c20679980ff9a21d7ade242">&#9670;&nbsp;</a></span>DumbTable3D</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceAIToolbox.html#a8aeef0560c20679980ff9a21d7ade242">AIToolbox::DumbTable3D</a> = typedef boost::multi_array&lt;unsigned long, 3&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a967d7ac0afaa61470bc00b04df196dca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a967d7ac0afaa61470bc00b04df196dca">&#9670;&nbsp;</a></span>Hyperplane</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceAIToolbox.html#a967d7ac0afaa61470bc00b04df196dca">AIToolbox::Hyperplane</a> = typedef <a class="el" href="namespaceAIToolbox.html#a1e6976de7a0159cd1630c4f2553fc9f3">Vector</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Defines a plane in a simplex where each value is the height at that corner. </p>

</div>
</div>
<a id="a9d66d3e9eba8d23aeef6c6b865b6965a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9d66d3e9eba8d23aeef6c6b865b6965a">&#9670;&nbsp;</a></span>Matrix2D</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceAIToolbox.html#a9d66d3e9eba8d23aeef6c6b865b6965a">AIToolbox::Matrix2D</a> = typedef Eigen::Matrix&lt;double, Eigen::Dynamic, Eigen::Dynamic, Eigen::RowMajor | Eigen::AutoAlign&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ae816d088c18d4f3e13c83ae29904ef94"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae816d088c18d4f3e13c83ae29904ef94">&#9670;&nbsp;</a></span>Matrix3D</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceAIToolbox.html#ae816d088c18d4f3e13c83ae29904ef94">AIToolbox::Matrix3D</a> = typedef std::vector&lt;<a class="el" href="namespaceAIToolbox.html#a9d66d3e9eba8d23aeef6c6b865b6965a">Matrix2D</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aaa7541eece4eef765b312dc4b686852d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaa7541eece4eef765b312dc4b686852d">&#9670;&nbsp;</a></span>Matrix4D</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceAIToolbox.html#aaa7541eece4eef765b312dc4b686852d">AIToolbox::Matrix4D</a> = typedef boost::multi_array&lt;<a class="el" href="namespaceAIToolbox.html#a9d66d3e9eba8d23aeef6c6b865b6965a">Matrix2D</a>, 2&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a917e72df43c1ed5e15caa4e8d8b80552"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a917e72df43c1ed5e15caa4e8d8b80552">&#9670;&nbsp;</a></span>Point</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceAIToolbox.html#a917e72df43c1ed5e15caa4e8d8b80552">AIToolbox::Point</a> = typedef <a class="el" href="namespaceAIToolbox.html#af4149b71e91dee03ad9d0c8c207eddf0">ProbabilityVector</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Defines a point inside a simplex. Coordinates sum to 1. </p>

</div>
</div>
<a id="a5baa50917e25aabd8cb3e292ce37d040"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5baa50917e25aabd8cb3e292ce37d040">&#9670;&nbsp;</a></span>PointSurface</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceAIToolbox.html#a5baa50917e25aabd8cb3e292ce37d040">AIToolbox::PointSurface</a> = typedef std::pair&lt;std::vector&lt;<a class="el" href="namespaceAIToolbox.html#a917e72df43c1ed5e15caa4e8d8b80552">Point</a>&gt;, std::vector&lt;double&gt; &gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A surface within a simplex defined by points and their height. Should not contain the corners. </p>

</div>
</div>
<a id="af4149b71e91dee03ad9d0c8c207eddf0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af4149b71e91dee03ad9d0c8c207eddf0">&#9670;&nbsp;</a></span>ProbabilityVector</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceAIToolbox.html#af4149b71e91dee03ad9d0c8c207eddf0">AIToolbox::ProbabilityVector</a> = typedef <a class="el" href="namespaceAIToolbox.html#a1e6976de7a0159cd1630c4f2553fc9f3">Vector</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a09b5db736a97adb3698ffa04ea3f4aa4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a09b5db736a97adb3698ffa04ea3f4aa4">&#9670;&nbsp;</a></span>RandomEngine</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceAIToolbox.html#a09b5db736a97adb3698ffa04ea3f4aa4">AIToolbox::RandomEngine</a> = typedef std::mt19937</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a03f42a5910cd868eb0af71b7491d420d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a03f42a5910cd868eb0af71b7491d420d">&#9670;&nbsp;</a></span>remove_cv_ref_t</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceAIToolbox.html#a03f42a5910cd868eb0af71b7491d420d">AIToolbox::remove_cv_ref_t</a> = typedef typename <a class="el" href="structAIToolbox_1_1remove__cv__ref.html">remove_cv_ref</a>&lt;T&gt;::type</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ab00da5abb5609a6454852aa726d67161"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab00da5abb5609a6454852aa726d67161">&#9670;&nbsp;</a></span>SparseMatrix2D</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceAIToolbox.html#ab00da5abb5609a6454852aa726d67161">AIToolbox::SparseMatrix2D</a> = typedef Eigen::SparseMatrix&lt;double, Eigen::RowMajor&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a92d1ba8e10537e996faadb65f9c1fa77"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a92d1ba8e10537e996faadb65f9c1fa77">&#9670;&nbsp;</a></span>SparseMatrix3D</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceAIToolbox.html#a92d1ba8e10537e996faadb65f9c1fa77">AIToolbox::SparseMatrix3D</a> = typedef std::vector&lt;<a class="el" href="namespaceAIToolbox.html#ab00da5abb5609a6454852aa726d67161">SparseMatrix2D</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a5615bfca915406da608cea51152cfe5b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5615bfca915406da608cea51152cfe5b">&#9670;&nbsp;</a></span>SparseMatrix4D</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceAIToolbox.html#a5615bfca915406da608cea51152cfe5b">AIToolbox::SparseMatrix4D</a> = typedef boost::multi_array&lt;<a class="el" href="namespaceAIToolbox.html#ab00da5abb5609a6454852aa726d67161">SparseMatrix2D</a>, 2&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aa05a760a56af0c357a5403b89474f7bc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa05a760a56af0c357a5403b89474f7bc">&#9670;&nbsp;</a></span>SparseTable2D</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceAIToolbox.html#aa05a760a56af0c357a5403b89474f7bc">AIToolbox::SparseTable2D</a> = typedef Eigen::SparseMatrix&lt;unsigned long, Eigen::RowMajor&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a4306fdf1fdec30a935c45405fee5af67"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4306fdf1fdec30a935c45405fee5af67">&#9670;&nbsp;</a></span>SparseTable3D</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceAIToolbox.html#a4306fdf1fdec30a935c45405fee5af67">AIToolbox::SparseTable3D</a> = typedef std::vector&lt;<a class="el" href="namespaceAIToolbox.html#aa05a760a56af0c357a5403b89474f7bc">SparseTable2D</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ab5ae42e63414014882288d00516e35da"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab5ae42e63414014882288d00516e35da">&#9670;&nbsp;</a></span>Table2D</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceAIToolbox.html#ab5ae42e63414014882288d00516e35da">AIToolbox::Table2D</a> = typedef Eigen::Matrix&lt;unsigned long, Eigen::Dynamic, Eigen::Dynamic, Eigen::RowMajor | Eigen::AutoAlign&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="acd8213c615b634fba0a8c8e250138ca2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acd8213c615b634fba0a8c8e250138ca2">&#9670;&nbsp;</a></span>Table3D</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceAIToolbox.html#acd8213c615b634fba0a8c8e250138ca2">AIToolbox::Table3D</a> = typedef std::vector&lt;<a class="el" href="namespaceAIToolbox.html#ab5ae42e63414014882288d00516e35da">Table2D</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a1e6976de7a0159cd1630c4f2553fc9f3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1e6976de7a0159cd1630c4f2553fc9f3">&#9670;&nbsp;</a></span>Vector</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceAIToolbox.html#a1e6976de7a0159cd1630c4f2553fc9f3">AIToolbox::Vector</a> = typedef Eigen::Matrix&lt;double, Eigen::Dynamic, 1&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="a9f6c1c85280fc7a2d5c2cf96c72ca770"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9f6c1c85280fc7a2d5c2cf96c72ca770">&#9670;&nbsp;</a></span>ballsBins()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned AIToolbox::ballsBins </td>
          <td>(</td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>balls</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>bins</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the number of balls/bins combinations. </p>
<p>This function returns the number of combinations in which you can split a set of indistinguishable balls into a set of distinguishable bins.</p>
<p>This is equivalent to starsBars(balls, bins - 1).</p>
<p>Note: bins shall NOT be equal to 0. </p>

</div>
</div>
<a id="a59fe3a76d13567f94fde660335fff93b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a59fe3a76d13567f94fde660335fff93b">&#9670;&nbsp;</a></span>ceil()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned AIToolbox::ceil </td>
          <td>(</td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This function returns a fast ceiling between two unsigned ints. </p>
<p>Note: we do x + y, so it may overflow.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>The dividend. </td></tr>
    <tr><td class="paramname">y</td><td>The divisor.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The ceiling from the integer division. </dd></dl>

</div>
</div>
<a id="a67f283ebe30cd11e1eead7a814057945"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a67f283ebe30cd11e1eead7a814057945">&#9670;&nbsp;</a></span>checkDifferentGeneral() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool AIToolbox::checkDifferentGeneral </td>
          <td>(</td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This function checks if two doubles are reasonably different. </p>
<p>The order of the parameters is not important.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>The first number to compare. </td></tr>
    <tr><td class="paramname">b</td><td>The second number to compare.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the two numbers are far away enough, false otherwise. </dd></dl>

</div>
</div>
<a id="a65413c83ea777c89684f5d901ea33679"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a65413c83ea777c89684f5d901ea33679">&#9670;&nbsp;</a></span>checkDifferentGeneral() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename V &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool AIToolbox::checkDifferentGeneral </td>
          <td>(</td>
          <td class="paramtype">const V &amp;&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>d</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function checks whether a given vector does not contain only the stated value. </p>
<dl class="section return"><dt>Returns</dt><dd>True if not all elements are equal to the input. </dd></dl>

</div>
</div>
<a id="add1da51b88333c412b0978a7e95581f1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#add1da51b88333c412b0978a7e95581f1">&#9670;&nbsp;</a></span>checkDifferentSmall() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool AIToolbox::checkDifferentSmall </td>
          <td>(</td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This function checks if two doubles near [0,1] are reasonably different. </p>
<p>If the numbers are not near [0,1], the result is not guaranteed to be what may be expected. The order of the parameters is not important.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>The first number to compare. </td></tr>
    <tr><td class="paramname">b</td><td>The second number to compare.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the two numbers are far away enough, false otherwise. </dd></dl>

</div>
</div>
<a id="a6797db6216af3a252546a74690bda979"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6797db6216af3a252546a74690bda979">&#9670;&nbsp;</a></span>checkDifferentSmall() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename V &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool AIToolbox::checkDifferentSmall </td>
          <td>(</td>
          <td class="paramtype">const V &amp;&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>d</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function checks whether a given vector does not contain only the stated value. </p>
<dl class="section return"><dt>Returns</dt><dd>True if not all elements are equal to the input. </dd></dl>

</div>
</div>
<a id="a1cb49a3d6b7ce2588edec044a541e88e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1cb49a3d6b7ce2588edec044a541e88e">&#9670;&nbsp;</a></span>checkEqualGeneral() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool AIToolbox::checkEqualGeneral </td>
          <td>(</td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This function checks if two doubles are reasonably equal. </p>
<p>The order of the parameters is not important.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>The first number to compare. </td></tr>
    <tr><td class="paramname">b</td><td>The second number to compare.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the two numbers are close enough, false otherwise. </dd></dl>

</div>
</div>
<a id="a71946ca7560a469505d9e449841b40d1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a71946ca7560a469505d9e449841b40d1">&#9670;&nbsp;</a></span>checkEqualGeneral() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename V &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool AIToolbox::checkEqualGeneral </td>
          <td>(</td>
          <td class="paramtype">const V &amp;&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>d</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function checks whether a given vector only contains the stated value. </p>
<p>This function compares using <a class="el" href="namespaceAIToolbox.html#a1cb49a3d6b7ce2588edec044a541e88e" title="This function checks if two doubles are reasonably equal.">checkEqualGeneral(double, double)</a>;</p>
<dl class="section return"><dt>Returns</dt><dd>True if all elements are compared equal to the input. </dd></dl>

</div>
</div>
<a id="a0e60a055a590bbd22deb801d1a0121a6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0e60a055a590bbd22deb801d1a0121a6">&#9670;&nbsp;</a></span>checkEqualProbability()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool AIToolbox::checkEqualProbability </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceAIToolbox.html#af4149b71e91dee03ad9d0c8c207eddf0">ProbabilityVector</a> &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceAIToolbox.html#af4149b71e91dee03ad9d0c8c207eddf0">ProbabilityVector</a> &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This function checks whether two input ProbabilityVector are equal. </p>
<p>This function is approximate. It assumes that the vectors are valid, so they must sum up to one, and each element must be between zero and one. The vector must also be of the same size.</p>
<p>This function is approximate, as we're dealing with floating point.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>The left hand side to check. </td></tr>
    <tr><td class="paramname">rhs</td><td>The right hand side to check.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Whether the two ProbabilityVectors are the same. </dd></dl>

</div>
</div>
<a id="a164ff36d8475927a491a18c990a9e199"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a164ff36d8475927a491a18c990a9e199">&#9670;&nbsp;</a></span>checkEqualSmall() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool AIToolbox::checkEqualSmall </td>
          <td>(</td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This function checks if two doubles near [0,1] are reasonably equal. </p>
<p>If the numbers are not near [0,1], the result is not guaranteed to be what may be expected. The order of the parameters is not important.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>The first number to compare. </td></tr>
    <tr><td class="paramname">b</td><td>The second number to compare.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the two numbers are close enough, false otherwise. </dd></dl>

</div>
</div>
<a id="a18765a780a9488b129cb8334e16e370a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a18765a780a9488b129cb8334e16e370a">&#9670;&nbsp;</a></span>checkEqualSmall() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename V &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool AIToolbox::checkEqualSmall </td>
          <td>(</td>
          <td class="paramtype">const V &amp;&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>d</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function checks whether a given vector only contains the stated value. </p>
<p>This function compares using <a class="el" href="namespaceAIToolbox.html#a164ff36d8475927a491a18c990a9e199" title="This function checks if two doubles near [0,1] are reasonably equal.">checkEqualSmall(double, double)</a>;</p>
<dl class="section return"><dt>Returns</dt><dd>True if all elements are compared equal to the input. </dd></dl>

</div>
</div>
<a id="a6b0abfe5d76cd15d737279e7955cbea6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6b0abfe5d76cd15d737279e7955cbea6">&#9670;&nbsp;</a></span>computeOptimisticValue()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double AIToolbox::computeOptimisticValue </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceAIToolbox.html#a917e72df43c1ed5e15caa4e8d8b80552">Point</a> &amp;&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="namespaceAIToolbox.html#a917e72df43c1ed5e15caa4e8d8b80552">Point</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>points</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>values</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function computes the optimistic value of a point given known vertices and values. </p>
<p>This function computes an <a class="el" href="classAIToolbox_1_1LP.html" title="This class presents a common interface for solving Linear Programming problems.">LP</a> to determine the best possible value of a point given all known best vertices around it.</p>
<p>This function is needed in multi-objective settings (rather than POMDPs), since the step where we compute the optimal value for a given point is extremely expensive (it requires solving a full <a class="el" href="namespaceAIToolbox_1_1MDP.html">MDP</a>). Thus linear programming is used in order to determine an optimistic bound when deciding the next point to extract from the queue during the linear support process.</p>
<p>Note that the input is the same as a PointSurface; the two components have been kept as separate arguments simply to allow more freedom to the user.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>The point where we want to compute the best possible value. </td></tr>
    <tr><td class="paramname">points</td><td>The points that make up the surface. </td></tr>
    <tr><td class="paramname">values</td><td>The respective values of the input points.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The best possible value that the input point can have given the known vertices. </dd></dl>

</div>
</div>
<a id="a2ef6c271697802b01b05562715052bf4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2ef6c271697802b01b05562715052bf4">&#9670;&nbsp;</a></span>copyDumb3D()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename U &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void AIToolbox::copyDumb3D </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">U &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>d1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>d2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>d3</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Copies a 3d container into another 3d container. </p>
<p>The containers needs to support data access through operator[]. In addition, the dimensions of the containers must match the ones specified.</p>
<p>This is important, as this function DOES NOT perform any size checks on the containers.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Type of the input container. </td></tr>
    <tr><td class="paramname">U</td><td>Type of the output container. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">in</td><td>Input container. </td></tr>
    <tr><td class="paramname">out</td><td>Output container. </td></tr>
    <tr><td class="paramname">d1</td><td>First dimension of the containers. </td></tr>
    <tr><td class="paramname">d2</td><td>Second dimension of the containers. </td></tr>
    <tr><td class="paramname">d3</td><td>Third dimension of the containers. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="afa6c3c00a1d06d54b24559c996972183"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afa6c3c00a1d06d54b24559c996972183">&#9670;&nbsp;</a></span>dominates()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool AIToolbox::dominates </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceAIToolbox.html#a967d7ac0afaa61470bc00b04df196dca">Hyperplane</a> &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceAIToolbox.html#a967d7ac0afaa61470bc00b04df196dca">Hyperplane</a> &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This function checks whether an Hyperplane dominates another. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>The Hyperplane that should dominate. </td></tr>
    <tr><td class="paramname">rhs</td><td>The Hyperplane that should be dominated.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Whether the left hand side dominates the right hand side. </dd></dl>

</div>
</div>
<a id="a0cda3496f7e84c8247fc3c7fac1c93f2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0cda3496f7e84c8247fc3c7fac1c93f2">&#9670;&nbsp;</a></span>extractBestAtPoint()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Iterator , typename P  = identity&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Iterator AIToolbox::extractBestAtPoint </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceAIToolbox.html#a917e72df43c1ed5e15caa4e8d8b80552">Point</a> &amp;&#160;</td>
          <td class="paramname"><em>point</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Iterator&#160;</td>
          <td class="paramname"><em>begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Iterator&#160;</td>
          <td class="paramname"><em>bound</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Iterator&#160;</td>
          <td class="paramname"><em>end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">P&#160;</td>
          <td class="paramname"><em>p</em> = <code>P{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function finds and moves the Hyperplane with the highest value for the given point at the beginning of the specified range. </p>
<p>This function uses an already existing bound containing previously marked useful hyperplanes. The order is 'begin'-&gt;'bound'-&gt;'end', where bound may be equal to end where no previous bound exists. The found hyperplane is moved between 'begin' and 'bound', but only if it was not there previously.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>The point where we need to check the value </td></tr>
    <tr><td class="paramname">begin</td><td>The begin of the search range. </td></tr>
    <tr><td class="paramname">bound</td><td>The begin of the 'useful' range. </td></tr>
    <tr><td class="paramname">end</td><td>The range end to be checked. It is NOT included in the search. </td></tr>
    <tr><td class="paramname">p</td><td>A projection function to call on the iterators (defaults to identity).</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The new bound iterator. </dd></dl>

</div>
</div>
<a id="ac8ff7b74b51c088cda28e9371e4c2988"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac8ff7b74b51c088cda28e9371e4c2988">&#9670;&nbsp;</a></span>extractBestAtSimplexCorners()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Iterator , typename P  = identity&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Iterator AIToolbox::extractBestAtSimplexCorners </td>
          <td>(</td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>S</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Iterator&#160;</td>
          <td class="paramname"><em>begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Iterator&#160;</td>
          <td class="paramname"><em>bound</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Iterator&#160;</td>
          <td class="paramname"><em>end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">P&#160;</td>
          <td class="paramname"><em>p</em> = <code>P{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function finds and moves all best Hyperplanes in the simplex corners at the beginning of the specified range. </p>
<p>What this function does is to find out which hyperplanes give the highest value in the corner points. Since multiple corners may use the same hyperplanes, the number of found hyperplanes may not be the same as the number of corners.</p>
<p>This function uses an already existing bound containing previously marked useful hyperplanes. The order is 'begin'-&gt;'bound'-&gt;'end', where bound may be equal to end where no previous bound exists. All found hyperplanes are added between 'begin' and 'bound', but only if they were not there previously.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">S</td><td>The number of corners of the simplex. </td></tr>
    <tr><td class="paramname">begin</td><td>The begin of the search range. </td></tr>
    <tr><td class="paramname">bound</td><td>The begin of the 'useful' range. </td></tr>
    <tr><td class="paramname">end</td><td>The end of the search range. It is NOT included in the search. </td></tr>
    <tr><td class="paramname">p</td><td>A projection function to call on the iterators (defaults to identity).</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The new bound iterator. </dd></dl>

</div>
</div>
<a id="ac4875f77e08a1ef6b4828279ac74aa23"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac4875f77e08a1ef6b4828279ac74aa23">&#9670;&nbsp;</a></span>extractBestUsefulPoints()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PIterator , typename VIterator , typename P  = identity&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">PIterator AIToolbox::extractBestUsefulPoints </td>
          <td>(</td>
          <td class="paramtype">PIterator&#160;</td>
          <td class="paramname"><em>pbegin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PIterator&#160;</td>
          <td class="paramname"><em>pend</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VIterator&#160;</td>
          <td class="paramname"><em>begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VIterator&#160;</td>
          <td class="paramname"><em>end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">P&#160;</td>
          <td class="paramname"><em>p</em> = <code>P{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function finds and moves all non-useful points at the end of the input range. </p>
<p>This function helps remove points which do not support any hyperplane and are thus not useful for improving the overall surface.</p>
<p>This function moves all non-useful points at the end of the input range, and returns the resulting iterator pointing to the first non-useful point.</p>
<p>When multiple Points support the same Hyperplane, the one with the best value is returned.</p>
<p>The Hyperplane range may contain elements which are not supported by any of the input Points (although if they exist they may slow down the function).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pbegin</td><td>The beginning of the Point range to check. </td></tr>
    <tr><td class="paramname">pend</td><td>The end of the Point range to check. </td></tr>
    <tr><td class="paramname">begin</td><td>The beginning of the Hyperplane range to check against. </td></tr>
    <tr><td class="paramname">end</td><td>The end of the Hyperplane range to check against. </td></tr>
    <tr><td class="paramname">p</td><td>A projection function to call on the iterators (defaults to identity).</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An iterator pointing to the first non-useful Point. </dd></dl>

</div>
</div>
<a id="ad460c77a4bf9eb827a0bf62ed09266df"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad460c77a4bf9eb827a0bf62ed09266df">&#9670;&nbsp;</a></span>extractDominated()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Iterator , typename P  = identity&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Iterator AIToolbox::extractDominated </td>
          <td>(</td>
          <td class="paramtype">Iterator&#160;</td>
          <td class="paramname"><em>begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Iterator&#160;</td>
          <td class="paramname"><em>end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">P&#160;</td>
          <td class="paramname"><em>p</em> = <code>P{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function finds and moves all Hyperplanes in the range that are dominated by others. </p>
<p>This function performs simple comparisons between all Hyperplanes in the range, and is thus much more performant than a full-fledged prune, since that would need to solve multiple linear programming problems. However, this function will not return the truly parsimonious set of Hyperplanes, as its pruning powers are limited.</p>
<p>Dominated elements will be moved at the end of the range for safe removal.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">begin</td><td>The begin of the list that needs to be pruned. </td></tr>
    <tr><td class="paramname">end</td><td>The end of the list that needs to be pruned. </td></tr>
    <tr><td class="paramname">p</td><td>A projection function to call on the iterators (defaults to identity).</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The iterator that separates dominated elements with non-pruned. </dd></dl>

</div>
</div>
<a id="a63d2a6f73c7f817403ec9ffb6d2a2ab2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a63d2a6f73c7f817403ec9ffb6d2a2ab2">&#9670;&nbsp;</a></span>extractDominatedIncremental()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Iterator , typename P  = identity&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::tuple&lt;Iterator, Iterator, Iterator&gt; AIToolbox::extractDominatedIncremental </td>
          <td>(</td>
          <td class="paramtype">Iterator&#160;</td>
          <td class="paramname"><em>begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Iterator&#160;</td>
          <td class="paramname"><em>newBegin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Iterator&#160;</td>
          <td class="paramname"><em>end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">P&#160;</td>
          <td class="paramname"><em>p</em> = <code>P{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function finds and moves all Hyperplanes in the range that are dominated by others. </p>
<p>This function is similar to extractDominated, with the additional assumption that a certain set of Hyperplanes do not dominate each other. This function can be useful to extract dominated Hyperplanes after new ones have been added to an already pruned set. This function would then skip re-checking between the already pruned Hyperplanes.</p>
<p>This function assumes that the new additions are not that many with respect to the already validated Hyperplanes. If that's not the case, it's possible that extractDominated might be faster.</p>
<p>Dominated elements will be moved at the end of the range for safe removal.</p>
<p>In order to enable possible optimizations, entries are kept grouped in four groups: still good old entries, good new entries, dominated old entries and dominated new entries. Note that the initial ordering of these sub-ranges is lost.</p>
<p>We return the three iterators needed to identify these four ranges (together with the provided begin and end iterators).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">begin</td><td>The begin of the list that needs to be pruned. </td></tr>
    <tr><td class="paramname">newBegin</td><td>The begin of the new Hyperplanes that need to be checked. </td></tr>
    <tr><td class="paramname">end</td><td>The end of the list that needs to be pruned. </td></tr>
    <tr><td class="paramname">p</td><td>A projection function to call on the iterators (defaults to identity).</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Three iterators demarking the various filtered ranges: old, new, dominated old. </dd></dl>

</div>
</div>
<a id="a1b4429b1f3771a012553ce96c2760f8a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1b4429b1f3771a012553ce96c2760f8a">&#9670;&nbsp;</a></span>findBestAtPoint()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Iterator , typename P  = identity&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Iterator AIToolbox::findBestAtPoint </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceAIToolbox.html#a917e72df43c1ed5e15caa4e8d8b80552">Point</a> &amp;&#160;</td>
          <td class="paramname"><em>point</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Iterator&#160;</td>
          <td class="paramname"><em>begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Iterator&#160;</td>
          <td class="paramname"><em>end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>value</em> = <code>nullptr</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">P&#160;</td>
          <td class="paramname"><em>p</em> = <code>P{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function returns an iterator pointing to the best Hyperplane for the specified point. </p>
<p>Given a list of hyperplanes as a surface, this function returns the hyperplane which provides the highest value at the specified point.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>The point where we need to check the value </td></tr>
    <tr><td class="paramname">begin</td><td>The start of the range to look in. </td></tr>
    <tr><td class="paramname">end</td><td>The end of the range to look in (excluded). </td></tr>
    <tr><td class="paramname">value</td><td>A pointer to double, which gets set to the value of the given point with the found Hyperplane. </td></tr>
    <tr><td class="paramname">p</td><td>A projection function to call on the iterators (defaults to identity).</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An iterator pointing to the best choice in range. </dd></dl>

</div>
</div>
<a id="afc68b38e82940ad0963445f1a44ce64a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afc68b38e82940ad0963445f1a44ce64a">&#9670;&nbsp;</a></span>findBestAtSimplexCorner()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Iterator , typename P  = identity&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Iterator AIToolbox::findBestAtSimplexCorner </td>
          <td>(</td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>corner</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Iterator&#160;</td>
          <td class="paramname"><em>begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Iterator&#160;</td>
          <td class="paramname"><em>end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>value</em> = <code>nullptr</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">P&#160;</td>
          <td class="paramname"><em>p</em> = <code>P{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function returns an iterator pointing to the best Hyperplane for the specified corner of the simplex space. </p>
<p>This function is slightly more efficient than findBestAtPoint for a simplex corner.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">corner</td><td>The corner of the simplex space we are checking. </td></tr>
    <tr><td class="paramname">begin</td><td>The start of the range to look in. </td></tr>
    <tr><td class="paramname">end</td><td>The end of the range to look in (excluded). </td></tr>
    <tr><td class="paramname">p</td><td>A projection function to call on the iterators (defaults to identity).</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An iterator pointing to the best choice in range. </dd></dl>

</div>
</div>
<a id="a9c125f5564ca7a035861f4bad13f59b1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9c125f5564ca7a035861f4bad13f59b1">&#9670;&nbsp;</a></span>findBestDeltaDominated()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Iterator , typename P  = identity&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Iterator AIToolbox::findBestDeltaDominated </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceAIToolbox.html#a917e72df43c1ed5e15caa4e8d8b80552">Point</a> &amp;&#160;</td>
          <td class="paramname"><em>point</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceAIToolbox.html#a967d7ac0afaa61470bc00b04df196dca">Hyperplane</a> &amp;&#160;</td>
          <td class="paramname"><em>plane</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>delta</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Iterator&#160;</td>
          <td class="paramname"><em>begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Iterator&#160;</td>
          <td class="paramname"><em>end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">P&#160;</td>
          <td class="paramname"><em>p</em> = <code>P{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function returns, if it exists, an iterator to the highest Hyperplane that delta-dominates the input one. </p>
<p>Delta-domination refers to a concept introduced in the SARSOP paper. It means that a Hyperplane dominates another in a neighborhood of a given Point p. This is in contrast to either simply being higher at that point, or dominating the other plane across the whole simplex space.</p>
<p>The returned entry of this function depends on the ordering of the range, as more than one Hyperplane may delta-dominate the input, but they may not delta-dominate each other.</p>
<p>Thus, we iterate the input range once, and we check iteratively if an entry delta-dominates the currently found best Hyperplane.</p>
<p>Note that an entry is not guaranteed to exist; in that case we return the end of the input range.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">point</td><td>The Point where to check for delta-domination. </td></tr>
    <tr><td class="paramname">plane</td><td>The Hyperplane that needs to be delta-dominated. </td></tr>
    <tr><td class="paramname">delta</td><td>The delta value to use to validate delta-domination, i.e. the size of the neighborhood to check. </td></tr>
    <tr><td class="paramname">begin</td><td>The start of the range to check. </td></tr>
    <tr><td class="paramname">end</td><td>The end of the range to check. </td></tr>
    <tr><td class="paramname">p</td><td>A projection function to call on the iterators (defaults to identity).</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An iterator to the highest dominating entry, or if none is found, the end of the range. </dd></dl>

</div>
</div>
<a id="a92a200c6c709aad831698f2bf145d7c1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a92a200c6c709aad831698f2bf145d7c1">&#9670;&nbsp;</a></span>findVerticesNaive() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Range , typename P  = identity&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceAIToolbox.html#a5baa50917e25aabd8cb3e292ce37d040">PointSurface</a> AIToolbox::findVerticesNaive </td>
          <td>(</td>
          <td class="paramtype">const Range &amp;&#160;</td>
          <td class="paramname"><em>range</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">P&#160;</td>
          <td class="paramname"><em>p</em> = <code>P{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function returns all vertices for a given range of planes. </p>
<p>This function is used as a convenience to avoid duplicate plane problems. It will still possibly return duplicate vertices though.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">range</td><td>The range of planes to examine. </td></tr>
    <tr><td class="paramname">p</td><td>A projection function to call on the iterators of the range (defaults to identity).</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A non-unique list of all the vertices found. </dd></dl>

</div>
</div>
<a id="af8ab0db4b1347fdd3a0b383a185b9f98"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af8ab0db4b1347fdd3a0b383a185b9f98">&#9670;&nbsp;</a></span>findVerticesNaive() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename NewIt , typename OldIt , typename P1  = identity, typename P2  = identity&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceAIToolbox.html#a5baa50917e25aabd8cb3e292ce37d040">PointSurface</a> AIToolbox::findVerticesNaive </td>
          <td>(</td>
          <td class="paramtype">NewIt&#160;</td>
          <td class="paramname"><em>beginNew</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">NewIt&#160;</td>
          <td class="paramname"><em>endNew</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OldIt&#160;</td>
          <td class="paramname"><em>alphasBegin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OldIt&#160;</td>
          <td class="paramname"><em>alphasEnd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">P1&#160;</td>
          <td class="paramname"><em>p1</em> = <code>P1{}</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">P2&#160;</td>
          <td class="paramname"><em>p2</em> = <code>P2{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function implements a naive vertex enumeration algorithm. </p>
<p>This function goes through every subset of planes of size S, and finds all vertices it can. In particular, it goes through the first list one element at a time, and joins it with S-1 elements from the second list.</p>
<p>Even more precisely, we take &gt;= 1 elements from the second list. The remaining elements (so that in total we still use S-1) are simply the simplex boundaries, which allows us to find the corners located there.</p>
<p>This method may find duplicate vertices (it does not bother to prune them), as a vertex can be in the convergence of more than S planes.</p>
<p>The advantage is that we do not need any linear programming, and simple matrix decomposition techniques suffice.</p>
<p>We do NOT return simplex corners.</p>
<p>Warning: this function will return wrong vertices if the first set contains the same vectors in the second set!</p>
<p>Warning: the values of each vertex depends on the planes it has been found of, and thus may <em>not</em> be the true value if considering all planes at the same time! In other words, the same vertex may be found multiple times with different values!</p>
<p>This function works on ranges of Vectors.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">beginNew</td><td>The beginning of the range of the planes to find vertices for. </td></tr>
    <tr><td class="paramname">endNew</td><td>The end of the range of the planes to find vertices for. </td></tr>
    <tr><td class="paramname">alphasBegin</td><td>The beginning of the range of all other planes. </td></tr>
    <tr><td class="paramname">alphasEnd</td><td>The end of the range of all other planes. </td></tr>
    <tr><td class="paramname">p1</td><td>A projection function to call on the iterators of the first range (defaults to identity). </td></tr>
    <tr><td class="paramname">p2</td><td>A projection function to call on the iterators of the second range (defaults to identity).</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A non-unique list of all the vertices found. </dd></dl>

</div>
</div>
<a id="a0560565550b4432765a4b9126aa770e6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0560565550b4432765a4b9126aa770e6">&#9670;&nbsp;</a></span>getEntropy()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double AIToolbox::getEntropy </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceAIToolbox.html#af4149b71e91dee03ad9d0c8c207eddf0">ProbabilityVector</a> &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This function returns the entropy of the input ProbabilityVector. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">v</td><td>The input ProbabilityVector.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The entropy of the input. </dd></dl>

</div>
</div>
<a id="a4b76378b9a911994f2f3c237e94997bc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4b76378b9a911994f2f3c237e94997bc">&#9670;&nbsp;</a></span>getEntropyBase2()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double AIToolbox::getEntropyBase2 </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceAIToolbox.html#af4149b71e91dee03ad9d0c8c207eddf0">ProbabilityVector</a> &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This function returns the entropy of the input ProbabilityVector computed using log2. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">v</td><td>The input ProbabilityVector.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The entropy of the input in base 2. </dd></dl>

</div>
</div>
<a id="afc040c10bbec513dac4ee154328d799f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afc040c10bbec513dac4ee154328d799f">&#9670;&nbsp;</a></span>IndexMap()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Container &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classAIToolbox_1_1IndexMap.html">AIToolbox::IndexMap</a> </td>
          <td>(</td>
          <td class="paramtype">std::initializer_list&lt; T &gt;&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Container&#160;</td>
          <td class="paramname"><em>c</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt;  <a class="el" href="classAIToolbox_1_1IndexMap.html">IndexMap</a>&lt; std::vector&lt; T &gt;, Container &gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a0ad1be4bb3c810a6b25373d91a28038e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0ad1be4bb3c810a6b25373d91a28038e">&#9670;&nbsp;</a></span>IndexSkipMap()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Container &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classAIToolbox_1_1IndexSkipMap.html">AIToolbox::IndexSkipMap</a> </td>
          <td>(</td>
          <td class="paramtype">std::initializer_list&lt; T &gt;&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Container&#160;</td>
          <td class="paramname"><em>c</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt;  <a class="el" href="classAIToolbox_1_1IndexSkipMap.html">IndexSkipMap</a>&lt; std::vector&lt; T &gt;, Container &gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a5d4052078699d21068b648273ec9dcf6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5d4052078699d21068b648273ec9dcf6">&#9670;&nbsp;</a></span>isProbability()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool AIToolbox::isProbability </td>
          <td>(</td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>d</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>in</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function checks whether the supplied vector is a correct probability vector. </p>
<p>This function verifies basic probability conditions on the supplied container. The sum of all elements must be 1, and all elements must be &gt;= 0 and &lt;= 1.</p>
<p>The container needs to support data access through operator[]. In addition, the dimension of the container must match the one provided as argument.</p>
<p>This is important, as this function DOES NOT perform any size checks on the external container.</p>
<p>Internal values of the container will be converted to double, so the conversion T to double must be possible.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The external transition container type. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">in</td><td>The external transitions container. </td></tr>
    <tr><td class="paramname">d</td><td>The size of the supplied container.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the container satisfies probability constraints, and false otherwise. </dd></dl>

</div>
</div>
<a id="ab6541804d91ba3c11903fd8d29f34bcc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab6541804d91ba3c11903fd8d29f34bcc">&#9670;&nbsp;</a></span>LPInterpolation()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::tuple&lt;double, <a class="el" href="namespaceAIToolbox.html#a1e6976de7a0159cd1630c4f2553fc9f3">Vector</a>&gt; AIToolbox::LPInterpolation </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceAIToolbox.html#a917e72df43c1ed5e15caa4e8d8b80552">Point</a> &amp;&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceAIToolbox.html#a196a2986a1edf009b2c2f057aae24b71">CompactHyperplanes</a> &amp;&#160;</td>
          <td class="paramname"><em>ubQ</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceAIToolbox.html#a5baa50917e25aabd8cb3e292ce37d040">PointSurface</a> &amp;&#160;</td>
          <td class="paramname"><em>ubV</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function computes the exact value of the input Point w.r.t. the given surfaces. </p>
<p>The input CompactHyperplanes are used as an easy upper bound.</p>
<p>Then, a linear programming is created that uses the input PointSurface. What happens is that the linear program uses each Point (and its value) to construct a piecewise linear surface, where the value of the input belief is determined.</p>
<p>The higher of the two surfaces is then returned as the value of the input Point.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>The point to compute the value of. </td></tr>
    <tr><td class="paramname">ubQ</td><td>A set of Hyperplanes to use as a baseline surface. </td></tr>
    <tr><td class="paramname">ubV</td><td>A set of Points (not on the corners of the simplex) to use as main interpolation.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The value of the Point, and a vector containing the proportion in which each Point in the PointSurface contributes to the upper bound. </dd></dl>

</div>
</div>
<a id="a476a8ac48b42df366183a01594f78dac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a476a8ac48b42df366183a01594f78dac">&#9670;&nbsp;</a></span>makeRandomProbability()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename G &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceAIToolbox.html#af4149b71e91dee03ad9d0c8c207eddf0">ProbabilityVector</a> AIToolbox::makeRandomProbability </td>
          <td>(</td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>S</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">G &amp;&#160;</td>
          <td class="paramname"><em>generator</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function generates a random probability vector. </p>
<p>This function will sample uniformly from the simplex space with the specified number of dimensions.</p>
<p>S must be at least one or we don't guarantee any behaviour.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">S</td><td>The number of entries of the output vector. </td></tr>
    <tr><td class="paramname">generator</td><td>A random number generator.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A new random probability vector. </dd></dl>

</div>
</div>
<a id="a2ae0c23572526182d5fd984223c580c4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2ae0c23572526182d5fd984223c580c4">&#9670;&nbsp;</a></span>max_element_unary()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename It , typename F &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto AIToolbox::max_element_unary </td>
          <td>(</td>
          <td class="paramtype">It&#160;</td>
          <td class="paramname"><em>begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const It&#160;</td>
          <td class="paramname"><em>end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">F&#160;</td>
          <td class="paramname"><em>unary_converter</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function is equivalent to std::max_element, but takes a unary function. </p>
<p>This function can be called when doing a comparison between elements is expensive, as they must be converted to some particular value every single time.</p>
<p>Instead, here we take a unary function which we apply once to every element in the range, and we pick the one with the value that compares the max.</p>
<p>If there are duplicates, the first max is returned.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">begin</td><td>The begin of the range to compare. </td></tr>
    <tr><td class="paramname">end</td><td>The end of the range to compare. </td></tr>
    <tr><td class="paramname">unary_converter</td><td>The unary function to apply to each item in the range.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The iterator pointing to the max element in the range. </dd></dl>

</div>
</div>
<a id="ade5a791c00b531a438fd130591ee0809"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ade5a791c00b531a438fd130591ee0809">&#9670;&nbsp;</a></span>nChooseK()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned AIToolbox::nChooseK </td>
          <td>(</td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>k</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns (n k); i.e. n choose k. </p>

</div>
</div>
<a id="aaecaab4f7eee1001fa0c46fb93c98201"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaecaab4f7eee1001fa0c46fb93c98201">&#9670;&nbsp;</a></span>nonZeroBallsBins()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned AIToolbox::nonZeroBallsBins </td>
          <td>(</td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>balls</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>bins</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the number of balls/bins combinations. </p>
<p>This function returns the number of combinations in which you can split a set of indistinguishable balls into a set of distinguishable bins, where no bin can be empty.</p>
<p>This is equivalent to nonZeroStarsBars(balls, bins - 1).</p>
<p>Note: bins shall NOT be equal to 0. </p>

</div>
</div>
<a id="a089de7e55bbd13310ce6f3d5296932af"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a089de7e55bbd13310ce6f3d5296932af">&#9670;&nbsp;</a></span>nonZeroStarsBars()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned AIToolbox::nonZeroStarsBars </td>
          <td>(</td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>stars</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>bars</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the number of stars/bars combinations. </p>
<p>This function returns the number of combinations for dividing a set of stars with <code>bars</code> number of elements, where no two bars can be adjacent. </p>

</div>
</div>
<a id="a6ca50b6d2585387be42d0ae76205f34a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6ca50b6d2585387be42d0ae76205f34a">&#9670;&nbsp;</a></span>operator&lt;&lt;()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; AIToolbox::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classAIToolbox_1_1Statistics.html">Statistics</a> &amp;&#160;</td>
          <td class="paramname"><em>rh</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function writes the output of the <a class="el" href="classAIToolbox_1_1Statistics.html" title="This class registers sets of data and computes statistics about it.">Statistics</a> to the stream. </p>
<p>The output will contain a series of lines, each formed by: timestep, mean, cumulative mean, standard deviation and cumulative standard deviation.</p>
<p>The output is GnuPlot friendly!</p>
<p>Note that each reprint will recompute the statistics from scratch, as they are not cached.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">os</td><td>The stream to write to. </td></tr>
    <tr><td class="paramname">rh</td><td>The <a class="el" href="classAIToolbox_1_1Statistics.html" title="This class registers sets of data and computes statistics about it.">Statistics</a> to get data from.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The input stream. </dd></dl>

</div>
</div>
<a id="aa33180c05494468c0f7afa2262384ce7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa33180c05494468c0f7afa2262384ce7">&#9670;&nbsp;</a></span>probabilityDistribution()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static std::uniform_real_distribution&lt;double&gt; AIToolbox::probabilityDistribution </td>
          <td>(</td>
          <td class="paramtype">0.&#160;</td>
          <td class="paramname"><em>0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">1.&#160;</td>
          <td class="paramname"><em>0</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ad1d02a7b4abada909d8d0b620496d381"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad1d02a7b4abada909d8d0b620496d381">&#9670;&nbsp;</a></span>projectToProbability()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceAIToolbox.html#af4149b71e91dee03ad9d0c8c207eddf0">ProbabilityVector</a> AIToolbox::projectToProbability </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceAIToolbox.html#a1e6976de7a0159cd1630c4f2553fc9f3">Vector</a> &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function projects the input vector to a valid probability space. </p>
<p>This function finds the closest valid ProbabilityVector to the input vector. The distance measure used here is the sum of the absolute values of the element-wise difference between the input and the output.</p>
<p>When it has a choice, it tries to preserve the "shape" of the input and not arbitrarily change elements around.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">v</td><td>The vector to project to a valid probability space.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The closes valid probability vector to the input. </dd></dl>

</div>
</div>
<a id="a2a0814792b2a6cf30eaa196d4571bd9b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2a0814792b2a6cf30eaa196d4571bd9b">&#9670;&nbsp;</a></span>sampleBetaDistribution()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename G &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">double AIToolbox::sampleBetaDistribution </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">G &amp;&#160;</td>
          <td class="paramname"><em>generator</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function samples from a Beta distribution. </p>
<p>The Beta distribution can be useful as it is the conjugate prior of the Bernoulli and Binomial distributions (and others).</p>
<p>As C++ does not yet have a Beta distribution in the standard, we emulate the sampling using two gamma distributions.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">G</td><td>The type of the generator used. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>The 'a' shape parameter of the Beta distribution to sample. </td></tr>
    <tr><td class="paramname">b</td><td>The 'b' shape parameter of the Beta distribution to sample. </td></tr>
    <tr><td class="paramname">generator</td><td>A random number generator.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The sampled number. </dd></dl>

</div>
</div>
<a id="a74fd0fb7396717f9f2751bf2f3121dc0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a74fd0fb7396717f9f2751bf2f3121dc0">&#9670;&nbsp;</a></span>sampleDirichletDistribution() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TIn , typename G &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceAIToolbox.html#af4149b71e91dee03ad9d0c8c207eddf0">ProbabilityVector</a> AIToolbox::sampleDirichletDistribution </td>
          <td>(</td>
          <td class="paramtype">const TIn &amp;&#160;</td>
          <td class="paramname"><em>params</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">G &amp;&#160;</td>
          <td class="paramname"><em>generator</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function samples from the input Dirichlet distribution. </p>
<p>The input parameters's type must support size() and square bracket access.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">params</td><td>The parameters of the Dirichlet distribution. </td></tr>
    <tr><td class="paramname">generator</td><td>The random generator to sample from.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A ProbabilityVector containing the sampled Dirichlet. </dd></dl>

</div>
</div>
<a id="a9fe13af882ae35ca664adbb08663e2ad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9fe13af882ae35ca664adbb08663e2ad">&#9670;&nbsp;</a></span>sampleDirichletDistribution() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TIn , typename TOut , typename G &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void AIToolbox::sampleDirichletDistribution </td>
          <td>(</td>
          <td class="paramtype">const TIn &amp;&#160;</td>
          <td class="paramname"><em>params</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">G &amp;&#160;</td>
          <td class="paramname"><em>generator</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TOut &amp;&amp;&#160;</td>
          <td class="paramname"><em>out</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function samples from the input Dirichlet distribution inline. </p>
<p>The input parameters's type must support size() and square bracket access. The output parameter's type must be a dense <a class="el" href="namespaceEigen.html">Eigen</a> type (Vector, row, etc).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">params</td><td>The parameters of the Dirichlet distribution. </td></tr>
    <tr><td class="paramname">generator</td><td>The random generator to sample from. </td></tr>
    <tr><td class="paramname">out</td><td>The output container. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a31fb7fd3eb6b455f39a1bd388a5fd264"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a31fb7fd3eb6b455f39a1bd388a5fd264">&#9670;&nbsp;</a></span>sampleProbability() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename G &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">size_t AIToolbox::sampleProbability </td>
          <td>(</td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>d</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const SparseMatrix2D::ConstRowXpr &amp;&#160;</td>
          <td class="paramname"><em>in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">G &amp;&#160;</td>
          <td class="paramname"><em>generator</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function samples an index from a sparse probability vector. </p>
<p>This function randomly samples an index between 0 and d, given a vector containing the probabilities of sampling each of the indexes.</p>
<p>For performance reasons this function does not verify that the input container is effectively a probability.</p>
<p>The generator has to be supplied to the function, so that different objects are able to maintain different generators, to reduce correlations between different samples. The generator has to be compatible with std::uniform_real_distribution&lt;double&gt;, since that is what is used to obtain the random sample.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">G</td><td>The type of the generator used. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">in</td><td>The external probability container. </td></tr>
    <tr><td class="paramname">d</td><td>The size of the supplied container. </td></tr>
    <tr><td class="paramname">generator</td><td>The generator used to sample.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An index in range [0,d-1]. </dd></dl>

</div>
</div>
<a id="ad73352f6ce65aa95f76b7399cf0d2cb0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad73352f6ce65aa95f76b7399cf0d2cb0">&#9670;&nbsp;</a></span>sampleProbability() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename G &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">size_t AIToolbox::sampleProbability </td>
          <td>(</td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>d</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">G &amp;&#160;</td>
          <td class="paramname"><em>generator</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function samples an index from a probability vector. </p>
<p>This function randomly samples an index between 0 and d, given a vector containing the probabilities of sampling each of the indexes.</p>
<p>For performance reasons this function does not verify that the input container is effectively a probability.</p>
<p>The generator has to be supplied to the function, so that different objects are able to maintain different generators, to reduce correlations between different samples. The generator has to be compatible with std::uniform_real_distribution&lt;double&gt;, since that is what is used to obtain the random sample.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The type of the container vector to sample. </td></tr>
    <tr><td class="paramname">G</td><td>The type of the generator used. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">in</td><td>The external probability container. </td></tr>
    <tr><td class="paramname">d</td><td>The size of the supplied container. </td></tr>
    <tr><td class="paramname">generator</td><td>The generator used to sample.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An index in range [0,d-1]. </dd></dl>

</div>
</div>
<a id="a3aec9476bc80e36874b755a4cf111dce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3aec9476bc80e36874b755a4cf111dce">&#9670;&nbsp;</a></span>sawtoothInterpolation()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::tuple&lt;double, <a class="el" href="namespaceAIToolbox.html#a1e6976de7a0159cd1630c4f2553fc9f3">Vector</a>&gt; AIToolbox::sawtoothInterpolation </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceAIToolbox.html#a917e72df43c1ed5e15caa4e8d8b80552">Point</a> &amp;&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceAIToolbox.html#a196a2986a1edf009b2c2f057aae24b71">CompactHyperplanes</a> &amp;&#160;</td>
          <td class="paramname"><em>ubQ</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceAIToolbox.html#a5baa50917e25aabd8cb3e292ce37d040">PointSurface</a> &amp;&#160;</td>
          <td class="paramname"><em>ubV</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function computes an approximate, but quick, upper bound on the surface value at the input point. </p>
<p>The input CompactHyperplanes are used as an easy upper bound.</p>
<p>We then start to consider every surface composed by one Point in the input PointSurface, and N-1 corners of the simplex (the highest corners of the surface, as identified by the CompactHyperplanes). Since each Point defines N such surfaces (one for each corner we "skip"), the enumeration can be done fairly quickly.</p>
<p>The overall surface has a sawtooth shape, from which the name of this method. The approximation is not perfect, but some methods must use it as using the LPInterpolation method would be too computationally expensive.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>The point to compute the value of. </td></tr>
    <tr><td class="paramname">ubQ</td><td>A set of Hyperplanes to use as a baseline surface. </td></tr>
    <tr><td class="paramname">ubV</td><td>A set of Points (not on the corners of the simplex) to use as main interpolation.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The value of the Point, and a vector containing the proportion in which each Point in the PointSurface contributes to the upper bound. </dd></dl>

</div>
</div>
<a id="acb9131cfadf0600e435b545dbf0b5fc9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acb9131cfadf0600e435b545dbf0b5fc9">&#9670;&nbsp;</a></span>sequential_sorted_contains() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename V &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool AIToolbox::sequential_sorted_contains </td>
          <td>(</td>
          <td class="paramtype">const V &amp;&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const V &amp;&#160;</td>
          <td class="paramname"><em>elems</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function returns whether a sorted range contains another sorted range, via sequential scan. </p>
<p>Note: This function assumes that the contained vector is smaller or equal in size of the vector to be searched.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">V</td><td>The type of the vector to be scanned. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">v</td><td>The vector to be scanned. </td></tr>
    <tr><td class="paramname">elems</td><td>The vector that must be contained.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the vector contains all elements from the input, false otherwise. </dd></dl>

</div>
</div>
<a id="ae70933a8434d22f0d888527a5d72e5ad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae70933a8434d22f0d888527a5d72e5ad">&#9670;&nbsp;</a></span>sequential_sorted_contains() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename It &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool AIToolbox::sequential_sorted_contains </td>
          <td>(</td>
          <td class="paramtype">It&#160;</td>
          <td class="paramname"><em>begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">It&#160;</td>
          <td class="paramname"><em>end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename std::iterator_traits&lt; It &gt;::value_type &amp;&#160;</td>
          <td class="paramname"><em>elem</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function returns whether a sorted range contains a given element, via sequential scan. </p>
<p>The idea behind this function is that for small sorted vectors it is faster to do a sequential scan rather than employing the heavy handed technique of binary search.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">begin</td><td>The beginning of the sorted range to scan. </td></tr>
    <tr><td class="paramname">end</td><td>The end of the sorted range to scan. </td></tr>
    <tr><td class="paramname">elem</td><td>The element to be looked for in the range.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the input is in the range, false otherwise. </dd></dl>

</div>
</div>
<a id="add1a336767c8dd3b7999237a1149818a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#add1a336767c8dd3b7999237a1149818a">&#9670;&nbsp;</a></span>sequential_sorted_find()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename It &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">It AIToolbox::sequential_sorted_find </td>
          <td>(</td>
          <td class="paramtype">It&#160;</td>
          <td class="paramname"><em>begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">It&#160;</td>
          <td class="paramname"><em>end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename std::iterator_traits&lt; It &gt;::value_type &amp;&#160;</td>
          <td class="paramname"><em>elem</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function returns an iterator to the position where the input should be in a sorted range, via sequential scan. </p>
<p>The idea behind this function is that for small sorted vectors it is faster to do a sequential scan rather than employing the heavy handed technique of binary search.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">begin</td><td>The beginning of the sorted range to scan. </td></tr>
    <tr><td class="paramname">end</td><td>The end of the sorted range to scan. </td></tr>
    <tr><td class="paramname">elem</td><td>The element to be looked for in the range.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An iterator to the position the input element should be in the sorted range. </dd></dl>

</div>
</div>
<a id="a68e4594e4010a8d2e5d731f94a33c2fb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a68e4594e4010a8d2e5d731f94a33c2fb">&#9670;&nbsp;</a></span>set_union_inplace()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void AIToolbox::set_union_inplace </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function performs an inplace union of two sorted sets. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>The left hand side, to be increased. </td></tr>
    <tr><td class="paramname">rhs</td><td>The right hand side. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="acc2c6fcda7af327c205dae20fc162d35"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acc2c6fcda7af327c205dae20fc162d35">&#9670;&nbsp;</a></span>starsBars()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned AIToolbox::starsBars </td>
          <td>(</td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>stars</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>bars</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the number of stars/bars combinations. </p>
<p>This function returns the number of combinations for dividing a set of stars with <code>bars</code> number of elements. </p>

</div>
</div>
<a id="a111282b4c465f34023497869fdeecd58"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a111282b4c465f34023497869fdeecd58">&#9670;&nbsp;</a></span>veccmp()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename V &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">int AIToolbox::veccmp </td>
          <td>(</td>
          <td class="paramtype">const V &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const V &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function compares two general vectors of equal size lexicographically. </p>
<p>Note that veccmp reports equality only if the elements are all exactly the same. You should not use this function to compare floating point numbers unless you know what you are doing.</p>
<p>Note: This function assumes that the inputs are equally sized.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>The left hand size of the comparison. </td></tr>
    <tr><td class="paramname">rhs</td><td>The right hand size of the comparison.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>1 if the lhs is greater than the rhs, 0 if they are equal, -1 otherwise. </dd></dl>

</div>
</div>
<a id="a2ad90c42f9cf72812707724c6a669161"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2ad90c42f9cf72812707724c6a669161">&#9670;&nbsp;</a></span>veccmpGeneral()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename V &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">int AIToolbox::veccmpGeneral </td>
          <td>(</td>
          <td class="paramtype">const V &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const V &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function compares two general vectors of equal size lexicographically. </p>
<p>This function considers two elements equal using the checkEqualGeneral function.</p>
<p>Note: This function assumes that the inputs are equally sized.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>The left hand size of the comparison. </td></tr>
    <tr><td class="paramname">rhs</td><td>The right hand size of the comparison.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>1 if the lhs is greater than the rhs, 0 if they are equal, -1 otherwise. </dd></dl>

</div>
</div>
<a id="ad0927a8f10c7aa36aa7d341fab1834fc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad0927a8f10c7aa36aa7d341fab1834fc">&#9670;&nbsp;</a></span>veccmpSmall()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename V &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">int AIToolbox::veccmpSmall </td>
          <td>(</td>
          <td class="paramtype">const V &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const V &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function compares two general vectors of equal size lexicographically. </p>
<p>Note that veccmpSmall considers two elements equal using the checkEqualSmall function.</p>
<p>Note: This function assumes that the inputs are equally sized.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>The left hand size of the comparison. </td></tr>
    <tr><td class="paramname">rhs</td><td>The right hand size of the comparison.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>1 if the lhs is greater than the rhs, 0 if they are equal, -1 otherwise. </dd></dl>

</div>
</div>
<h2 class="groupheader">Variable Documentation</h2>
<a id="a7ac7114c76d8082333e9222fd1aac187"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7ac7114c76d8082333e9222fd1aac187">&#9670;&nbsp;</a></span>AILogger</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceAIToolbox.html#af6eb1f8c89dcca62cbe9912b6ec77d33">AILoggerFun</a>* AIToolbox::AILogger = nullptr</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This pointer defines the function used to log. </p>
<dl class="section see"><dt>See also</dt><dd>Logging </dd></dl>

</div>
</div>
<a id="ad6fe7471894e7e26ec5a51003997d258"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad6fe7471894e7e26ec5a51003997d258">&#9670;&nbsp;</a></span>equalToleranceGeneral</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto AIToolbox::equalToleranceGeneral = 0.00000000001</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This is a relative term used in the checkEqualGeneral functions, where two values may be considered equal if they are within this percentage of each other. </p>

</div>
</div>
<a id="a395f82018bc6d027736805fec404d482"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a395f82018bc6d027736805fec404d482">&#9670;&nbsp;</a></span>equalToleranceSmall</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto AIToolbox::equalToleranceSmall = 0.000001</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This is the max absolute difference for which two values can be considered equal. </p>

</div>
</div>
<a id="ab17c75e0097c109e4737f2c1215c2dd6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab17c75e0097c109e4737f2c1215c2dd6">&#9670;&nbsp;</a></span>NO_CHECK</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct <a class="el" href="structAIToolbox_1_1NoCheck.html">AIToolbox::NoCheck</a> AIToolbox::NO_CHECK</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- HTML footer for doxygen 1.8.17-->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
</div>
</body>
</html>
