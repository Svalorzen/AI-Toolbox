<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.17"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>AIToolbox: AIToolbox::POMDP Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">AIToolbox
   </div>
   <div id="projectbrief">A library that offers tools for AI problem solving.</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.17 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('namespaceAIToolbox_1_1POMDP.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#namespaces">Namespaces</a> &#124;
<a href="#nested-classes">Classes</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle">
<div class="title">AIToolbox::POMDP Namespace Reference</div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="namespaces"></a>
Namespaces</h2></td></tr>
<tr class="memitem:namespaceAIToolbox_1_1POMDP_1_1TigerProblemUtils"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceAIToolbox_1_1POMDP_1_1TigerProblemUtils.html">TigerProblemUtils</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structAIToolbox_1_1POMDP_1_1ActionNode.html">ActionNode</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAIToolbox_1_1POMDP_1_1AMDP.html">AMDP</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class implements the Augmented <a class="el" href="namespaceAIToolbox_1_1MDP.html">MDP</a> algorithm.  <a href="classAIToolbox_1_1POMDP_1_1AMDP.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAIToolbox_1_1POMDP_1_1BeliefGenerator.html">BeliefGenerator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class generates reachable beliefs from a given <a class="el" href="classAIToolbox_1_1POMDP_1_1Model.html" title="This class represents a Partially Observable Markov Decision Process.">Model</a>.  <a href="classAIToolbox_1_1POMDP_1_1BeliefGenerator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAIToolbox_1_1POMDP_1_1BeliefNode.html">BeliefNode</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is a belief node of the <a class="el" href="classAIToolbox_1_1POMDP_1_1rPOMCP.html" title="This class represents the rPOMCP online planner.">rPOMCP</a> tree.  <a href="classAIToolbox_1_1POMDP_1_1BeliefNode.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structAIToolbox_1_1POMDP_1_1BeliefParticle.html">BeliefParticle</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAIToolbox_1_1POMDP_1_1BlindStrategies.html">BlindStrategies</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class implements the blind strategies lower bound.  <a href="classAIToolbox_1_1POMDP_1_1BlindStrategies.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAIToolbox_1_1POMDP_1_1FastInformedBound.html">FastInformedBound</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class implements the Fast Informed Bound algorithm.  <a href="classAIToolbox_1_1POMDP_1_1FastInformedBound.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAIToolbox_1_1POMDP_1_1GapMin.html">GapMin</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class implements the <a class="el" href="classAIToolbox_1_1POMDP_1_1GapMin.html" title="This class implements the GapMin algorithm.">GapMin</a> algorithm.  <a href="classAIToolbox_1_1POMDP_1_1GapMin.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAIToolbox_1_1POMDP_1_1HeadBeliefNode.html">HeadBeliefNode</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class is the root node of the <a class="el" href="classAIToolbox_1_1POMDP_1_1rPOMCP.html" title="This class represents the rPOMCP online planner.">rPOMCP</a> graph.  <a href="classAIToolbox_1_1POMDP_1_1HeadBeliefNode.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAIToolbox_1_1POMDP_1_1IncrementalPruning.html">IncrementalPruning</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class implements the Incremental Pruning algorithm.  <a href="classAIToolbox_1_1POMDP_1_1IncrementalPruning.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structAIToolbox_1_1POMDP_1_1is__generative__model.html">is_generative_model</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This struct represents the required interface for a generative <a class="el" href="namespaceAIToolbox_1_1MDP.html">MDP</a>.  <a href="structAIToolbox_1_1POMDP_1_1is__generative__model.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structAIToolbox_1_1POMDP_1_1is__model.html">is_model</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This struct represents the required interface for a <a class="el" href="namespaceAIToolbox_1_1POMDP.html">POMDP</a> <a class="el" href="classAIToolbox_1_1POMDP_1_1Model.html" title="This class represents a Partially Observable Markov Decision Process.">Model</a>.  <a href="structAIToolbox_1_1POMDP_1_1is__model.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structAIToolbox_1_1POMDP_1_1is__model__eigen.html">is_model_eigen</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This struct represents the required interface that allows <a class="el" href="namespaceAIToolbox_1_1POMDP.html">POMDP</a> algorithms to leverage <a class="el" href="namespaceEigen.html">Eigen</a>.  <a href="structAIToolbox_1_1POMDP_1_1is__model__eigen.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structAIToolbox_1_1POMDP_1_1is__model__not__eigen.html">is_model_not_eigen</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This struct verifies that a class satisfies the <a class="el" href="structAIToolbox_1_1POMDP_1_1is__model.html" title="This struct represents the required interface for a POMDP Model.">is_model</a> interface but not the <a class="el" href="structAIToolbox_1_1POMDP_1_1is__model__eigen.html" title="This struct represents the required interface that allows POMDP algorithms to leverage Eigen.">is_model_eigen</a> interface.  <a href="structAIToolbox_1_1POMDP_1_1is__model__not__eigen.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structAIToolbox_1_1POMDP_1_1is__witness__lp.html">is_witness_lp</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This check the interface for a <a class="el" href="classAIToolbox_1_1WitnessLP.html" title="This class implements an easy interface to do Witness discovery through linear programming.">WitnessLP</a>.  <a href="structAIToolbox_1_1POMDP_1_1is__witness__lp.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAIToolbox_1_1POMDP_1_1LinearSupport.html">LinearSupport</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class represents the <a class="el" href="classAIToolbox_1_1POMDP_1_1LinearSupport.html" title="This class represents the LinearSupport algorithm.">LinearSupport</a> algorithm.  <a href="classAIToolbox_1_1POMDP_1_1LinearSupport.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAIToolbox_1_1POMDP_1_1Model.html">Model</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class represents a Partially Observable Markov Decision Process.  <a href="classAIToolbox_1_1POMDP_1_1Model.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAIToolbox_1_1POMDP_1_1PBVI.html">PBVI</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class implements the Point Based Value Iteration algorithm.  <a href="classAIToolbox_1_1POMDP_1_1PBVI.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAIToolbox_1_1POMDP_1_1PERSEUS.html">PERSEUS</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class implements the <a class="el" href="classAIToolbox_1_1POMDP_1_1PERSEUS.html" title="This class implements the PERSEUS algorithm.">PERSEUS</a> algorithm.  <a href="classAIToolbox_1_1POMDP_1_1PERSEUS.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAIToolbox_1_1POMDP_1_1Policy.html">Policy</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class represents a <a class="el" href="namespaceAIToolbox_1_1POMDP.html">POMDP</a> <a class="el" href="classAIToolbox_1_1POMDP_1_1Policy.html" title="This class represents a POMDP Policy.">Policy</a>.  <a href="classAIToolbox_1_1POMDP_1_1Policy.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAIToolbox_1_1POMDP_1_1POMCP.html">POMCP</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class represents the <a class="el" href="classAIToolbox_1_1POMDP_1_1POMCP.html" title="This class represents the POMCP online planner using UCB1.">POMCP</a> online planner using UCB1.  <a href="classAIToolbox_1_1POMDP_1_1POMCP.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAIToolbox_1_1POMDP_1_1Projecter.html">Projecter</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class offers projecting facilities for Models.  <a href="classAIToolbox_1_1POMDP_1_1Projecter.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAIToolbox_1_1POMDP_1_1QMDP.html">QMDP</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class implements the <a class="el" href="classAIToolbox_1_1POMDP_1_1QMDP.html" title="This class implements the QMDP algorithm.">QMDP</a> algorithm.  <a href="classAIToolbox_1_1POMDP_1_1QMDP.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAIToolbox_1_1POMDP_1_1rPOMCP.html">rPOMCP</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class represents the <a class="el" href="classAIToolbox_1_1POMDP_1_1rPOMCP.html" title="This class represents the rPOMCP online planner.">rPOMCP</a> online planner.  <a href="classAIToolbox_1_1POMDP_1_1rPOMCP.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAIToolbox_1_1POMDP_1_1RTBSS.html">RTBSS</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class represents the <a class="el" href="classAIToolbox_1_1POMDP_1_1RTBSS.html" title="This class represents the RTBSS online planner.">RTBSS</a> online planner.  <a href="classAIToolbox_1_1POMDP_1_1RTBSS.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAIToolbox_1_1POMDP_1_1SARSOP.html">SARSOP</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class implements the <a class="el" href="classAIToolbox_1_1POMDP_1_1SARSOP.html" title="This class implements the SARSOP algorithm.">SARSOP</a> algorithm.  <a href="classAIToolbox_1_1POMDP_1_1SARSOP.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAIToolbox_1_1POMDP_1_1SparseModel.html">SparseModel</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class represents a Partially Observable Markov Decision Process.  <a href="classAIToolbox_1_1POMDP_1_1SparseModel.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structAIToolbox_1_1POMDP_1_1VEntry.html">VEntry</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAIToolbox_1_1POMDP_1_1Witness.html">Witness</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class implements the <a class="el" href="classAIToolbox_1_1POMDP_1_1Witness.html" title="This class implements the Witness algorithm.">Witness</a> algorithm.  <a href="classAIToolbox_1_1POMDP_1_1Witness.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:a97f123407d50846293c4e9b46d7fbd49"><td class="memTemplParams" colspan="2">template&lt;bool UseEntropy&gt; </td></tr>
<tr class="memitem:a97f123407d50846293c4e9b46d7fbd49"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceAIToolbox_1_1POMDP.html#a97f123407d50846293c4e9b46d7fbd49">ActionNodes</a> = std::vector&lt; <a class="el" href="structAIToolbox_1_1POMDP_1_1ActionNode.html">ActionNode</a>&lt; UseEntropy &gt; &gt;</td></tr>
<tr class="separator:a97f123407d50846293c4e9b46d7fbd49"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad867f06ad8946aa1b205a7f5f8fcb42e"><td class="memTemplParams" colspan="2">template&lt;bool UseEntropy&gt; </td></tr>
<tr class="memitem:ad867f06ad8946aa1b205a7f5f8fcb42e"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceAIToolbox_1_1POMDP.html#ad867f06ad8946aa1b205a7f5f8fcb42e">TrackBelief</a> = std::unordered_map&lt; size_t, <a class="el" href="structAIToolbox_1_1POMDP_1_1BeliefParticle.html">BeliefParticle</a>&lt; UseEntropy &gt;, std::hash&lt; size_t &gt;, std::equal_to&lt; size_t &gt; &gt;</td></tr>
<tr class="separator:ad867f06ad8946aa1b205a7f5f8fcb42e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afba9c8e6204b8f6b341362af3991da75"><td class="memTemplParams" colspan="2">template&lt;bool UseEntropy&gt; </td></tr>
<tr class="memitem:afba9c8e6204b8f6b341362af3991da75"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceAIToolbox_1_1POMDP.html#afba9c8e6204b8f6b341362af3991da75">BeliefNodes</a> = std::unordered_map&lt; size_t, <a class="el" href="classAIToolbox_1_1POMDP_1_1BeliefNode.html">BeliefNode</a>&lt; UseEntropy &gt; &gt;</td></tr>
<tr class="separator:afba9c8e6204b8f6b341362af3991da75"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a79664c416e1fbfe5d89acb9f94f35bee"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceAIToolbox_1_1POMDP.html#a79664c416e1fbfe5d89acb9f94f35bee">SampleBelief</a> = std::vector&lt; std::pair&lt; size_t, unsigned &gt; &gt;</td></tr>
<tr class="separator:a79664c416e1fbfe5d89acb9f94f35bee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4522c5e35483fb30b2c43c271781e8bc"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceAIToolbox_1_1POMDP.html#a4522c5e35483fb30b2c43c271781e8bc">Belief</a> = <a class="el" href="namespaceAIToolbox.html#af4149b71e91dee03ad9d0c8c207eddf0">ProbabilityVector</a></td></tr>
<tr class="memdesc:a4522c5e35483fb30b2c43c271781e8bc"><td class="mdescLeft">&#160;</td><td class="mdescRight">This represents a belief, which is a probability distribution over states.  <a href="namespaceAIToolbox_1_1POMDP.html#a4522c5e35483fb30b2c43c271781e8bc">More...</a><br /></td></tr>
<tr class="separator:a4522c5e35483fb30b2c43c271781e8bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:af6a629b143e07d3f001e7d1f193c35e1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classAIToolbox_1_1POMDP_1_1Model.html">Model</a>&lt; <a class="el" href="classAIToolbox_1_1MDP_1_1Model.html">MDP::Model</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceAIToolbox_1_1POMDP.html#af6a629b143e07d3f001e7d1f193c35e1">makeChengD35</a> ()</td></tr>
<tr class="memdesc:af6a629b143e07d3f001e7d1f193c35e1"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function returns a <a class="el" href="namespaceAIToolbox_1_1POMDP.html">POMDP</a> model of the chengD35 problem.  <a href="namespaceAIToolbox_1_1POMDP.html#af6a629b143e07d3f001e7d1f193c35e1">More...</a><br /></td></tr>
<tr class="separator:af6a629b143e07d3f001e7d1f193c35e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aec8902c4e5cc3a90884f269c13d03b0d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classAIToolbox_1_1POMDP_1_1Model.html">Model</a>&lt; <a class="el" href="classAIToolbox_1_1MDP_1_1Model.html">MDP::Model</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceAIToolbox_1_1POMDP.html#aec8902c4e5cc3a90884f269c13d03b0d">makeEJS4</a> ()</td></tr>
<tr class="memdesc:aec8902c4e5cc3a90884f269c13d03b0d"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function returns a <a class="el" href="namespaceAIToolbox_1_1POMDP.html">POMDP</a> model of the ejs4 problem.  <a href="namespaceAIToolbox_1_1POMDP.html#aec8902c4e5cc3a90884f269c13d03b0d">More...</a><br /></td></tr>
<tr class="separator:aec8902c4e5cc3a90884f269c13d03b0d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abcd38fafda125d7a1e44a0d04c56e0e0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classAIToolbox_1_1POMDP_1_1Model.html">AIToolbox::POMDP::Model</a>&lt; <a class="el" href="classAIToolbox_1_1MDP_1_1Model.html">AIToolbox::MDP::Model</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceAIToolbox_1_1POMDP.html#abcd38fafda125d7a1e44a0d04c56e0e0">makeTigerProblem</a> ()</td></tr>
<tr class="memdesc:abcd38fafda125d7a1e44a0d04c56e0e0"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function sets up the tiger problem in a <a class="el" href="classAIToolbox_1_1POMDP_1_1Model.html" title="This class represents a Partially Observable Markov Decision Process.">Model</a>.  <a href="namespaceAIToolbox_1_1POMDP.html#abcd38fafda125d7a1e44a0d04c56e0e0">More...</a><br /></td></tr>
<tr class="separator:abcd38fafda125d7a1e44a0d04c56e0e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a184e91a2441d41ffc7c249c587bf415c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classAIToolbox_1_1POMDP_1_1Model.html">Model</a>&lt; <a class="el" href="classAIToolbox_1_1MDP_1_1Model.html">MDP::Model</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceAIToolbox_1_1POMDP.html#a184e91a2441d41ffc7c249c587bf415c">parseCassandra</a> (std::istream &amp;input)</td></tr>
<tr class="memdesc:a184e91a2441d41ffc7c249c587bf415c"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function parses a <a class="el" href="namespaceAIToolbox_1_1POMDP.html">POMDP</a> from a Cassandra formatted stream.  <a href="namespaceAIToolbox_1_1POMDP.html#a184e91a2441d41ffc7c249c587bf415c">More...</a><br /></td></tr>
<tr class="separator:a184e91a2441d41ffc7c249c587bf415c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af460a8a2b997c9c93e620e9f805fcaf3"><td class="memTemplParams" colspan="2">template&lt;typename M , std::enable_if_t&lt; is_model_v&lt; M &gt;, int &gt;  = 0&gt; </td></tr>
<tr class="memitem:af460a8a2b997c9c93e620e9f805fcaf3"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceAIToolbox_1_1POMDP.html#af460a8a2b997c9c93e620e9f805fcaf3">operator&lt;&lt;</a> (std::ostream &amp;os, const M &amp;model)</td></tr>
<tr class="memdesc:af460a8a2b997c9c93e620e9f805fcaf3"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function prints any <a class="el" href="namespaceAIToolbox_1_1POMDP.html">POMDP</a> model to a file.  <a href="namespaceAIToolbox_1_1POMDP.html#af460a8a2b997c9c93e620e9f805fcaf3">More...</a><br /></td></tr>
<tr class="separator:af460a8a2b997c9c93e620e9f805fcaf3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3e6938312f6dd9d20f1f3767bb361a76"><td class="memTemplParams" colspan="2">template&lt;typename M , typename &gt; </td></tr>
<tr class="memitem:a3e6938312f6dd9d20f1f3767bb361a76"><td class="memTemplItemLeft" align="right" valign="top">std::istream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceAIToolbox_1_1POMDP.html#a3e6938312f6dd9d20f1f3767bb361a76">operator&gt;&gt;</a> (std::istream &amp;is, <a class="el" href="classAIToolbox_1_1POMDP_1_1Model.html">Model</a>&lt; M &gt; &amp;m)</td></tr>
<tr class="memdesc:a3e6938312f6dd9d20f1f3767bb361a76"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function implements input from stream for the <a class="el" href="classAIToolbox_1_1POMDP_1_1Model.html" title="This class represents a Partially Observable Markov Decision Process.">POMDP::Model</a> class.  <a href="namespaceAIToolbox_1_1POMDP.html#a3e6938312f6dd9d20f1f3767bb361a76">More...</a><br /></td></tr>
<tr class="separator:a3e6938312f6dd9d20f1f3767bb361a76"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a55c4ff8e7537e5d77f5edd0038705393"><td class="memTemplParams" colspan="2">template&lt;typename M , typename &gt; </td></tr>
<tr class="memitem:a55c4ff8e7537e5d77f5edd0038705393"><td class="memTemplItemLeft" align="right" valign="top">std::istream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceAIToolbox_1_1POMDP.html#a55c4ff8e7537e5d77f5edd0038705393">operator&gt;&gt;</a> (std::istream &amp;is, <a class="el" href="classAIToolbox_1_1POMDP_1_1SparseModel.html">SparseModel</a>&lt; M &gt; &amp;m)</td></tr>
<tr class="memdesc:a55c4ff8e7537e5d77f5edd0038705393"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function implements input from stream for the <a class="el" href="classAIToolbox_1_1POMDP_1_1SparseModel.html" title="This class represents a Partially Observable Markov Decision Process.">POMDP::SparseModel</a> class.  <a href="namespaceAIToolbox_1_1POMDP.html#a55c4ff8e7537e5d77f5edd0038705393">More...</a><br /></td></tr>
<tr class="separator:a55c4ff8e7537e5d77f5edd0038705393"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a17b5a1ad1cf5759d34c6a8470089f9e1"><td class="memItemLeft" align="right" valign="top">std::istream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceAIToolbox_1_1POMDP.html#a17b5a1ad1cf5759d34c6a8470089f9e1">operator&gt;&gt;</a> (std::istream &amp;is, <a class="el" href="classAIToolbox_1_1POMDP_1_1Policy.html">Policy</a> &amp;p)</td></tr>
<tr class="memdesc:a17b5a1ad1cf5759d34c6a8470089f9e1"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function reads a policy from a file.  <a href="namespaceAIToolbox_1_1POMDP.html#a17b5a1ad1cf5759d34c6a8470089f9e1">More...</a><br /></td></tr>
<tr class="separator:a17b5a1ad1cf5759d34c6a8470089f9e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a46eee8111107489e3d68d30055722ed8"><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceAIToolbox_1_1POMDP.html#a46eee8111107489e3d68d30055722ed8">operator&lt;&lt;</a> (std::ostream &amp;os, const <a class="el" href="classAIToolbox_1_1POMDP_1_1Policy.html">Policy</a> &amp;p)</td></tr>
<tr class="memdesc:a46eee8111107489e3d68d30055722ed8"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function prints the whole policy to a stream.  <a href="namespaceAIToolbox_1_1POMDP.html#a46eee8111107489e3d68d30055722ed8">More...</a><br /></td></tr>
<tr class="separator:a46eee8111107489e3d68d30055722ed8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3dd0669f710850fc93fe8f7b102fb1b6"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceAIToolbox_1_1POMDP.html#a3dd0669f710850fc93fe8f7b102fb1b6">operator&lt;</a> (const <a class="el" href="structAIToolbox_1_1POMDP_1_1VEntry.html">VEntry</a> &amp;lhs, const <a class="el" href="structAIToolbox_1_1POMDP_1_1VEntry.html">VEntry</a> &amp;rhs)</td></tr>
<tr class="memdesc:a3dd0669f710850fc93fe8f7b102fb1b6"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function lexicographically sorts VEntries.  <a href="namespaceAIToolbox_1_1POMDP.html#a3dd0669f710850fc93fe8f7b102fb1b6">More...</a><br /></td></tr>
<tr class="separator:a3dd0669f710850fc93fe8f7b102fb1b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a45f5d972365404bca4ddfbef575b1bd0"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceAIToolbox_1_1POMDP.html#a45f5d972365404bca4ddfbef575b1bd0">operator==</a> (const <a class="el" href="structAIToolbox_1_1POMDP_1_1VEntry.html">VEntry</a> &amp;lhs, const <a class="el" href="structAIToolbox_1_1POMDP_1_1VEntry.html">VEntry</a> &amp;rhs)</td></tr>
<tr class="separator:a45f5d972365404bca4ddfbef575b1bd0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5254fac18b477fde30cff6ccbb131a63"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceAIToolbox_1_1POMDP.html#a5254fac18b477fde30cff6ccbb131a63">hash_value</a> (const <a class="el" href="structAIToolbox_1_1POMDP_1_1VEntry.html">VEntry</a> &amp;v)</td></tr>
<tr class="memdesc:a5254fac18b477fde30cff6ccbb131a63"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function enables hashing of VEntries with boost::hash.  <a href="namespaceAIToolbox_1_1POMDP.html#a5254fac18b477fde30cff6ccbb131a63">More...</a><br /></td></tr>
<tr class="separator:a5254fac18b477fde30cff6ccbb131a63"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac8532961013ec06fe6d47960b71ae822"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="namespaceAIToolbox_1_1MDP.html#ae6bfccca3b00146c82eb345ca8490b74">MDP::Values</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceAIToolbox_1_1POMDP.html#ac8532961013ec06fe6d47960b71ae822">unwrap</a> (const <a class="el" href="structAIToolbox_1_1POMDP_1_1VEntry.html">VEntry</a> &amp;ve)</td></tr>
<tr class="memdesc:ac8532961013ec06fe6d47960b71ae822"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function is used as iterator projection to obtain the Values of a <a class="el" href="structAIToolbox_1_1POMDP_1_1VEntry.html">VEntry</a>.  <a href="namespaceAIToolbox_1_1POMDP.html#ac8532961013ec06fe6d47960b71ae822">More...</a><br /></td></tr>
<tr class="separator:ac8532961013ec06fe6d47960b71ae822"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3f341f4ae91af26c67abd8e650522fdf"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceAIToolbox_1_1POMDP.html#ab1cada9fef241e48a9d14d36cb61dabb">ValueFunction</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceAIToolbox_1_1POMDP.html#a3f341f4ae91af26c67abd8e650522fdf">makeValueFunction</a> (size_t S)</td></tr>
<tr class="memdesc:a3f341f4ae91af26c67abd8e650522fdf"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function creates a default ValueFunction.  <a href="namespaceAIToolbox_1_1POMDP.html#a3f341f4ae91af26c67abd8e650522fdf">More...</a><br /></td></tr>
<tr class="separator:a3f341f4ae91af26c67abd8e650522fdf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a05e4fb4a18324709e70b42d66cf2054b"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceAIToolbox_1_1POMDP.html#a05e4fb4a18324709e70b42d66cf2054b">weakBoundDistance</a> (const <a class="el" href="namespaceAIToolbox_1_1POMDP.html#a5655ffd334a1e53622314eae70eab464">VList</a> &amp;oldV, const <a class="el" href="namespaceAIToolbox_1_1POMDP.html#a5655ffd334a1e53622314eae70eab464">VList</a> &amp;newV)</td></tr>
<tr class="memdesc:a05e4fb4a18324709e70b42d66cf2054b"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function returns a weak measure of distance between two VLists.  <a href="namespaceAIToolbox_1_1POMDP.html#a05e4fb4a18324709e70b42d66cf2054b">More...</a><br /></td></tr>
<tr class="separator:a05e4fb4a18324709e70b42d66cf2054b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a18f4d95909ab7eeee98d04317c5e88ac"><td class="memTemplParams" colspan="2">template&lt;typename M , std::enable_if_t&lt; is_model_v&lt; M &gt;, int &gt;  = 0&gt; </td></tr>
<tr class="memitem:a18f4d95909ab7eeee98d04317c5e88ac"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceAIToolbox_1_1POMDP.html#a18f4d95909ab7eeee98d04317c5e88ac">makeSOSA</a> (const M &amp;m)</td></tr>
<tr class="memdesc:a18f4d95909ab7eeee98d04317c5e88ac"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function creates the SOSA matrix for the input <a class="el" href="namespaceAIToolbox_1_1POMDP.html">POMDP</a>.  <a href="namespaceAIToolbox_1_1POMDP.html#a18f4d95909ab7eeee98d04317c5e88ac">More...</a><br /></td></tr>
<tr class="separator:a18f4d95909ab7eeee98d04317c5e88ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6a6deb0f6f3d12bb59f0b9813604abc2"><td class="memTemplParams" colspan="2">template&lt;typename M , std::enable_if_t&lt; is_model_v&lt; M &gt;, int &gt;  = 0&gt; </td></tr>
<tr class="memitem:a6a6deb0f6f3d12bb59f0b9813604abc2"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceAIToolbox_1_1POMDP.html#a6a6deb0f6f3d12bb59f0b9813604abc2">updateBeliefUnnormalized</a> (const M &amp;model, const <a class="el" href="namespaceAIToolbox_1_1POMDP.html#a4522c5e35483fb30b2c43c271781e8bc">Belief</a> &amp;b, const size_t a, const size_t o, <a class="el" href="namespaceAIToolbox_1_1POMDP.html#a4522c5e35483fb30b2c43c271781e8bc">Belief</a> *bRet)</td></tr>
<tr class="memdesc:a6a6deb0f6f3d12bb59f0b9813604abc2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new belief reflecting changes after an action and observation for a particular <a class="el" href="classAIToolbox_1_1POMDP_1_1Model.html" title="This class represents a Partially Observable Markov Decision Process.">Model</a>.  <a href="namespaceAIToolbox_1_1POMDP.html#a6a6deb0f6f3d12bb59f0b9813604abc2">More...</a><br /></td></tr>
<tr class="separator:a6a6deb0f6f3d12bb59f0b9813604abc2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeadb8ad292520175aea2ad4b9173c5cd"><td class="memTemplParams" colspan="2">template&lt;typename M , std::enable_if_t&lt; is_model_v&lt; M &gt;, int &gt;  = 0&gt; </td></tr>
<tr class="memitem:aeadb8ad292520175aea2ad4b9173c5cd"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespaceAIToolbox_1_1POMDP.html#a4522c5e35483fb30b2c43c271781e8bc">Belief</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceAIToolbox_1_1POMDP.html#aeadb8ad292520175aea2ad4b9173c5cd">updateBeliefUnnormalized</a> (const M &amp;model, const <a class="el" href="namespaceAIToolbox_1_1POMDP.html#a4522c5e35483fb30b2c43c271781e8bc">Belief</a> &amp;b, const size_t a, const size_t o)</td></tr>
<tr class="memdesc:aeadb8ad292520175aea2ad4b9173c5cd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new belief reflecting changes after an action and observation for a particular <a class="el" href="classAIToolbox_1_1POMDP_1_1Model.html" title="This class represents a Partially Observable Markov Decision Process.">Model</a>.  <a href="namespaceAIToolbox_1_1POMDP.html#aeadb8ad292520175aea2ad4b9173c5cd">More...</a><br /></td></tr>
<tr class="separator:aeadb8ad292520175aea2ad4b9173c5cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a33a1c23c71b6afae16da4db1863bf68d"><td class="memTemplParams" colspan="2">template&lt;typename M , std::enable_if_t&lt; is_model_v&lt; M &gt;, int &gt;  = 0&gt; </td></tr>
<tr class="memitem:a33a1c23c71b6afae16da4db1863bf68d"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceAIToolbox_1_1POMDP.html#a33a1c23c71b6afae16da4db1863bf68d">updateBelief</a> (const M &amp;model, const <a class="el" href="namespaceAIToolbox_1_1POMDP.html#a4522c5e35483fb30b2c43c271781e8bc">Belief</a> &amp;b, const size_t a, const size_t o, <a class="el" href="namespaceAIToolbox_1_1POMDP.html#a4522c5e35483fb30b2c43c271781e8bc">Belief</a> *bRet)</td></tr>
<tr class="memdesc:a33a1c23c71b6afae16da4db1863bf68d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new belief reflecting changes after an action and observation for a particular <a class="el" href="classAIToolbox_1_1POMDP_1_1Model.html" title="This class represents a Partially Observable Markov Decision Process.">Model</a>.  <a href="namespaceAIToolbox_1_1POMDP.html#a33a1c23c71b6afae16da4db1863bf68d">More...</a><br /></td></tr>
<tr class="separator:a33a1c23c71b6afae16da4db1863bf68d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad19c9f085248dc19299d511194210843"><td class="memTemplParams" colspan="2">template&lt;typename M , std::enable_if_t&lt; is_model_v&lt; M &gt;, int &gt;  = 0&gt; </td></tr>
<tr class="memitem:ad19c9f085248dc19299d511194210843"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespaceAIToolbox_1_1POMDP.html#a4522c5e35483fb30b2c43c271781e8bc">Belief</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceAIToolbox_1_1POMDP.html#ad19c9f085248dc19299d511194210843">updateBelief</a> (const M &amp;model, const <a class="el" href="namespaceAIToolbox_1_1POMDP.html#a4522c5e35483fb30b2c43c271781e8bc">Belief</a> &amp;b, const size_t a, const size_t o)</td></tr>
<tr class="memdesc:ad19c9f085248dc19299d511194210843"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new belief reflecting changes after an action and observation for a particular <a class="el" href="classAIToolbox_1_1POMDP_1_1Model.html" title="This class represents a Partially Observable Markov Decision Process.">Model</a>.  <a href="namespaceAIToolbox_1_1POMDP.html#ad19c9f085248dc19299d511194210843">More...</a><br /></td></tr>
<tr class="separator:ad19c9f085248dc19299d511194210843"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a413832fe24061c45091f0a24e7a7eee2"><td class="memTemplParams" colspan="2">template&lt;typename M , std::enable_if_t&lt; is_model_v&lt; M &gt;, int &gt;  = 0&gt; </td></tr>
<tr class="memitem:a413832fe24061c45091f0a24e7a7eee2"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceAIToolbox_1_1POMDP.html#a413832fe24061c45091f0a24e7a7eee2">updateBeliefPartial</a> (const M &amp;model, const <a class="el" href="namespaceAIToolbox_1_1POMDP.html#a4522c5e35483fb30b2c43c271781e8bc">Belief</a> &amp;b, const size_t a, <a class="el" href="namespaceAIToolbox_1_1POMDP.html#a4522c5e35483fb30b2c43c271781e8bc">Belief</a> *bRet)</td></tr>
<tr class="memdesc:a413832fe24061c45091f0a24e7a7eee2"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function partially updates a belief.  <a href="namespaceAIToolbox_1_1POMDP.html#a413832fe24061c45091f0a24e7a7eee2">More...</a><br /></td></tr>
<tr class="separator:a413832fe24061c45091f0a24e7a7eee2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af9903a18de2b0961d2f9a58f18bed9e5"><td class="memTemplParams" colspan="2">template&lt;typename M , std::enable_if_t&lt; is_model_v&lt; M &gt;, int &gt;  = 0&gt; </td></tr>
<tr class="memitem:af9903a18de2b0961d2f9a58f18bed9e5"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespaceAIToolbox_1_1POMDP.html#a4522c5e35483fb30b2c43c271781e8bc">Belief</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceAIToolbox_1_1POMDP.html#af9903a18de2b0961d2f9a58f18bed9e5">updateBeliefPartial</a> (const M &amp;model, const <a class="el" href="namespaceAIToolbox_1_1POMDP.html#a4522c5e35483fb30b2c43c271781e8bc">Belief</a> &amp;b, const size_t a)</td></tr>
<tr class="memdesc:af9903a18de2b0961d2f9a58f18bed9e5"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function partially updates a belief.  <a href="namespaceAIToolbox_1_1POMDP.html#af9903a18de2b0961d2f9a58f18bed9e5">More...</a><br /></td></tr>
<tr class="separator:af9903a18de2b0961d2f9a58f18bed9e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0f00347484bfd228db82d264a889d649"><td class="memTemplParams" colspan="2">template&lt;typename M , std::enable_if_t&lt; is_model_v&lt; M &gt;, int &gt;  = 0&gt; </td></tr>
<tr class="memitem:a0f00347484bfd228db82d264a889d649"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceAIToolbox_1_1POMDP.html#a0f00347484bfd228db82d264a889d649">updateBeliefPartialUnnormalized</a> (const M &amp;model, const <a class="el" href="namespaceAIToolbox_1_1POMDP.html#a4522c5e35483fb30b2c43c271781e8bc">Belief</a> &amp;b, const size_t a, const size_t o, <a class="el" href="namespaceAIToolbox_1_1POMDP.html#a4522c5e35483fb30b2c43c271781e8bc">Belief</a> *bRet)</td></tr>
<tr class="memdesc:a0f00347484bfd228db82d264a889d649"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function terminates the unnormalized update of a partially updated belief.  <a href="namespaceAIToolbox_1_1POMDP.html#a0f00347484bfd228db82d264a889d649">More...</a><br /></td></tr>
<tr class="separator:a0f00347484bfd228db82d264a889d649"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad03a82580eea9bba77d72052b181168a"><td class="memTemplParams" colspan="2">template&lt;typename M , std::enable_if_t&lt; is_model_v&lt; M &gt;, int &gt;  = 0&gt; </td></tr>
<tr class="memitem:ad03a82580eea9bba77d72052b181168a"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespaceAIToolbox_1_1POMDP.html#a4522c5e35483fb30b2c43c271781e8bc">Belief</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceAIToolbox_1_1POMDP.html#ad03a82580eea9bba77d72052b181168a">updateBeliefPartialUnnormalized</a> (const M &amp;model, const <a class="el" href="namespaceAIToolbox_1_1POMDP.html#a4522c5e35483fb30b2c43c271781e8bc">Belief</a> &amp;b, const size_t a, const size_t o)</td></tr>
<tr class="memdesc:ad03a82580eea9bba77d72052b181168a"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function terminates the unnormalized update of a partially updated belief.  <a href="namespaceAIToolbox_1_1POMDP.html#ad03a82580eea9bba77d72052b181168a">More...</a><br /></td></tr>
<tr class="separator:ad03a82580eea9bba77d72052b181168a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3be3dce28e8d80fe6457ebbe0b5da9cb"><td class="memTemplParams" colspan="2">template&lt;typename M , std::enable_if_t&lt; is_model_v&lt; M &gt;, int &gt;  = 0&gt; </td></tr>
<tr class="memitem:a3be3dce28e8d80fe6457ebbe0b5da9cb"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceAIToolbox_1_1POMDP.html#a3be3dce28e8d80fe6457ebbe0b5da9cb">updateBeliefPartialNormalized</a> (const M &amp;model, const <a class="el" href="namespaceAIToolbox_1_1POMDP.html#a4522c5e35483fb30b2c43c271781e8bc">Belief</a> &amp;b, const size_t a, const size_t o, <a class="el" href="namespaceAIToolbox_1_1POMDP.html#a4522c5e35483fb30b2c43c271781e8bc">Belief</a> *bRet)</td></tr>
<tr class="memdesc:a3be3dce28e8d80fe6457ebbe0b5da9cb"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function terminates the normalized update of a partially updated belief.  <a href="namespaceAIToolbox_1_1POMDP.html#a3be3dce28e8d80fe6457ebbe0b5da9cb">More...</a><br /></td></tr>
<tr class="separator:a3be3dce28e8d80fe6457ebbe0b5da9cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0fe1545a75c1d70a6fd97cb876bff9e2"><td class="memTemplParams" colspan="2">template&lt;typename M , std::enable_if_t&lt; is_model_v&lt; M &gt;, int &gt;  = 0&gt; </td></tr>
<tr class="memitem:a0fe1545a75c1d70a6fd97cb876bff9e2"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespaceAIToolbox_1_1POMDP.html#a4522c5e35483fb30b2c43c271781e8bc">Belief</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceAIToolbox_1_1POMDP.html#a0fe1545a75c1d70a6fd97cb876bff9e2">updateBeliefPartialNormalized</a> (const M &amp;model, const <a class="el" href="namespaceAIToolbox_1_1POMDP.html#a4522c5e35483fb30b2c43c271781e8bc">Belief</a> &amp;b, const size_t a, const size_t o)</td></tr>
<tr class="memdesc:a0fe1545a75c1d70a6fd97cb876bff9e2"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function terminates the normalized update of a partially updated belief.  <a href="namespaceAIToolbox_1_1POMDP.html#a0fe1545a75c1d70a6fd97cb876bff9e2">More...</a><br /></td></tr>
<tr class="separator:a0fe1545a75c1d70a6fd97cb876bff9e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a49e94718a9c0e92e4c0da630aa5d3dc9"><td class="memTemplParams" colspan="2">template&lt;typename M , std::enable_if_t&lt; is_model_v&lt; M &gt;, int &gt;  = 0&gt; </td></tr>
<tr class="memitem:a49e94718a9c0e92e4c0da630aa5d3dc9"><td class="memTemplItemLeft" align="right" valign="top">double&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceAIToolbox_1_1POMDP.html#a49e94718a9c0e92e4c0da630aa5d3dc9">beliefExpectedReward</a> (const M &amp;model, const <a class="el" href="namespaceAIToolbox_1_1POMDP.html#a4522c5e35483fb30b2c43c271781e8bc">Belief</a> &amp;b, const size_t a)</td></tr>
<tr class="memdesc:a49e94718a9c0e92e4c0da630aa5d3dc9"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function computes an immediate reward based on a belief rather than a state.  <a href="namespaceAIToolbox_1_1POMDP.html#a49e94718a9c0e92e4c0da630aa5d3dc9">More...</a><br /></td></tr>
<tr class="separator:a49e94718a9c0e92e4c0da630aa5d3dc9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a29c6a60175a6d93b7ec845c2a2cec928"><td class="memTemplParams" colspan="2">template&lt;typename ActionRow &gt; </td></tr>
<tr class="memitem:a29c6a60175a6d93b7ec845c2a2cec928"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structAIToolbox_1_1POMDP_1_1VEntry.html">VEntry</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceAIToolbox_1_1POMDP.html#a29c6a60175a6d93b7ec845c2a2cec928">crossSumBestAtBelief</a> (const <a class="el" href="namespaceAIToolbox_1_1POMDP.html#a4522c5e35483fb30b2c43c271781e8bc">Belief</a> &amp;b, const ActionRow &amp;row, const size_t a, double *value=nullptr)</td></tr>
<tr class="memdesc:a29c6a60175a6d93b7ec845c2a2cec928"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function computes the best <a class="el" href="structAIToolbox_1_1POMDP_1_1VEntry.html">VEntry</a> for the input belief from the input VLists.  <a href="namespaceAIToolbox_1_1POMDP.html#a29c6a60175a6d93b7ec845c2a2cec928">More...</a><br /></td></tr>
<tr class="separator:a29c6a60175a6d93b7ec845c2a2cec928"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b1bf71cbc9a2c566437f1cda780c123"><td class="memTemplParams" colspan="2">template&lt;typename Projections &gt; </td></tr>
<tr class="memitem:a7b1bf71cbc9a2c566437f1cda780c123"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structAIToolbox_1_1POMDP_1_1VEntry.html">VEntry</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceAIToolbox_1_1POMDP.html#a7b1bf71cbc9a2c566437f1cda780c123">crossSumBestAtBelief</a> (const <a class="el" href="namespaceAIToolbox_1_1POMDP.html#a4522c5e35483fb30b2c43c271781e8bc">Belief</a> &amp;b, const Projections &amp;projs, double *value=nullptr)</td></tr>
<tr class="memdesc:a7b1bf71cbc9a2c566437f1cda780c123"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function computes the best <a class="el" href="structAIToolbox_1_1POMDP_1_1VEntry.html">VEntry</a> for the input belief across all actions.  <a href="namespaceAIToolbox_1_1POMDP.html#a7b1bf71cbc9a2c566437f1cda780c123">More...</a><br /></td></tr>
<tr class="separator:a7b1bf71cbc9a2c566437f1cda780c123"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2a7aa24800d72c0eef0139c3f989d36f"><td class="memTemplParams" colspan="2">template&lt;typename M , std::enable_if_t&lt; is_model_v&lt; M &gt;, int &gt;  = 0&gt; </td></tr>
<tr class="memitem:a2a7aa24800d72c0eef0139c3f989d36f"><td class="memTemplItemLeft" align="right" valign="top">std::tuple&lt; size_t, double &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceAIToolbox_1_1POMDP.html#a2a7aa24800d72c0eef0139c3f989d36f">bestConservativeAction</a> (const M &amp;pomdp, <a class="el" href="namespaceAIToolbox_1_1MDP.html#a7511ad35cec2e20bf392458125e28ebc">MDP::QFunction</a> immediateRewards, const <a class="el" href="namespaceAIToolbox_1_1POMDP.html#a4522c5e35483fb30b2c43c271781e8bc">Belief</a> &amp;initialBelief, const <a class="el" href="namespaceAIToolbox_1_1POMDP.html#a5655ffd334a1e53622314eae70eab464">VList</a> &amp;lbVList, <a class="el" href="namespaceAIToolbox_1_1MDP.html#ae6bfccca3b00146c82eb345ca8490b74">MDP::Values</a> *alpha=nullptr)</td></tr>
<tr class="memdesc:a2a7aa24800d72c0eef0139c3f989d36f"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function obtains the best action with respect to the input VList.  <a href="namespaceAIToolbox_1_1POMDP.html#a2a7aa24800d72c0eef0139c3f989d36f">More...</a><br /></td></tr>
<tr class="separator:a2a7aa24800d72c0eef0139c3f989d36f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abd6029ce127e9ec0495c02433b5c690e"><td class="memTemplParams" colspan="2">template&lt;bool useLP = true, typename M , std::enable_if_t&lt; is_model_v&lt; M &gt;, int &gt;  = 0&gt; </td></tr>
<tr class="memitem:abd6029ce127e9ec0495c02433b5c690e"><td class="memTemplItemLeft" align="right" valign="top">std::tuple&lt; size_t, double &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceAIToolbox_1_1POMDP.html#abd6029ce127e9ec0495c02433b5c690e">bestPromisingAction</a> (const M &amp;pomdp, const <a class="el" href="namespaceAIToolbox_1_1MDP.html#a7511ad35cec2e20bf392458125e28ebc">MDP::QFunction</a> &amp;immediateRewards, const <a class="el" href="namespaceAIToolbox_1_1POMDP.html#a4522c5e35483fb30b2c43c271781e8bc">Belief</a> &amp;belief, const <a class="el" href="namespaceAIToolbox_1_1MDP.html#a7511ad35cec2e20bf392458125e28ebc">MDP::QFunction</a> &amp;ubQ, const <a class="el" href="namespaceAIToolbox_1_1POMDP.html#ace6914f598eab0d79bf4e533295d6839">UpperBoundValueFunction</a> &amp;ubV, <a class="el" href="namespaceAIToolbox.html#a1e6976de7a0159cd1630c4f2553fc9f3">Vector</a> *vals=nullptr)</td></tr>
<tr class="memdesc:abd6029ce127e9ec0495c02433b5c690e"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function obtains the best action with respect to the input QFunction and UbV.  <a href="namespaceAIToolbox_1_1POMDP.html#abd6029ce127e9ec0495c02433b5c690e">More...</a><br /></td></tr>
<tr class="separator:abd6029ce127e9ec0495c02433b5c690e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:a30d62c33ae0e760503f3712b498b3e47"><td class="memTemplParams" colspan="2">template&lt;typename LP &gt; </td></tr>
<tr class="memitem:a30d62c33ae0e760503f3712b498b3e47"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceAIToolbox_1_1POMDP.html#a30d62c33ae0e760503f3712b498b3e47">is_witness_lp_v</a> = <a class="el" href="structAIToolbox_1_1POMDP_1_1is__witness__lp.html">is_witness_lp</a>&lt;<a class="el" href="classAIToolbox_1_1LP.html">LP</a>&gt;::value</td></tr>
<tr class="separator:a30d62c33ae0e760503f3712b498b3e47"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a14f2ade0c0d30091b74297fce650ddbf"><td class="memTemplParams" colspan="2">template&lt;typename M &gt; </td></tr>
<tr class="memitem:a14f2ade0c0d30091b74297fce650ddbf"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceAIToolbox_1_1POMDP.html#a14f2ade0c0d30091b74297fce650ddbf">is_generative_model_v</a> = <a class="el" href="structAIToolbox_1_1POMDP_1_1is__generative__model.html">is_generative_model</a>&lt;M&gt;::value</td></tr>
<tr class="separator:a14f2ade0c0d30091b74297fce650ddbf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c3d5eb7dc047b0b55379914b76fd132"><td class="memTemplParams" colspan="2">template&lt;typename M &gt; </td></tr>
<tr class="memitem:a7c3d5eb7dc047b0b55379914b76fd132"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceAIToolbox_1_1POMDP.html#a7c3d5eb7dc047b0b55379914b76fd132">is_model_v</a> = <a class="el" href="structAIToolbox_1_1POMDP_1_1is__model.html">is_model</a>&lt;M&gt;::value</td></tr>
<tr class="separator:a7c3d5eb7dc047b0b55379914b76fd132"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0a7899814376313aa6ee8dadecea379d"><td class="memTemplParams" colspan="2">template&lt;typename M &gt; </td></tr>
<tr class="memitem:a0a7899814376313aa6ee8dadecea379d"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceAIToolbox_1_1POMDP.html#a0a7899814376313aa6ee8dadecea379d">is_model_eigen_v</a> = <a class="el" href="structAIToolbox_1_1POMDP_1_1is__model__eigen.html">is_model_eigen</a>&lt;M&gt;::value</td></tr>
<tr class="separator:a0a7899814376313aa6ee8dadecea379d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abbf63587b8e90849d2501933a827061a"><td class="memTemplParams" colspan="2">template&lt;typename M &gt; </td></tr>
<tr class="memitem:abbf63587b8e90849d2501933a827061a"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceAIToolbox_1_1POMDP.html#abbf63587b8e90849d2501933a827061a">is_model_not_eigen_v</a> = <a class="el" href="structAIToolbox_1_1POMDP_1_1is__model__not__eigen.html">is_model_not_eigen</a>&lt;M&gt;::value</td></tr>
<tr class="separator:abbf63587b8e90849d2501933a827061a"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Typedef Documentation</h2>
<a id="a97f123407d50846293c4e9b46d7fbd49"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a97f123407d50846293c4e9b46d7fbd49">&#9670;&nbsp;</a></span>ActionNodes</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;bool UseEntropy&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceAIToolbox_1_1POMDP.html#a97f123407d50846293c4e9b46d7fbd49">AIToolbox::POMDP::ActionNodes</a> = typedef std::vector&lt;<a class="el" href="structAIToolbox_1_1POMDP_1_1ActionNode.html">ActionNode</a>&lt;UseEntropy&gt; &gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a4522c5e35483fb30b2c43c271781e8bc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4522c5e35483fb30b2c43c271781e8bc">&#9670;&nbsp;</a></span>Belief</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceAIToolbox_1_1POMDP.html#a4522c5e35483fb30b2c43c271781e8bc">AIToolbox::POMDP::Belief</a> = typedef <a class="el" href="namespaceAIToolbox.html#af4149b71e91dee03ad9d0c8c207eddf0">ProbabilityVector</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This represents a belief, which is a probability distribution over states. </p>

</div>
</div>
<a id="afba9c8e6204b8f6b341362af3991da75"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afba9c8e6204b8f6b341362af3991da75">&#9670;&nbsp;</a></span>BeliefNodes</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;bool UseEntropy&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceAIToolbox_1_1POMDP.html#afba9c8e6204b8f6b341362af3991da75">AIToolbox::POMDP::BeliefNodes</a> = typedef std::unordered_map&lt;size_t, <a class="el" href="classAIToolbox_1_1POMDP_1_1BeliefNode.html">BeliefNode</a>&lt;UseEntropy&gt; &gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a79664c416e1fbfe5d89acb9f94f35bee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a79664c416e1fbfe5d89acb9f94f35bee">&#9670;&nbsp;</a></span>SampleBelief</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceAIToolbox_1_1POMDP.html#a79664c416e1fbfe5d89acb9f94f35bee">AIToolbox::POMDP::SampleBelief</a> = typedef std::vector&lt;std::pair&lt;size_t, unsigned&gt; &gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ad867f06ad8946aa1b205a7f5f8fcb42e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad867f06ad8946aa1b205a7f5f8fcb42e">&#9670;&nbsp;</a></span>TrackBelief</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;bool UseEntropy&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceAIToolbox_1_1POMDP.html#ad867f06ad8946aa1b205a7f5f8fcb42e">AIToolbox::POMDP::TrackBelief</a> = typedef std::unordered_map&lt; size_t, <a class="el" href="structAIToolbox_1_1POMDP_1_1BeliefParticle.html">BeliefParticle</a>&lt;UseEntropy&gt;, std::hash&lt;size_t&gt;, std::equal_to&lt;size_t&gt; &gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ace6914f598eab0d79bf4e533295d6839"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ace6914f598eab0d79bf4e533295d6839">&#9670;&nbsp;</a></span>UpperBoundValueFunction</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceAIToolbox_1_1POMDP.html#ace6914f598eab0d79bf4e533295d6839">AIToolbox::POMDP::UpperBoundValueFunction</a> = typedef std::pair&lt;std::vector&lt;<a class="el" href="namespaceAIToolbox_1_1POMDP.html#a4522c5e35483fb30b2c43c271781e8bc">Belief</a>&gt;, std::vector&lt;double&gt; &gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ab1cada9fef241e48a9d14d36cb61dabb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab1cada9fef241e48a9d14d36cb61dabb">&#9670;&nbsp;</a></span>ValueFunction</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceAIToolbox_1_1POMDP.html#ab1cada9fef241e48a9d14d36cb61dabb">AIToolbox::POMDP::ValueFunction</a> = typedef std::vector&lt;<a class="el" href="namespaceAIToolbox_1_1POMDP.html#a5655ffd334a1e53622314eae70eab464">VList</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a5655ffd334a1e53622314eae70eab464"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5655ffd334a1e53622314eae70eab464">&#9670;&nbsp;</a></span>VList</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceAIToolbox_1_1POMDP.html#a5655ffd334a1e53622314eae70eab464">AIToolbox::POMDP::VList</a> = typedef std::vector&lt;<a class="el" href="structAIToolbox_1_1POMDP_1_1VEntry.html">VEntry</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a72aee7b57445d6b773012d9b54b85339"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a72aee7b57445d6b773012d9b54b85339">&#9670;&nbsp;</a></span>VObs</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceAIToolbox_1_1POMDP.html#a72aee7b57445d6b773012d9b54b85339">AIToolbox::POMDP::VObs</a> = typedef std::vector&lt;size_t&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="a49e94718a9c0e92e4c0da630aa5d3dc9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a49e94718a9c0e92e4c0da630aa5d3dc9">&#9670;&nbsp;</a></span>beliefExpectedReward()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename M , std::enable_if_t&lt; is_model_v&lt; M &gt;, int &gt;  = 0&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">double AIToolbox::POMDP::beliefExpectedReward </td>
          <td>(</td>
          <td class="paramtype">const M &amp;&#160;</td>
          <td class="paramname"><em>model</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceAIToolbox_1_1POMDP.html#a4522c5e35483fb30b2c43c271781e8bc">Belief</a> &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>a</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function computes an immediate reward based on a belief rather than a state. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">model</td><td>The <a class="el" href="namespaceAIToolbox_1_1POMDP.html">POMDP</a> model to use. </td></tr>
    <tr><td class="paramname">b</td><td>The belief to use. </td></tr>
    <tr><td class="paramname">a</td><td>The action performed from the belief.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The immediate reward. </dd></dl>

</div>
</div>
<a id="a2a7aa24800d72c0eef0139c3f989d36f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2a7aa24800d72c0eef0139c3f989d36f">&#9670;&nbsp;</a></span>bestConservativeAction()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename M , std::enable_if_t&lt; is_model_v&lt; M &gt;, int &gt;  = 0&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::tuple&lt;size_t, double&gt; AIToolbox::POMDP::bestConservativeAction </td>
          <td>(</td>
          <td class="paramtype">const M &amp;&#160;</td>
          <td class="paramname"><em>pomdp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceAIToolbox_1_1MDP.html#a7511ad35cec2e20bf392458125e28ebc">MDP::QFunction</a>&#160;</td>
          <td class="paramname"><em>immediateRewards</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceAIToolbox_1_1POMDP.html#a4522c5e35483fb30b2c43c271781e8bc">Belief</a> &amp;&#160;</td>
          <td class="paramname"><em>initialBelief</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceAIToolbox_1_1POMDP.html#a5655ffd334a1e53622314eae70eab464">VList</a> &amp;&#160;</td>
          <td class="paramname"><em>lbVList</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceAIToolbox_1_1MDP.html#ae6bfccca3b00146c82eb345ca8490b74">MDP::Values</a> *&#160;</td>
          <td class="paramname"><em>alpha</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function obtains the best action with respect to the input VList. </p>
<p>This function pretty much does what the <a class="el" href="classAIToolbox_1_1POMDP_1_1Projecter.html" title="This class offers projecting facilities for Models.">Projecter</a> class does. The difference is that while the <a class="el" href="classAIToolbox_1_1POMDP_1_1Projecter.html" title="This class offers projecting facilities for Models.">Projecter</a> expands one step in the future every single entry in the input VList, this only does it to the input Belief.</p>
<p>This allows to both avoid a lot of work if we wouldn't need to reuse the <a class="el" href="classAIToolbox_1_1POMDP_1_1Projecter.html" title="This class offers projecting facilities for Models.">Projecter</a> results a lot, and simplifies the crossSum step.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pomdp</td><td>The model to use. </td></tr>
    <tr><td class="paramname">immediateRewards</td><td>The immediate rewards of the model. </td></tr>
    <tr><td class="paramname">initialBelief</td><td>The belief where the best action needs to be found. </td></tr>
    <tr><td class="paramname">lbVList</td><td>The alphavectors to use. </td></tr>
    <tr><td class="paramname">alpha</td><td>Optionally, the output alphavector for the best action. Does not need preallocation.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The best action in the input belief with respect to the input VList. </dd></dl>

</div>
</div>
<a id="abd6029ce127e9ec0495c02433b5c690e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abd6029ce127e9ec0495c02433b5c690e">&#9670;&nbsp;</a></span>bestPromisingAction()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;bool useLP = true, typename M , std::enable_if_t&lt; is_model_v&lt; M &gt;, int &gt;  = 0&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::tuple&lt;size_t, double&gt; AIToolbox::POMDP::bestPromisingAction </td>
          <td>(</td>
          <td class="paramtype">const M &amp;&#160;</td>
          <td class="paramname"><em>pomdp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceAIToolbox_1_1MDP.html#a7511ad35cec2e20bf392458125e28ebc">MDP::QFunction</a> &amp;&#160;</td>
          <td class="paramname"><em>immediateRewards</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceAIToolbox_1_1POMDP.html#a4522c5e35483fb30b2c43c271781e8bc">Belief</a> &amp;&#160;</td>
          <td class="paramname"><em>belief</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceAIToolbox_1_1MDP.html#a7511ad35cec2e20bf392458125e28ebc">MDP::QFunction</a> &amp;&#160;</td>
          <td class="paramname"><em>ubQ</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceAIToolbox_1_1POMDP.html#ace6914f598eab0d79bf4e533295d6839">UpperBoundValueFunction</a> &amp;&#160;</td>
          <td class="paramname"><em>ubV</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceAIToolbox.html#a1e6976de7a0159cd1630c4f2553fc9f3">Vector</a> *&#160;</td>
          <td class="paramname"><em>vals</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function obtains the best action with respect to the input QFunction and UbV. </p>
<p>This function simply computes the upper bound for all beliefs that can be reached from the input belief. For each action, their values are summed (after multiplying each by the probability of it happening), and the best action extracted.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">useLP</td><td>Whether we want to use <a class="el" href="classAIToolbox_1_1LP.html" title="This class presents a common interface for solving Linear Programming problems.">LP</a> interpolation, rather than sawtooth. Defaults to true. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pomdp</td><td>The model to look the action for. </td></tr>
    <tr><td class="paramname">immediateRewards</td><td>The immediate rewards of the model. </td></tr>
    <tr><td class="paramname">belief</td><td>The belief to find the best action in. </td></tr>
    <tr><td class="paramname">ubQ</td><td>The current QFunction for this model. </td></tr>
    <tr><td class="paramname">ubV</td><td>The current list of belief/values for this model. </td></tr>
    <tr><td class="paramname">vals</td><td>Optionally, an output vector containing the per-action upper-bound values. Does not need preallocation, and passing it does not result in more work.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The best action-value pair. </dd></dl>

</div>
</div>
<a id="a29c6a60175a6d93b7ec845c2a2cec928"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a29c6a60175a6d93b7ec845c2a2cec928">&#9670;&nbsp;</a></span>crossSumBestAtBelief() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ActionRow &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structAIToolbox_1_1POMDP_1_1VEntry.html">VEntry</a> AIToolbox::POMDP::crossSumBestAtBelief </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceAIToolbox_1_1POMDP.html#a4522c5e35483fb30b2c43c271781e8bc">Belief</a> &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ActionRow &amp;&#160;</td>
          <td class="paramname"><em>row</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>value</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function computes the best <a class="el" href="structAIToolbox_1_1POMDP_1_1VEntry.html">VEntry</a> for the input belief from the input VLists. </p>
<p>This function computes the best alphavector for the input belief. It assumes as input a list of VLists, one per observation. You can produce them with the <a class="el" href="classAIToolbox_1_1POMDP_1_1Projecter.html" title="This class offers projecting facilities for Models.">Projecter</a> class, for example.</p>
<p>For each observation it will select the match with the best value, and use it to compute the output <a class="el" href="structAIToolbox_1_1POMDP_1_1VEntry.html">VEntry</a>.</p>
<p>The action is not used to perform computations here, but it is fed directly into the returned <a class="el" href="structAIToolbox_1_1POMDP_1_1VEntry.html">VEntry</a>.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">ActionRow</td><td>The type of the list of VLists. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">b</td><td>The belief to compute the <a class="el" href="structAIToolbox_1_1POMDP_1_1VEntry.html">VEntry</a> for. </td></tr>
    <tr><td class="paramname">row</td><td>The list of VLists, one per observation. </td></tr>
    <tr><td class="paramname">a</td><td>The action this Ventry stands for. </td></tr>
    <tr><td class="paramname">value</td><td>A pointer to double, which gets set to the value of the given belief with the generated <a class="el" href="structAIToolbox_1_1POMDP_1_1VEntry.html">VEntry</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The best <a class="el" href="structAIToolbox_1_1POMDP_1_1VEntry.html">VEntry</a> for the input belief. </dd></dl>

</div>
</div>
<a id="a7b1bf71cbc9a2c566437f1cda780c123"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7b1bf71cbc9a2c566437f1cda780c123">&#9670;&nbsp;</a></span>crossSumBestAtBelief() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Projections &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structAIToolbox_1_1POMDP_1_1VEntry.html">VEntry</a> AIToolbox::POMDP::crossSumBestAtBelief </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceAIToolbox_1_1POMDP.html#a4522c5e35483fb30b2c43c271781e8bc">Belief</a> &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Projections &amp;&#160;</td>
          <td class="paramname"><em>projs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>value</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function computes the best <a class="el" href="structAIToolbox_1_1POMDP_1_1VEntry.html">VEntry</a> for the input belief across all actions. </p>
<p>This function needs the projections of the previous timestep's VLists in order to work. It will then compute the best <a class="el" href="structAIToolbox_1_1POMDP_1_1VEntry.html">VEntry</a> for the input belief across all actions.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Projections</td><td>The type of the 2D array of VLists containing all the projections. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">b</td><td>The belief to compute the <a class="el" href="structAIToolbox_1_1POMDP_1_1VEntry.html">VEntry</a> for. </td></tr>
    <tr><td class="paramname">projs</td><td>The projections of the old VLists. </td></tr>
    <tr><td class="paramname">value</td><td>A pointer to double, which gets set to the value of the given belief with the generated <a class="el" href="structAIToolbox_1_1POMDP_1_1VEntry.html">VEntry</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The best <a class="el" href="structAIToolbox_1_1POMDP_1_1VEntry.html">VEntry</a> for the input belief. </dd></dl>

</div>
</div>
<a id="a5254fac18b477fde30cff6ccbb131a63"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5254fac18b477fde30cff6ccbb131a63">&#9670;&nbsp;</a></span>hash_value()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t AIToolbox::POMDP::hash_value </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structAIToolbox_1_1POMDP_1_1VEntry.html">VEntry</a> &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This function enables hashing of VEntries with boost::hash. </p>

</div>
</div>
<a id="af6a629b143e07d3f001e7d1f193c35e1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af6a629b143e07d3f001e7d1f193c35e1">&#9670;&nbsp;</a></span>makeChengD35()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classAIToolbox_1_1POMDP_1_1Model.html">Model</a>&lt;<a class="el" href="classAIToolbox_1_1MDP_1_1Model.html">MDP::Model</a>&gt; AIToolbox::POMDP::makeChengD35 </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function returns a <a class="el" href="namespaceAIToolbox_1_1POMDP.html">POMDP</a> model of the chengD35 problem. </p>

</div>
</div>
<a id="aec8902c4e5cc3a90884f269c13d03b0d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aec8902c4e5cc3a90884f269c13d03b0d">&#9670;&nbsp;</a></span>makeEJS4()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classAIToolbox_1_1POMDP_1_1Model.html">Model</a>&lt;<a class="el" href="classAIToolbox_1_1MDP_1_1Model.html">MDP::Model</a>&gt; AIToolbox::POMDP::makeEJS4 </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function returns a <a class="el" href="namespaceAIToolbox_1_1POMDP.html">POMDP</a> model of the ejs4 problem. </p>

</div>
</div>
<a id="a18f4d95909ab7eeee98d04317c5e88ac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a18f4d95909ab7eeee98d04317c5e88ac">&#9670;&nbsp;</a></span>makeSOSA()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename M , std::enable_if_t&lt; is_model_v&lt; M &gt;, int &gt;  = 0&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto AIToolbox::POMDP::makeSOSA </td>
          <td>(</td>
          <td class="paramtype">const M &amp;&#160;</td>
          <td class="paramname"><em>m</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function creates the SOSA matrix for the input <a class="el" href="namespaceAIToolbox_1_1POMDP.html">POMDP</a>. </p>
<p>The SOSA matrix is a way to represent the observation and transition functions in a single function, at the same time.</p>
<p>Each cell in this four-dimensional matrix contains the probability of getting to state s' while obtaining observation o when starting with state s and action a.</p>
<p>This matrix is less space-efficient than storing both matrices separately, but it can save you some time if you need its values multiple times in a loop (for example in the <a class="el" href="classAIToolbox_1_1POMDP_1_1FastInformedBound.html" title="This class implements the Fast Informed Bound algorithm.">FastInformedBound</a> algorithm).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">m</td><td>The input <a class="el" href="namespaceAIToolbox_1_1POMDP.html">POMDP</a> to extract the SOSA matrix from.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The SOSA matrix for the input pomdp. </dd></dl>

</div>
</div>
<a id="abcd38fafda125d7a1e44a0d04c56e0e0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abcd38fafda125d7a1e44a0d04c56e0e0">&#9670;&nbsp;</a></span>makeTigerProblem()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classAIToolbox_1_1POMDP_1_1Model.html">AIToolbox::POMDP::Model</a>&lt;<a class="el" href="classAIToolbox_1_1MDP_1_1Model.html">AIToolbox::MDP::Model</a>&gt; AIToolbox::POMDP::makeTigerProblem </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This function sets up the tiger problem in a <a class="el" href="classAIToolbox_1_1POMDP_1_1Model.html" title="This class represents a Partially Observable Markov Decision Process.">Model</a>. </p>
<p>This function builds the AAAI-94 Tiger problem, with a 0.95 discount factor. The problem can be stated as follows:</p>
<p>The agent stands in front of two doors. He can open either of them. Behind one door, there is an agent-eater tiger, and in the other a small treasure. The agent does not know to what each door leads to, but instead of just opening the door, he can listen. When he listens, it will hear the tiger from either the left or right door. Its hearing is imperfect though, and 15% of the time it will hear the tiger behind the wrong door.</p>
<p>Once the agent opens a door, it will either get a great penalty due to being eaten by the tiger, or get the reward. After that the game will automatically reset to an unknown state: the agent needs to start guessing again where the new tiger and treasure are.</p>
<p>The states here are the positions of the tiger and treasure: since there are two doors, there are two states.</p>
<p>There are three actions, corresponding to the listen action and open door actions.</p>
<p>There are two possible observations, which are always random but for the listen action: in that case, we will obtain the correct information about the true state 85% of the time.</p>
<p>The solutions of this problem have been computed using Tony Cassandra's pomdp-solve program (www.pomdp.org).</p>
<dl class="section return"><dt>Returns</dt><dd>The <a class="el" href="classAIToolbox_1_1POMDP_1_1Model.html" title="This class represents a Partially Observable Markov Decision Process.">Model</a> representing the problem. </dd></dl>

</div>
</div>
<a id="a3f341f4ae91af26c67abd8e650522fdf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3f341f4ae91af26c67abd8e650522fdf">&#9670;&nbsp;</a></span>makeValueFunction()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceAIToolbox_1_1POMDP.html#ab1cada9fef241e48a9d14d36cb61dabb">ValueFunction</a> AIToolbox::POMDP::makeValueFunction </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>S</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function creates a default ValueFunction. </p>
<p>The default ValueFunction contains a single VList with inside a single <a class="el" href="structAIToolbox_1_1POMDP_1_1VEntry.html">VEntry</a>: do action 0, with all value zeroes.</p>
<p>The VList is a necessary byproduct that is needed when computing the whole ValueFunction recursively via dynamic programming.</p>
<p>In the end, to act, it's not needed, but it's probably more hassle to remove the entry, and so we leave it there. So in general we always assume it's there.</p>
<p>Another peculiarity of the default <a class="el" href="structAIToolbox_1_1POMDP_1_1VEntry.html">VEntry</a> is that it's the only place where the observation id vector is empty, since nobody is ever supposed to go looking in there.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">S</td><td>The number of possible states.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A new ValueFunction. </dd></dl>

</div>
</div>
<a id="a3dd0669f710850fc93fe8f7b102fb1b6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3dd0669f710850fc93fe8f7b102fb1b6">&#9670;&nbsp;</a></span>operator&lt;()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool AIToolbox::POMDP::operator&lt; </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structAIToolbox_1_1POMDP_1_1VEntry.html">VEntry</a> &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structAIToolbox_1_1POMDP_1_1VEntry.html">VEntry</a> &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function lexicographically sorts VEntries. </p>
<p>This is useful during testing in order to sort and compare a solution with the correct result.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>The left hand side of the comparison. </td></tr>
    <tr><td class="paramname">rhs</td><td>The right hand side of the comparison.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if lhs is less than rhs lexicographically, false otherwise. </dd></dl>

</div>
</div>
<a id="af460a8a2b997c9c93e620e9f805fcaf3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af460a8a2b997c9c93e620e9f805fcaf3">&#9670;&nbsp;</a></span>operator&lt;&lt;() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename M , std::enable_if_t&lt; is_model_v&lt; M &gt;, int &gt;  = 0&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; AIToolbox::POMDP::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const M &amp;&#160;</td>
          <td class="paramname"><em>model</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function prints any <a class="el" href="namespaceAIToolbox_1_1POMDP.html">POMDP</a> model to a file. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">M</td><td>The type of the model. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">os</td><td>The output stream. </td></tr>
    <tr><td class="paramname">model</td><td>The model to print.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The resulting output stream. </dd></dl>

</div>
</div>
<a id="a46eee8111107489e3d68d30055722ed8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a46eee8111107489e3d68d30055722ed8">&#9670;&nbsp;</a></span>operator&lt;&lt;() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; AIToolbox::POMDP::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classAIToolbox_1_1POMDP_1_1Policy.html">Policy</a> &amp;&#160;</td>
          <td class="paramname"><em>p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function prints the whole policy to a stream. </p>
<p>This function basically outputs the internal ValueFunction in a recoverable format.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">os</td><td>The stream where the policy is printed. </td></tr>
    <tr><td class="paramname">p</td><td>The policy that is begin printed.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The original stream. </dd></dl>

</div>
</div>
<a id="a45f5d972365404bca4ddfbef575b1bd0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a45f5d972365404bca4ddfbef575b1bd0">&#9670;&nbsp;</a></span>operator==()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool AIToolbox::POMDP::operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structAIToolbox_1_1POMDP_1_1VEntry.html">VEntry</a> &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structAIToolbox_1_1POMDP_1_1VEntry.html">VEntry</a> &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a3e6938312f6dd9d20f1f3767bb361a76"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3e6938312f6dd9d20f1f3767bb361a76">&#9670;&nbsp;</a></span>operator&gt;&gt;() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename M , typename &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::istream &amp; AIToolbox::POMDP::operator&gt;&gt; </td>
          <td>(</td>
          <td class="paramtype">std::istream &amp;&#160;</td>
          <td class="paramname"><em>is</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classAIToolbox_1_1POMDP_1_1Model.html">Model</a>&lt; M &gt; &amp;&#160;</td>
          <td class="paramname"><em>m</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function implements input from stream for the <a class="el" href="classAIToolbox_1_1POMDP_1_1Model.html" title="This class represents a Partially Observable Markov Decision Process.">POMDP::Model</a> class. </p>
<p>Note that as all other input function, it does not actually change the input model if the reading fails.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">M</td><td>The underlying <a class="el" href="namespaceAIToolbox_1_1MDP.html">MDP</a> model. Needs to have operator&lt;&lt; implemented. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">is</td><td>The input stream. </td></tr>
    <tr><td class="paramname">m</td><td>The model to write into.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The input stream. </dd></dl>

</div>
</div>
<a id="a17b5a1ad1cf5759d34c6a8470089f9e1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a17b5a1ad1cf5759d34c6a8470089f9e1">&#9670;&nbsp;</a></span>operator&gt;&gt;() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::istream&amp; AIToolbox::POMDP::operator&gt;&gt; </td>
          <td>(</td>
          <td class="paramtype">std::istream &amp;&#160;</td>
          <td class="paramname"><em>is</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classAIToolbox_1_1POMDP_1_1Policy.html">Policy</a> &amp;&#160;</td>
          <td class="paramname"><em>p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function reads a policy from a file. </p>
<p>This function reads files that have been outputted through <a class="el" href="namespaceAIToolbox_1_1POMDP.html#af460a8a2b997c9c93e620e9f805fcaf3" title="This function prints any POMDP model to a file.">operator&lt;&lt;()</a>. If not enough values can be extracted from the stream, the function stops and the input policy is not modified. In addition, it checks whether the probability values are within 0 and 1.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">is</td><td>The stream were the policy is being read from. </td></tr>
    <tr><td class="paramname">p</td><td>The policy that is being assigned.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The input stream. </dd></dl>

</div>
</div>
<a id="a55c4ff8e7537e5d77f5edd0038705393"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a55c4ff8e7537e5d77f5edd0038705393">&#9670;&nbsp;</a></span>operator&gt;&gt;() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename M , typename &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::istream &amp; AIToolbox::POMDP::operator&gt;&gt; </td>
          <td>(</td>
          <td class="paramtype">std::istream &amp;&#160;</td>
          <td class="paramname"><em>is</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classAIToolbox_1_1POMDP_1_1SparseModel.html">SparseModel</a>&lt; M &gt; &amp;&#160;</td>
          <td class="paramname"><em>m</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function implements input from stream for the <a class="el" href="classAIToolbox_1_1POMDP_1_1SparseModel.html" title="This class represents a Partially Observable Markov Decision Process.">POMDP::SparseModel</a> class. </p>
<p>Note that as all other input function, it does not actually change the input model if the reading fails.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">M</td><td>The underlying <a class="el" href="namespaceAIToolbox_1_1MDP.html">MDP</a> model. Needs to have operator&lt;&lt; implemented. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">is</td><td>The input stream. </td></tr>
    <tr><td class="paramname">m</td><td>The model to write into.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The input stream. </dd></dl>

</div>
</div>
<a id="a184e91a2441d41ffc7c249c587bf415c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a184e91a2441d41ffc7c249c587bf415c">&#9670;&nbsp;</a></span>parseCassandra()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classAIToolbox_1_1POMDP_1_1Model.html">Model</a>&lt;<a class="el" href="classAIToolbox_1_1MDP_1_1Model.html">MDP::Model</a>&gt; AIToolbox::POMDP::parseCassandra </td>
          <td>(</td>
          <td class="paramtype">std::istream &amp;&#160;</td>
          <td class="paramname"><em>input</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function parses a <a class="el" href="namespaceAIToolbox_1_1POMDP.html">POMDP</a> from a Cassandra formatted stream. </p>
<p>This function may throw std::runtime_errors depending on whether the input is correctly formed or not.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">input</td><td>The input stream.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The parsed model. </dd></dl>

</div>
</div>
<a id="ac8532961013ec06fe6d47960b71ae822"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac8532961013ec06fe6d47960b71ae822">&#9670;&nbsp;</a></span>unwrap()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="namespaceAIToolbox_1_1MDP.html#ae6bfccca3b00146c82eb345ca8490b74">MDP::Values</a>&amp; AIToolbox::POMDP::unwrap </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structAIToolbox_1_1POMDP_1_1VEntry.html">VEntry</a> &amp;&#160;</td>
          <td class="paramname"><em>ve</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This function is used as iterator projection to obtain the Values of a <a class="el" href="structAIToolbox_1_1POMDP_1_1VEntry.html">VEntry</a>. </p>

</div>
</div>
<a id="ad19c9f085248dc19299d511194210843"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad19c9f085248dc19299d511194210843">&#9670;&nbsp;</a></span>updateBelief() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename M , std::enable_if_t&lt; is_model_v&lt; M &gt;, int &gt;  = 0&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceAIToolbox_1_1POMDP.html#a4522c5e35483fb30b2c43c271781e8bc">Belief</a> AIToolbox::POMDP::updateBelief </td>
          <td>(</td>
          <td class="paramtype">const M &amp;&#160;</td>
          <td class="paramname"><em>model</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceAIToolbox_1_1POMDP.html#a4522c5e35483fb30b2c43c271781e8bc">Belief</a> &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>o</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a new belief reflecting changes after an action and observation for a particular <a class="el" href="classAIToolbox_1_1POMDP_1_1Model.html" title="This class represents a Partially Observable Markov Decision Process.">Model</a>. </p>
<p>This function needs to create a new belief since modifying a belief in place is not possible. This is because each cell update for the new belief requires all values from the previous belief.</p>
<p>NOTE: This function assumes that the update and the normalization are possible, i.e. that from the input belief and action it is possible to receive the input observation.</p>
<p>If that cannot be guaranteed, use the <a class="el" href="namespaceAIToolbox_1_1POMDP.html#a6a6deb0f6f3d12bb59f0b9813604abc2" title="Creates a new belief reflecting changes after an action and observation for a particular Model.">updateBeliefUnnormalized()</a> function and do the normalization yourself (and check for it).</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">M</td><td>The type of the <a class="el" href="namespaceAIToolbox_1_1POMDP.html">POMDP</a> <a class="el" href="classAIToolbox_1_1POMDP_1_1Model.html" title="This class represents a Partially Observable Markov Decision Process.">Model</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">model</td><td>The model used to update the belief. </td></tr>
    <tr><td class="paramname">b</td><td>The old belief. </td></tr>
    <tr><td class="paramname">a</td><td>The action taken during the transition. </td></tr>
    <tr><td class="paramname">o</td><td>The observation registered. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a33a1c23c71b6afae16da4db1863bf68d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a33a1c23c71b6afae16da4db1863bf68d">&#9670;&nbsp;</a></span>updateBelief() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename M , std::enable_if_t&lt; is_model_v&lt; M &gt;, int &gt;  = 0&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void AIToolbox::POMDP::updateBelief </td>
          <td>(</td>
          <td class="paramtype">const M &amp;&#160;</td>
          <td class="paramname"><em>model</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceAIToolbox_1_1POMDP.html#a4522c5e35483fb30b2c43c271781e8bc">Belief</a> &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>o</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceAIToolbox_1_1POMDP.html#a4522c5e35483fb30b2c43c271781e8bc">Belief</a> *&#160;</td>
          <td class="paramname"><em>bRet</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a new belief reflecting changes after an action and observation for a particular <a class="el" href="classAIToolbox_1_1POMDP_1_1Model.html" title="This class represents a Partially Observable Markov Decision Process.">Model</a>. </p>
<p>This function writes directly into the provided Belief pointer. It assumes that the pointer points to a correctly sized Belief. It does a basic nullptr check.</p>
<p>NOTE: This function assumes that the update and the normalization are possible, i.e. that from the input belief and action it is possible to receive the input observation.</p>
<p>If that cannot be guaranteed, use the <a class="el" href="namespaceAIToolbox_1_1POMDP.html#a6a6deb0f6f3d12bb59f0b9813604abc2" title="Creates a new belief reflecting changes after an action and observation for a particular Model.">updateBeliefUnnormalized()</a> function and do the normalization yourself (and check for it).</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">M</td><td>The type of the <a class="el" href="namespaceAIToolbox_1_1POMDP.html">POMDP</a> <a class="el" href="classAIToolbox_1_1POMDP_1_1Model.html" title="This class represents a Partially Observable Markov Decision Process.">Model</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">model</td><td>The model used to update the belief. </td></tr>
    <tr><td class="paramname">b</td><td>The old belief. </td></tr>
    <tr><td class="paramname">a</td><td>The action taken during the transition. </td></tr>
    <tr><td class="paramname">o</td><td>The observation registered. </td></tr>
    <tr><td class="paramname">bRet</td><td>The output belief. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af9903a18de2b0961d2f9a58f18bed9e5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af9903a18de2b0961d2f9a58f18bed9e5">&#9670;&nbsp;</a></span>updateBeliefPartial() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename M , std::enable_if_t&lt; is_model_v&lt; M &gt;, int &gt;  = 0&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceAIToolbox_1_1POMDP.html#a4522c5e35483fb30b2c43c271781e8bc">Belief</a> AIToolbox::POMDP::updateBeliefPartial </td>
          <td>(</td>
          <td class="paramtype">const M &amp;&#160;</td>
          <td class="paramname"><em>model</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceAIToolbox_1_1POMDP.html#a4522c5e35483fb30b2c43c271781e8bc">Belief</a> &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>a</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function partially updates a belief. </p>
<p>This function is useful in case one needs to update a belief for all possible observations. In such a case, it is possible to avoid repeating the same operations by creating an intermediate belief, that only depends on the action and not on the observation.</p>
<p>From this intermediate result it will be then possible to obtain the end belief by supplying the same action and the desired observation.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">M</td><td>The type of the <a class="el" href="namespaceAIToolbox_1_1POMDP.html">POMDP</a> <a class="el" href="classAIToolbox_1_1POMDP_1_1Model.html" title="This class represents a Partially Observable Markov Decision Process.">Model</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">model</td><td>The model used to update the belief. </td></tr>
    <tr><td class="paramname">b</td><td>The old belief. </td></tr>
    <tr><td class="paramname">a</td><td>The action taken during the transition. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a413832fe24061c45091f0a24e7a7eee2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a413832fe24061c45091f0a24e7a7eee2">&#9670;&nbsp;</a></span>updateBeliefPartial() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename M , std::enable_if_t&lt; is_model_v&lt; M &gt;, int &gt;  = 0&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void AIToolbox::POMDP::updateBeliefPartial </td>
          <td>(</td>
          <td class="paramtype">const M &amp;&#160;</td>
          <td class="paramname"><em>model</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceAIToolbox_1_1POMDP.html#a4522c5e35483fb30b2c43c271781e8bc">Belief</a> &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceAIToolbox_1_1POMDP.html#a4522c5e35483fb30b2c43c271781e8bc">Belief</a> *&#160;</td>
          <td class="paramname"><em>bRet</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function partially updates a belief. </p>
<p>This function is useful in case one needs to update a belief for all possible observations. In such a case, it is possible to avoid repeating the same operations by creating an intermediate belief, that only depends on the action and not on the observation.</p>
<p>From this intermediate result it will be then possible to obtain the end belief by supplying the same action and the desired observation.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">M</td><td>The type of the <a class="el" href="namespaceAIToolbox_1_1POMDP.html">POMDP</a> <a class="el" href="classAIToolbox_1_1POMDP_1_1Model.html" title="This class represents a Partially Observable Markov Decision Process.">Model</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">model</td><td>The model used to update the belief. </td></tr>
    <tr><td class="paramname">b</td><td>The old belief. </td></tr>
    <tr><td class="paramname">a</td><td>The action taken during the transition. </td></tr>
    <tr><td class="paramname">bRet</td><td>The output belief. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a0fe1545a75c1d70a6fd97cb876bff9e2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0fe1545a75c1d70a6fd97cb876bff9e2">&#9670;&nbsp;</a></span>updateBeliefPartialNormalized() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename M , std::enable_if_t&lt; is_model_v&lt; M &gt;, int &gt;  = 0&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceAIToolbox_1_1POMDP.html#a4522c5e35483fb30b2c43c271781e8bc">Belief</a> AIToolbox::POMDP::updateBeliefPartialNormalized </td>
          <td>(</td>
          <td class="paramtype">const M &amp;&#160;</td>
          <td class="paramname"><em>model</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceAIToolbox_1_1POMDP.html#a4522c5e35483fb30b2c43c271781e8bc">Belief</a> &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>o</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function terminates the normalized update of a partially updated belief. </p>
<p>This function is useful in case one needs to update a belief for all possible observations. In such a case, it is possible to avoid repeating the same operations by creating an intermediate belief, that only depends on the action and not on the observation.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="namespaceAIToolbox_1_1POMDP.html#a413832fe24061c45091f0a24e7a7eee2" title="This function partially updates a belief.">updateBeliefPartial</a></dd></dl>
<p>Note that the input action here must be the same one that produced the intermediate result.</p>
<p>NOTE: This function assumes that the update and the normalization are possible, i.e. that from the input belief and action it is possible to receive the input observation.</p>
<p>If that cannot be guaranteed, use the <a class="el" href="namespaceAIToolbox_1_1POMDP.html#a6a6deb0f6f3d12bb59f0b9813604abc2" title="Creates a new belief reflecting changes after an action and observation for a particular Model.">updateBeliefUnnormalized()</a> function and do the normalization yourself (and check for it).</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">M</td><td>The type of the <a class="el" href="namespaceAIToolbox_1_1POMDP.html">POMDP</a> <a class="el" href="classAIToolbox_1_1POMDP_1_1Model.html" title="This class represents a Partially Observable Markov Decision Process.">Model</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">model</td><td>The model used to update the belief. </td></tr>
    <tr><td class="paramname">b</td><td>The intermediate belief. </td></tr>
    <tr><td class="paramname">a</td><td>The action taken during the transition. </td></tr>
    <tr><td class="paramname">o</td><td>The observation registered. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a3be3dce28e8d80fe6457ebbe0b5da9cb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3be3dce28e8d80fe6457ebbe0b5da9cb">&#9670;&nbsp;</a></span>updateBeliefPartialNormalized() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename M , std::enable_if_t&lt; is_model_v&lt; M &gt;, int &gt;  = 0&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void AIToolbox::POMDP::updateBeliefPartialNormalized </td>
          <td>(</td>
          <td class="paramtype">const M &amp;&#160;</td>
          <td class="paramname"><em>model</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceAIToolbox_1_1POMDP.html#a4522c5e35483fb30b2c43c271781e8bc">Belief</a> &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>o</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceAIToolbox_1_1POMDP.html#a4522c5e35483fb30b2c43c271781e8bc">Belief</a> *&#160;</td>
          <td class="paramname"><em>bRet</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function terminates the normalized update of a partially updated belief. </p>
<p>This function is useful in case one needs to update a belief for all possible observations. In such a case, it is possible to avoid repeating the same operations by creating an intermediate belief, that only depends on the action and not on the observation.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="namespaceAIToolbox_1_1POMDP.html#a413832fe24061c45091f0a24e7a7eee2" title="This function partially updates a belief.">updateBeliefPartial</a></dd></dl>
<p>Note that the input action here must be the same one that produced the intermediate result.</p>
<p>NOTE: This function assumes that the update and the normalization are possible, i.e. that from the input belief and action it is possible to receive the input observation.</p>
<p>If that cannot be guaranteed, use the <a class="el" href="namespaceAIToolbox_1_1POMDP.html#a6a6deb0f6f3d12bb59f0b9813604abc2" title="Creates a new belief reflecting changes after an action and observation for a particular Model.">updateBeliefUnnormalized()</a> function and do the normalization yourself (and check for it).</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">M</td><td>The type of the <a class="el" href="namespaceAIToolbox_1_1POMDP.html">POMDP</a> <a class="el" href="classAIToolbox_1_1POMDP_1_1Model.html" title="This class represents a Partially Observable Markov Decision Process.">Model</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">model</td><td>The model used to update the belief. </td></tr>
    <tr><td class="paramname">b</td><td>The intermediate belief. </td></tr>
    <tr><td class="paramname">a</td><td>The action taken during the transition. </td></tr>
    <tr><td class="paramname">o</td><td>The observation registered. </td></tr>
    <tr><td class="paramname">bRet</td><td>The output belief. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad03a82580eea9bba77d72052b181168a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad03a82580eea9bba77d72052b181168a">&#9670;&nbsp;</a></span>updateBeliefPartialUnnormalized() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename M , std::enable_if_t&lt; is_model_v&lt; M &gt;, int &gt;  = 0&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceAIToolbox_1_1POMDP.html#a4522c5e35483fb30b2c43c271781e8bc">Belief</a> AIToolbox::POMDP::updateBeliefPartialUnnormalized </td>
          <td>(</td>
          <td class="paramtype">const M &amp;&#160;</td>
          <td class="paramname"><em>model</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceAIToolbox_1_1POMDP.html#a4522c5e35483fb30b2c43c271781e8bc">Belief</a> &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>o</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function terminates the unnormalized update of a partially updated belief. </p>
<p>This function is useful in case one needs to update a belief for all possible observations. In such a case, it is possible to avoid repeating the same operations by creating an intermediate belief, that only depends on the action and not on the observation.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="namespaceAIToolbox_1_1POMDP.html#a413832fe24061c45091f0a24e7a7eee2" title="This function partially updates a belief.">updateBeliefPartial</a></dd></dl>
<p>Note that the input action here must be the same one that produced the intermediate result.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">M</td><td>The type of the <a class="el" href="namespaceAIToolbox_1_1POMDP.html">POMDP</a> <a class="el" href="classAIToolbox_1_1POMDP_1_1Model.html" title="This class represents a Partially Observable Markov Decision Process.">Model</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">model</td><td>The model used to update the belief. </td></tr>
    <tr><td class="paramname">b</td><td>The intermediate belief. </td></tr>
    <tr><td class="paramname">a</td><td>The action taken during the transition. </td></tr>
    <tr><td class="paramname">o</td><td>The observation registered. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a0f00347484bfd228db82d264a889d649"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0f00347484bfd228db82d264a889d649">&#9670;&nbsp;</a></span>updateBeliefPartialUnnormalized() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename M , std::enable_if_t&lt; is_model_v&lt; M &gt;, int &gt;  = 0&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void AIToolbox::POMDP::updateBeliefPartialUnnormalized </td>
          <td>(</td>
          <td class="paramtype">const M &amp;&#160;</td>
          <td class="paramname"><em>model</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceAIToolbox_1_1POMDP.html#a4522c5e35483fb30b2c43c271781e8bc">Belief</a> &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>o</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceAIToolbox_1_1POMDP.html#a4522c5e35483fb30b2c43c271781e8bc">Belief</a> *&#160;</td>
          <td class="paramname"><em>bRet</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function terminates the unnormalized update of a partially updated belief. </p>
<p>This function is useful in case one needs to update a belief for all possible observations. In such a case, it is possible to avoid repeating the same operations by creating an intermediate belief, that only depends on the action and not on the observation.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="namespaceAIToolbox_1_1POMDP.html#a413832fe24061c45091f0a24e7a7eee2" title="This function partially updates a belief.">updateBeliefPartial</a></dd></dl>
<p>Note that the input action here must be the same one that produced the intermediate result.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">M</td><td>The type of the <a class="el" href="namespaceAIToolbox_1_1POMDP.html">POMDP</a> <a class="el" href="classAIToolbox_1_1POMDP_1_1Model.html" title="This class represents a Partially Observable Markov Decision Process.">Model</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">model</td><td>The model used to update the belief. </td></tr>
    <tr><td class="paramname">b</td><td>The intermediate belief. </td></tr>
    <tr><td class="paramname">a</td><td>The action taken during the transition. </td></tr>
    <tr><td class="paramname">o</td><td>The observation registered. </td></tr>
    <tr><td class="paramname">bRet</td><td>The output belief. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aeadb8ad292520175aea2ad4b9173c5cd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeadb8ad292520175aea2ad4b9173c5cd">&#9670;&nbsp;</a></span>updateBeliefUnnormalized() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename M , std::enable_if_t&lt; is_model_v&lt; M &gt;, int &gt;  = 0&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceAIToolbox_1_1POMDP.html#a4522c5e35483fb30b2c43c271781e8bc">Belief</a> AIToolbox::POMDP::updateBeliefUnnormalized </td>
          <td>(</td>
          <td class="paramtype">const M &amp;&#160;</td>
          <td class="paramname"><em>model</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceAIToolbox_1_1POMDP.html#a4522c5e35483fb30b2c43c271781e8bc">Belief</a> &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>o</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a new belief reflecting changes after an action and observation for a particular <a class="el" href="classAIToolbox_1_1POMDP_1_1Model.html" title="This class represents a Partially Observable Markov Decision Process.">Model</a>. </p>
<p>This function needs to create a new belief since modifying a belief in place is not possible. This is because each cell update for the new belief requires all values from the previous belief.</p>
<p>This function will not normalize the output, nor is guaranteed to return a non-completely-zero vector.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">M</td><td>The type of the <a class="el" href="namespaceAIToolbox_1_1POMDP.html">POMDP</a> <a class="el" href="classAIToolbox_1_1POMDP_1_1Model.html" title="This class represents a Partially Observable Markov Decision Process.">Model</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">model</td><td>The model used to update the belief. </td></tr>
    <tr><td class="paramname">b</td><td>The old belief. </td></tr>
    <tr><td class="paramname">a</td><td>The action taken during the transition. </td></tr>
    <tr><td class="paramname">o</td><td>The observation registered. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a6a6deb0f6f3d12bb59f0b9813604abc2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6a6deb0f6f3d12bb59f0b9813604abc2">&#9670;&nbsp;</a></span>updateBeliefUnnormalized() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename M , std::enable_if_t&lt; is_model_v&lt; M &gt;, int &gt;  = 0&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void AIToolbox::POMDP::updateBeliefUnnormalized </td>
          <td>(</td>
          <td class="paramtype">const M &amp;&#160;</td>
          <td class="paramname"><em>model</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceAIToolbox_1_1POMDP.html#a4522c5e35483fb30b2c43c271781e8bc">Belief</a> &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>o</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceAIToolbox_1_1POMDP.html#a4522c5e35483fb30b2c43c271781e8bc">Belief</a> *&#160;</td>
          <td class="paramname"><em>bRet</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a new belief reflecting changes after an action and observation for a particular <a class="el" href="classAIToolbox_1_1POMDP_1_1Model.html" title="This class represents a Partially Observable Markov Decision Process.">Model</a>. </p>
<p>This function writes directly into the provided Belief pointer. It assumes that the pointer points to a correctly sized Belief. It does a basic nullptr check.</p>
<p>This function will not normalize the output, nor is guaranteed to return a non-completely-zero vector.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">M</td><td>The type of the <a class="el" href="namespaceAIToolbox_1_1POMDP.html">POMDP</a> <a class="el" href="classAIToolbox_1_1POMDP_1_1Model.html" title="This class represents a Partially Observable Markov Decision Process.">Model</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">model</td><td>The model used to update the belief. </td></tr>
    <tr><td class="paramname">b</td><td>The old belief. </td></tr>
    <tr><td class="paramname">a</td><td>The action taken during the transition. </td></tr>
    <tr><td class="paramname">o</td><td>The observation registered. </td></tr>
    <tr><td class="paramname">bRet</td><td>The output belief. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a05e4fb4a18324709e70b42d66cf2054b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a05e4fb4a18324709e70b42d66cf2054b">&#9670;&nbsp;</a></span>weakBoundDistance()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double AIToolbox::POMDP::weakBoundDistance </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceAIToolbox_1_1POMDP.html#a5655ffd334a1e53622314eae70eab464">VList</a> &amp;&#160;</td>
          <td class="paramname"><em>oldV</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceAIToolbox_1_1POMDP.html#a5655ffd334a1e53622314eae70eab464">VList</a> &amp;&#160;</td>
          <td class="paramname"><em>newV</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function returns a weak measure of distance between two VLists. </p>
<p>The logic of the weak bound is the following: the variation between the old VList and the new one is equal to the maximum distance between a ValueFunction in the old VList with its closest match in the new VList. So the farthest from closest.</p>
<p>We define distance between two ValueFunctions as the maximum between their element-wise difference.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">oldV</td><td>The fist VList to compare. </td></tr>
    <tr><td class="paramname">newV</td><td>The second VList to compare.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The weak bound distance between the two arguments. </dd></dl>

</div>
</div>
<h2 class="groupheader">Variable Documentation</h2>
<a id="a14f2ade0c0d30091b74297fce650ddbf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a14f2ade0c0d30091b74297fce650ddbf">&#9670;&nbsp;</a></span>is_generative_model_v</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename M &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool AIToolbox::POMDP::is_generative_model_v = <a class="el" href="structAIToolbox_1_1POMDP_1_1is__generative__model.html">is_generative_model</a>&lt;M&gt;::value</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a0a7899814376313aa6ee8dadecea379d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0a7899814376313aa6ee8dadecea379d">&#9670;&nbsp;</a></span>is_model_eigen_v</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename M &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool AIToolbox::POMDP::is_model_eigen_v = <a class="el" href="structAIToolbox_1_1POMDP_1_1is__model__eigen.html">is_model_eigen</a>&lt;M&gt;::value</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="abbf63587b8e90849d2501933a827061a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abbf63587b8e90849d2501933a827061a">&#9670;&nbsp;</a></span>is_model_not_eigen_v</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename M &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool AIToolbox::POMDP::is_model_not_eigen_v = <a class="el" href="structAIToolbox_1_1POMDP_1_1is__model__not__eigen.html">is_model_not_eigen</a>&lt;M&gt;::value</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a7c3d5eb7dc047b0b55379914b76fd132"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7c3d5eb7dc047b0b55379914b76fd132">&#9670;&nbsp;</a></span>is_model_v</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename M &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool AIToolbox::POMDP::is_model_v = <a class="el" href="structAIToolbox_1_1POMDP_1_1is__model.html">is_model</a>&lt;M&gt;::value</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a30d62c33ae0e760503f3712b498b3e47"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a30d62c33ae0e760503f3712b498b3e47">&#9670;&nbsp;</a></span>is_witness_lp_v</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename LP &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool AIToolbox::POMDP::is_witness_lp_v = <a class="el" href="structAIToolbox_1_1POMDP_1_1is__witness__lp.html">is_witness_lp</a>&lt;<a class="el" href="classAIToolbox_1_1LP.html">LP</a>&gt;::value</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- HTML footer for doxygen 1.8.17-->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
</div>
</body>
</html>
