<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>AIToolbox: AIToolbox::POMDP Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">AIToolbox
   </div>
   <div id="projectbrief">A library that offers tools for AI problem solving.</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespaceAIToolbox.html">AIToolbox</a></li><li class="navelem"><a class="el" href="namespaceAIToolbox_1_1POMDP.html">POMDP</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle">
<div class="title">AIToolbox::POMDP Namespace Reference</div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structAIToolbox_1_1POMDP_1_1ActionNode.html">ActionNode</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAIToolbox_1_1POMDP_1_1AMDP.html">AMDP</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class implements the Augmented <a class="el" href="namespaceAIToolbox_1_1MDP.html">MDP</a> algorithm.  <a href="classAIToolbox_1_1POMDP_1_1AMDP.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAIToolbox_1_1POMDP_1_1BeliefGenerator.html">BeliefGenerator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class generates reachable beliefs from a given <a class="el" href="classAIToolbox_1_1POMDP_1_1Model.html" title="This class represents a Partially Observable Markov Decision Process. ">Model</a>.  <a href="classAIToolbox_1_1POMDP_1_1BeliefGenerator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAIToolbox_1_1POMDP_1_1BeliefNode.html">BeliefNode</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is a belief node of the <a class="el" href="classAIToolbox_1_1POMDP_1_1rPOMCP.html" title="This class represents the rPOMCP online planner. ">rPOMCP</a> tree.  <a href="classAIToolbox_1_1POMDP_1_1BeliefNode.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structAIToolbox_1_1POMDP_1_1BeliefParticle.html">BeliefParticle</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAIToolbox_1_1POMDP_1_1BlindStrategies.html">BlindStrategies</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class implements the blind strategies lower bound.  <a href="classAIToolbox_1_1POMDP_1_1BlindStrategies.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAIToolbox_1_1POMDP_1_1FastInformedBound.html">FastInformedBound</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class implements the Fast Informed Bound algorithm.  <a href="classAIToolbox_1_1POMDP_1_1FastInformedBound.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAIToolbox_1_1POMDP_1_1GapMin.html">GapMin</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class implements the <a class="el" href="classAIToolbox_1_1POMDP_1_1GapMin.html" title="This class implements the GapMin algorithm. ">GapMin</a> algorithm.  <a href="classAIToolbox_1_1POMDP_1_1GapMin.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAIToolbox_1_1POMDP_1_1HeadBeliefNode.html">HeadBeliefNode</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class is the root node of the <a class="el" href="classAIToolbox_1_1POMDP_1_1rPOMCP.html" title="This class represents the rPOMCP online planner. ">rPOMCP</a> graph.  <a href="classAIToolbox_1_1POMDP_1_1HeadBeliefNode.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAIToolbox_1_1POMDP_1_1IncrementalPruning.html">IncrementalPruning</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class implements the Incremental Pruning algorithm.  <a href="classAIToolbox_1_1POMDP_1_1IncrementalPruning.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structAIToolbox_1_1POMDP_1_1is__generative__model.html">is_generative_model</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This struct represents the required interface for a generative <a class="el" href="namespaceAIToolbox_1_1MDP.html">MDP</a>.  <a href="structAIToolbox_1_1POMDP_1_1is__generative__model.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structAIToolbox_1_1POMDP_1_1is__model.html">is_model</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This struct represents the required interface for a <a class="el" href="namespaceAIToolbox_1_1POMDP.html">POMDP</a> <a class="el" href="classAIToolbox_1_1POMDP_1_1Model.html" title="This class represents a Partially Observable Markov Decision Process. ">Model</a>.  <a href="structAIToolbox_1_1POMDP_1_1is__model.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structAIToolbox_1_1POMDP_1_1is__model__eigen.html">is_model_eigen</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This struct represents the required interface that allows <a class="el" href="namespaceAIToolbox_1_1POMDP.html">POMDP</a> algorithms to leverage <a class="el" href="namespaceEigen.html">Eigen</a>.  <a href="structAIToolbox_1_1POMDP_1_1is__model__eigen.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structAIToolbox_1_1POMDP_1_1is__model__not__eigen.html">is_model_not_eigen</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This struct verifies that a class satisfies the <a class="el" href="structAIToolbox_1_1POMDP_1_1is__model.html" title="This struct represents the required interface for a POMDP Model. ">is_model</a> interface but not the <a class="el" href="structAIToolbox_1_1POMDP_1_1is__model__eigen.html" title="This struct represents the required interface that allows POMDP algorithms to leverage Eigen...">is_model_eigen</a> interface.  <a href="structAIToolbox_1_1POMDP_1_1is__model__not__eigen.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structAIToolbox_1_1POMDP_1_1is__witness__lp.html">is_witness_lp</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This check the interface for a <a class="el" href="classAIToolbox_1_1WitnessLP.html" title="This class implements an easy interface to do Witness discovery through linear programming. ">WitnessLP</a>.  <a href="structAIToolbox_1_1POMDP_1_1is__witness__lp.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAIToolbox_1_1POMDP_1_1LinearSupport.html">LinearSupport</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class represents the <a class="el" href="classAIToolbox_1_1POMDP_1_1LinearSupport.html" title="This class represents the LinearSupport algorithm. ">LinearSupport</a> algorithm.  <a href="classAIToolbox_1_1POMDP_1_1LinearSupport.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAIToolbox_1_1POMDP_1_1Model.html">Model</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class represents a Partially Observable Markov Decision Process.  <a href="classAIToolbox_1_1POMDP_1_1Model.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAIToolbox_1_1POMDP_1_1PBVI.html">PBVI</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class implements the Point Based Value Iteration algorithm.  <a href="classAIToolbox_1_1POMDP_1_1PBVI.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAIToolbox_1_1POMDP_1_1PERSEUS.html">PERSEUS</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class implements the <a class="el" href="classAIToolbox_1_1POMDP_1_1PERSEUS.html" title="This class implements the PERSEUS algorithm. ">PERSEUS</a> algorithm.  <a href="classAIToolbox_1_1POMDP_1_1PERSEUS.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAIToolbox_1_1POMDP_1_1Policy.html">Policy</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class represents a <a class="el" href="namespaceAIToolbox_1_1POMDP.html">POMDP</a> <a class="el" href="classAIToolbox_1_1POMDP_1_1Policy.html" title="This class represents a POMDP Policy. ">Policy</a>.  <a href="classAIToolbox_1_1POMDP_1_1Policy.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAIToolbox_1_1POMDP_1_1POMCP.html">POMCP</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class represents the <a class="el" href="classAIToolbox_1_1POMDP_1_1POMCP.html" title="This class represents the POMCP online planner using UCB1. ">POMCP</a> online planner using UCB1.  <a href="classAIToolbox_1_1POMDP_1_1POMCP.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAIToolbox_1_1POMDP_1_1Projecter.html">Projecter</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class offers projecting facilities for Models.  <a href="classAIToolbox_1_1POMDP_1_1Projecter.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAIToolbox_1_1POMDP_1_1QMDP.html">QMDP</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class implements the <a class="el" href="classAIToolbox_1_1POMDP_1_1QMDP.html" title="This class implements the QMDP algorithm. ">QMDP</a> algorithm.  <a href="classAIToolbox_1_1POMDP_1_1QMDP.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAIToolbox_1_1POMDP_1_1rPOMCP.html">rPOMCP</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class represents the <a class="el" href="classAIToolbox_1_1POMDP_1_1rPOMCP.html" title="This class represents the rPOMCP online planner. ">rPOMCP</a> online planner.  <a href="classAIToolbox_1_1POMDP_1_1rPOMCP.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAIToolbox_1_1POMDP_1_1RTBSS.html">RTBSS</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class represents the <a class="el" href="classAIToolbox_1_1POMDP_1_1RTBSS.html" title="This class represents the RTBSS online planner. ">RTBSS</a> online planner.  <a href="classAIToolbox_1_1POMDP_1_1RTBSS.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAIToolbox_1_1POMDP_1_1SparseModel.html">SparseModel</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class represents a Partially Observable Markov Decision Process.  <a href="classAIToolbox_1_1POMDP_1_1SparseModel.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structAIToolbox_1_1POMDP_1_1VEntry.html">VEntry</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAIToolbox_1_1POMDP_1_1Witness.html">Witness</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class implements the <a class="el" href="classAIToolbox_1_1POMDP_1_1Witness.html" title="This class implements the Witness algorithm. ">Witness</a> algorithm.  <a href="classAIToolbox_1_1POMDP_1_1Witness.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:a97f123407d50846293c4e9b46d7fbd49"><td class="memTemplParams" colspan="2">template&lt;bool UseEntropy&gt; </td></tr>
<tr class="memitem:a97f123407d50846293c4e9b46d7fbd49"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceAIToolbox_1_1POMDP.html#a97f123407d50846293c4e9b46d7fbd49">ActionNodes</a> = std::vector&lt; <a class="el" href="structAIToolbox_1_1POMDP_1_1ActionNode.html">ActionNode</a>&lt; UseEntropy &gt; &gt;</td></tr>
<tr class="separator:a97f123407d50846293c4e9b46d7fbd49"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad867f06ad8946aa1b205a7f5f8fcb42e"><td class="memTemplParams" colspan="2">template&lt;bool UseEntropy&gt; </td></tr>
<tr class="memitem:ad867f06ad8946aa1b205a7f5f8fcb42e"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceAIToolbox_1_1POMDP.html#ad867f06ad8946aa1b205a7f5f8fcb42e">TrackBelief</a> = std::unordered_map&lt; size_t, <a class="el" href="structAIToolbox_1_1POMDP_1_1BeliefParticle.html">BeliefParticle</a>&lt; UseEntropy &gt;, std::hash&lt; size_t &gt;, std::equal_to&lt; size_t &gt; &gt;</td></tr>
<tr class="separator:ad867f06ad8946aa1b205a7f5f8fcb42e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afba9c8e6204b8f6b341362af3991da75"><td class="memTemplParams" colspan="2">template&lt;bool UseEntropy&gt; </td></tr>
<tr class="memitem:afba9c8e6204b8f6b341362af3991da75"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceAIToolbox_1_1POMDP.html#afba9c8e6204b8f6b341362af3991da75">BeliefNodes</a> = std::unordered_map&lt; size_t, <a class="el" href="classAIToolbox_1_1POMDP_1_1BeliefNode.html">BeliefNode</a>&lt; UseEntropy &gt; &gt;</td></tr>
<tr class="separator:afba9c8e6204b8f6b341362af3991da75"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a79664c416e1fbfe5d89acb9f94f35bee"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceAIToolbox_1_1POMDP.html#a79664c416e1fbfe5d89acb9f94f35bee">SampleBelief</a> = std::vector&lt; std::pair&lt; size_t, unsigned &gt; &gt;</td></tr>
<tr class="separator:a79664c416e1fbfe5d89acb9f94f35bee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4522c5e35483fb30b2c43c271781e8bc"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceAIToolbox_1_1POMDP.html#a4522c5e35483fb30b2c43c271781e8bc">Belief</a> = <a class="el" href="namespaceAIToolbox.html#af4149b71e91dee03ad9d0c8c207eddf0">ProbabilityVector</a></td></tr>
<tr class="memdesc:a4522c5e35483fb30b2c43c271781e8bc"><td class="mdescLeft">&#160;</td><td class="mdescRight">This represents a belief, which is a probability distribution over states.  <a href="#a4522c5e35483fb30b2c43c271781e8bc">More...</a><br /></td></tr>
<tr class="separator:a4522c5e35483fb30b2c43c271781e8bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">POMDP Value Types</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p><a class="el" href="namespaceAIToolbox_1_1POMDP.html">POMDP</a> ValueFunctions are complicated. In fact, they are trees. At each belief, you have a particular value function, which also depends on any future observation you might encounter, and must change "value" accordingly. For example, a high valued belief might in the end turn out bad due to repeated "bad" observations. At the same time, for each particular block of values, we want to save the single action that will result in the "actuation" of that particular value.</p>
<p>We avoid storing a <a class="el" href="namespaceAIToolbox_1_1POMDP.html">POMDP</a> ValueFunction as a true tree, mostly due to the fact that most operations like search and update are done on a timestep basis, as in, specific tree depth. Thus the layout is arranged as follows:</p>
<p>A <a class="el" href="structAIToolbox_1_1POMDP_1_1VEntry.html">VEntry</a> contains:</p>
<ul>
<li>The <a class="el" href="namespaceAIToolbox_1_1MDP.html#ae6bfccca3b00146c82eb345ca8490b74">MDP::Values</a> for its specific Belief range. This is also called an alphavector in the literature. At any belief it can be used to compute, via dot product, the true value of that belief.</li>
<li>An action index, for the action that results in the actuation of those particular values.</li>
<li>A vector containing, for each possible observation, the index of the <a class="el" href="structAIToolbox_1_1POMDP_1_1VEntry.html">VEntry</a> to look into for the next timestep/VList. Thus, there are going to be |O| entries in this vector (sometimes it's empty, when it doesn't matter). Some observations are however impossible from certain beliefs. In theory, those vector entries should never be accessed, so they will just keep the value of zero to keep things simple.</li>
</ul>
<p>A VList is a slice of the final tree with respect to depth, as in all ValueFunctions for a certain timestep t. Note that a VList can have an arbitrary number of VEntries inside - with an upper bound. Each VList can have at most A * size(VList_{t-1})^O.</p>
<p>A ValueFunction is the final tree keeping all VLists together. A ValueFunction has always at least one element.</p>
<p>The first element of a ValueFunction is technically useless, as it is a VList with just one <a class="el" href="structAIToolbox_1_1POMDP_1_1VEntry.html">VEntry</a> that tells to perform action zero. It's the default from which all Dynamic Programming algorithm start. The values of the default entry are usually zeros, although some algorithms initialize them differently. The first entry otherwise is never used, not even for sampling for a policy, and it's simply an artifact that takes little space to keep, and it's expected in all the code.</p>
<p>QFunctions may be defined later, however since <a class="el" href="namespaceAIToolbox_1_1POMDP.html">POMDP</a> ValueFunctions are already pretty costly in terms of space, in general there's little sense in storing them. </p>
</div></td></tr>
<tr class="memitem:a72aee7b57445d6b773012d9b54b85339"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceAIToolbox_1_1POMDP.html#a72aee7b57445d6b773012d9b54b85339">VObs</a> = std::vector&lt; size_t &gt;</td></tr>
<tr class="separator:a72aee7b57445d6b773012d9b54b85339"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5655ffd334a1e53622314eae70eab464"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceAIToolbox_1_1POMDP.html#a5655ffd334a1e53622314eae70eab464">VList</a> = std::vector&lt; <a class="el" href="structAIToolbox_1_1POMDP_1_1VEntry.html">VEntry</a> &gt;</td></tr>
<tr class="separator:a5655ffd334a1e53622314eae70eab464"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab1cada9fef241e48a9d14d36cb61dabb"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceAIToolbox_1_1POMDP.html#ab1cada9fef241e48a9d14d36cb61dabb">ValueFunction</a> = std::vector&lt; <a class="el" href="namespaceAIToolbox_1_1POMDP.html#a5655ffd334a1e53622314eae70eab464">VList</a> &gt;</td></tr>
<tr class="separator:ab1cada9fef241e48a9d14d36cb61dabb"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a5fe691ce2374490bf25dcb583d7c2baf"><td class="memTemplParams" colspan="2">template&lt;typename M , typename  = std::enable_if_t&lt;is_model_v&lt;M&gt;&gt;&gt; </td></tr>
<tr class="memitem:a5fe691ce2374490bf25dcb583d7c2baf"><td class="memTemplItemLeft" align="right" valign="top">std::tuple&lt; size_t, double &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceAIToolbox_1_1POMDP.html#a5fe691ce2374490bf25dcb583d7c2baf">bestConservativeAction</a> (const M &amp;pomdp, const <a class="el" href="namespaceAIToolbox_1_1POMDP.html#a4522c5e35483fb30b2c43c271781e8bc">Belief</a> &amp;initialBelief, const <a class="el" href="namespaceAIToolbox_1_1POMDP.html#a5655ffd334a1e53622314eae70eab464">VList</a> &amp;lbVList)</td></tr>
<tr class="memdesc:a5fe691ce2374490bf25dcb583d7c2baf"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function obtains the best action with respect to the input VList.  <a href="#a5fe691ce2374490bf25dcb583d7c2baf">More...</a><br /></td></tr>
<tr class="separator:a5fe691ce2374490bf25dcb583d7c2baf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a184e91a2441d41ffc7c249c587bf415c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classAIToolbox_1_1POMDP_1_1Model.html">Model</a>&lt; <a class="el" href="classAIToolbox_1_1MDP_1_1Model.html">MDP::Model</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceAIToolbox_1_1POMDP.html#a184e91a2441d41ffc7c249c587bf415c">parseCassandra</a> (std::istream &amp;input)</td></tr>
<tr class="memdesc:a184e91a2441d41ffc7c249c587bf415c"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function parses a <a class="el" href="namespaceAIToolbox_1_1POMDP.html">POMDP</a> from a Cassandra formatted stream.  <a href="#a184e91a2441d41ffc7c249c587bf415c">More...</a><br /></td></tr>
<tr class="separator:a184e91a2441d41ffc7c249c587bf415c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af460a8a2b997c9c93e620e9f805fcaf3"><td class="memTemplParams" colspan="2">template&lt;typename M , std::enable_if_t&lt; is_model_v&lt; M &gt;, int &gt;  = 0&gt; </td></tr>
<tr class="memitem:af460a8a2b997c9c93e620e9f805fcaf3"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceAIToolbox_1_1POMDP.html#af460a8a2b997c9c93e620e9f805fcaf3">operator&lt;&lt;</a> (std::ostream &amp;os, const M &amp;model)</td></tr>
<tr class="memdesc:af460a8a2b997c9c93e620e9f805fcaf3"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function prints any <a class="el" href="namespaceAIToolbox_1_1POMDP.html">POMDP</a> model to a file.  <a href="#af460a8a2b997c9c93e620e9f805fcaf3">More...</a><br /></td></tr>
<tr class="separator:af460a8a2b997c9c93e620e9f805fcaf3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3e6938312f6dd9d20f1f3767bb361a76"><td class="memTemplParams" colspan="2">template&lt;typename M , typename &gt; </td></tr>
<tr class="memitem:a3e6938312f6dd9d20f1f3767bb361a76"><td class="memTemplItemLeft" align="right" valign="top">std::istream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceAIToolbox_1_1POMDP.html#a3e6938312f6dd9d20f1f3767bb361a76">operator&gt;&gt;</a> (std::istream &amp;is, <a class="el" href="classAIToolbox_1_1POMDP_1_1Model.html">Model</a>&lt; M &gt; &amp;m)</td></tr>
<tr class="memdesc:a3e6938312f6dd9d20f1f3767bb361a76"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function implements input from stream for the <a class="el" href="classAIToolbox_1_1POMDP_1_1Model.html" title="This class represents a Partially Observable Markov Decision Process. ">POMDP::Model</a> class.  <a href="#a3e6938312f6dd9d20f1f3767bb361a76">More...</a><br /></td></tr>
<tr class="separator:a3e6938312f6dd9d20f1f3767bb361a76"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a55c4ff8e7537e5d77f5edd0038705393"><td class="memTemplParams" colspan="2">template&lt;typename M , typename &gt; </td></tr>
<tr class="memitem:a55c4ff8e7537e5d77f5edd0038705393"><td class="memTemplItemLeft" align="right" valign="top">std::istream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceAIToolbox_1_1POMDP.html#a55c4ff8e7537e5d77f5edd0038705393">operator&gt;&gt;</a> (std::istream &amp;is, <a class="el" href="classAIToolbox_1_1POMDP_1_1SparseModel.html">SparseModel</a>&lt; M &gt; &amp;m)</td></tr>
<tr class="memdesc:a55c4ff8e7537e5d77f5edd0038705393"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function implements input from stream for the <a class="el" href="classAIToolbox_1_1POMDP_1_1SparseModel.html" title="This class represents a Partially Observable Markov Decision Process. ">POMDP::SparseModel</a> class.  <a href="#a55c4ff8e7537e5d77f5edd0038705393">More...</a><br /></td></tr>
<tr class="separator:a55c4ff8e7537e5d77f5edd0038705393"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a17b5a1ad1cf5759d34c6a8470089f9e1"><td class="memItemLeft" align="right" valign="top">std::istream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceAIToolbox_1_1POMDP.html#a17b5a1ad1cf5759d34c6a8470089f9e1">operator&gt;&gt;</a> (std::istream &amp;is, <a class="el" href="classAIToolbox_1_1POMDP_1_1Policy.html">Policy</a> &amp;p)</td></tr>
<tr class="memdesc:a17b5a1ad1cf5759d34c6a8470089f9e1"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function reads a policy from a file.  <a href="#a17b5a1ad1cf5759d34c6a8470089f9e1">More...</a><br /></td></tr>
<tr class="separator:a17b5a1ad1cf5759d34c6a8470089f9e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a46eee8111107489e3d68d30055722ed8"><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceAIToolbox_1_1POMDP.html#a46eee8111107489e3d68d30055722ed8">operator&lt;&lt;</a> (std::ostream &amp;os, const <a class="el" href="classAIToolbox_1_1POMDP_1_1Policy.html">Policy</a> &amp;p)</td></tr>
<tr class="memdesc:a46eee8111107489e3d68d30055722ed8"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function prints the whole policy to a stream.  <a href="#a46eee8111107489e3d68d30055722ed8">More...</a><br /></td></tr>
<tr class="separator:a46eee8111107489e3d68d30055722ed8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3dd0669f710850fc93fe8f7b102fb1b6"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceAIToolbox_1_1POMDP.html#a3dd0669f710850fc93fe8f7b102fb1b6">operator&lt;</a> (const <a class="el" href="structAIToolbox_1_1POMDP_1_1VEntry.html">VEntry</a> &amp;lhs, const <a class="el" href="structAIToolbox_1_1POMDP_1_1VEntry.html">VEntry</a> &amp;rhs)</td></tr>
<tr class="memdesc:a3dd0669f710850fc93fe8f7b102fb1b6"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function lexicographically sorts VEntries.  <a href="#a3dd0669f710850fc93fe8f7b102fb1b6">More...</a><br /></td></tr>
<tr class="separator:a3dd0669f710850fc93fe8f7b102fb1b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a45f5d972365404bca4ddfbef575b1bd0"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceAIToolbox_1_1POMDP.html#a45f5d972365404bca4ddfbef575b1bd0">operator==</a> (const <a class="el" href="structAIToolbox_1_1POMDP_1_1VEntry.html">VEntry</a> &amp;lhs, const <a class="el" href="structAIToolbox_1_1POMDP_1_1VEntry.html">VEntry</a> &amp;rhs)</td></tr>
<tr class="separator:a45f5d972365404bca4ddfbef575b1bd0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5254fac18b477fde30cff6ccbb131a63"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceAIToolbox_1_1POMDP.html#a5254fac18b477fde30cff6ccbb131a63">hash_value</a> (const <a class="el" href="structAIToolbox_1_1POMDP_1_1VEntry.html">VEntry</a> &amp;v)</td></tr>
<tr class="memdesc:a5254fac18b477fde30cff6ccbb131a63"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function enables hashing of VEntries with boost::hash.  <a href="#a5254fac18b477fde30cff6ccbb131a63">More...</a><br /></td></tr>
<tr class="separator:a5254fac18b477fde30cff6ccbb131a63"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac8532961013ec06fe6d47960b71ae822"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="namespaceAIToolbox_1_1MDP.html#ae6bfccca3b00146c82eb345ca8490b74">MDP::Values</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceAIToolbox_1_1POMDP.html#ac8532961013ec06fe6d47960b71ae822">unwrap</a> (const <a class="el" href="structAIToolbox_1_1POMDP_1_1VEntry.html">VEntry</a> &amp;ve)</td></tr>
<tr class="memdesc:ac8532961013ec06fe6d47960b71ae822"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function is used with transform iterators to obtain the Values of a <a class="el" href="structAIToolbox_1_1POMDP_1_1VEntry.html">VEntry</a>.  <a href="#ac8532961013ec06fe6d47960b71ae822">More...</a><br /></td></tr>
<tr class="separator:ac8532961013ec06fe6d47960b71ae822"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3f341f4ae91af26c67abd8e650522fdf"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceAIToolbox_1_1POMDP.html#ab1cada9fef241e48a9d14d36cb61dabb">ValueFunction</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceAIToolbox_1_1POMDP.html#a3f341f4ae91af26c67abd8e650522fdf">makeValueFunction</a> (size_t S)</td></tr>
<tr class="memdesc:a3f341f4ae91af26c67abd8e650522fdf"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function creates a default ValueFunction.  <a href="#a3f341f4ae91af26c67abd8e650522fdf">More...</a><br /></td></tr>
<tr class="separator:a3f341f4ae91af26c67abd8e650522fdf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a05e4fb4a18324709e70b42d66cf2054b"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceAIToolbox_1_1POMDP.html#a05e4fb4a18324709e70b42d66cf2054b">weakBoundDistance</a> (const <a class="el" href="namespaceAIToolbox_1_1POMDP.html#a5655ffd334a1e53622314eae70eab464">VList</a> &amp;oldV, const <a class="el" href="namespaceAIToolbox_1_1POMDP.html#a5655ffd334a1e53622314eae70eab464">VList</a> &amp;newV)</td></tr>
<tr class="memdesc:a05e4fb4a18324709e70b42d66cf2054b"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function returns a weak measure of distance between two VLists.  <a href="#a05e4fb4a18324709e70b42d66cf2054b">More...</a><br /></td></tr>
<tr class="separator:a05e4fb4a18324709e70b42d66cf2054b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a18f4d95909ab7eeee98d04317c5e88ac"><td class="memTemplParams" colspan="2">template&lt;typename M , std::enable_if_t&lt; is_model_v&lt; M &gt;, int &gt;  = 0&gt; </td></tr>
<tr class="memitem:a18f4d95909ab7eeee98d04317c5e88ac"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceAIToolbox_1_1POMDP.html#a18f4d95909ab7eeee98d04317c5e88ac">makeSOSA</a> (const M &amp;m)</td></tr>
<tr class="memdesc:a18f4d95909ab7eeee98d04317c5e88ac"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function creates the SOSA table for the input <a class="el" href="namespaceAIToolbox_1_1POMDP.html">POMDP</a>.  <a href="#a18f4d95909ab7eeee98d04317c5e88ac">More...</a><br /></td></tr>
<tr class="separator:a18f4d95909ab7eeee98d04317c5e88ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6a6deb0f6f3d12bb59f0b9813604abc2"><td class="memTemplParams" colspan="2">template&lt;typename M , std::enable_if_t&lt; is_model_v&lt; M &gt;, int &gt;  = 0&gt; </td></tr>
<tr class="memitem:a6a6deb0f6f3d12bb59f0b9813604abc2"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceAIToolbox_1_1POMDP.html#a6a6deb0f6f3d12bb59f0b9813604abc2">updateBeliefUnnormalized</a> (const M &amp;model, const <a class="el" href="namespaceAIToolbox_1_1POMDP.html#a4522c5e35483fb30b2c43c271781e8bc">Belief</a> &amp;b, const size_t a, const size_t o, <a class="el" href="namespaceAIToolbox_1_1POMDP.html#a4522c5e35483fb30b2c43c271781e8bc">Belief</a> *bRet)</td></tr>
<tr class="memdesc:a6a6deb0f6f3d12bb59f0b9813604abc2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new belief reflecting changes after an action and observation for a particular <a class="el" href="classAIToolbox_1_1POMDP_1_1Model.html" title="This class represents a Partially Observable Markov Decision Process. ">Model</a>.  <a href="#a6a6deb0f6f3d12bb59f0b9813604abc2">More...</a><br /></td></tr>
<tr class="separator:a6a6deb0f6f3d12bb59f0b9813604abc2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeadb8ad292520175aea2ad4b9173c5cd"><td class="memTemplParams" colspan="2">template&lt;typename M , std::enable_if_t&lt; is_model_v&lt; M &gt;, int &gt;  = 0&gt; </td></tr>
<tr class="memitem:aeadb8ad292520175aea2ad4b9173c5cd"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespaceAIToolbox_1_1POMDP.html#a4522c5e35483fb30b2c43c271781e8bc">Belief</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceAIToolbox_1_1POMDP.html#aeadb8ad292520175aea2ad4b9173c5cd">updateBeliefUnnormalized</a> (const M &amp;model, const <a class="el" href="namespaceAIToolbox_1_1POMDP.html#a4522c5e35483fb30b2c43c271781e8bc">Belief</a> &amp;b, const size_t a, const size_t o)</td></tr>
<tr class="memdesc:aeadb8ad292520175aea2ad4b9173c5cd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new belief reflecting changes after an action and observation for a particular <a class="el" href="classAIToolbox_1_1POMDP_1_1Model.html" title="This class represents a Partially Observable Markov Decision Process. ">Model</a>.  <a href="#aeadb8ad292520175aea2ad4b9173c5cd">More...</a><br /></td></tr>
<tr class="separator:aeadb8ad292520175aea2ad4b9173c5cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a33a1c23c71b6afae16da4db1863bf68d"><td class="memTemplParams" colspan="2">template&lt;typename M , std::enable_if_t&lt; is_model_v&lt; M &gt;, int &gt;  = 0&gt; </td></tr>
<tr class="memitem:a33a1c23c71b6afae16da4db1863bf68d"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceAIToolbox_1_1POMDP.html#a33a1c23c71b6afae16da4db1863bf68d">updateBelief</a> (const M &amp;model, const <a class="el" href="namespaceAIToolbox_1_1POMDP.html#a4522c5e35483fb30b2c43c271781e8bc">Belief</a> &amp;b, const size_t a, const size_t o, <a class="el" href="namespaceAIToolbox_1_1POMDP.html#a4522c5e35483fb30b2c43c271781e8bc">Belief</a> *bRet)</td></tr>
<tr class="memdesc:a33a1c23c71b6afae16da4db1863bf68d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new belief reflecting changes after an action and observation for a particular <a class="el" href="classAIToolbox_1_1POMDP_1_1Model.html" title="This class represents a Partially Observable Markov Decision Process. ">Model</a>.  <a href="#a33a1c23c71b6afae16da4db1863bf68d">More...</a><br /></td></tr>
<tr class="separator:a33a1c23c71b6afae16da4db1863bf68d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad19c9f085248dc19299d511194210843"><td class="memTemplParams" colspan="2">template&lt;typename M , std::enable_if_t&lt; is_model_v&lt; M &gt;, int &gt;  = 0&gt; </td></tr>
<tr class="memitem:ad19c9f085248dc19299d511194210843"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespaceAIToolbox_1_1POMDP.html#a4522c5e35483fb30b2c43c271781e8bc">Belief</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceAIToolbox_1_1POMDP.html#ad19c9f085248dc19299d511194210843">updateBelief</a> (const M &amp;model, const <a class="el" href="namespaceAIToolbox_1_1POMDP.html#a4522c5e35483fb30b2c43c271781e8bc">Belief</a> &amp;b, const size_t a, const size_t o)</td></tr>
<tr class="memdesc:ad19c9f085248dc19299d511194210843"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new belief reflecting changes after an action and observation for a particular <a class="el" href="classAIToolbox_1_1POMDP_1_1Model.html" title="This class represents a Partially Observable Markov Decision Process. ">Model</a>.  <a href="#ad19c9f085248dc19299d511194210843">More...</a><br /></td></tr>
<tr class="separator:ad19c9f085248dc19299d511194210843"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a413832fe24061c45091f0a24e7a7eee2"><td class="memTemplParams" colspan="2">template&lt;typename M , std::enable_if_t&lt; is_model_v&lt; M &gt;, int &gt;  = 0&gt; </td></tr>
<tr class="memitem:a413832fe24061c45091f0a24e7a7eee2"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceAIToolbox_1_1POMDP.html#a413832fe24061c45091f0a24e7a7eee2">updateBeliefPartial</a> (const M &amp;model, const <a class="el" href="namespaceAIToolbox_1_1POMDP.html#a4522c5e35483fb30b2c43c271781e8bc">Belief</a> &amp;b, const size_t a, <a class="el" href="namespaceAIToolbox_1_1POMDP.html#a4522c5e35483fb30b2c43c271781e8bc">Belief</a> *bRet)</td></tr>
<tr class="memdesc:a413832fe24061c45091f0a24e7a7eee2"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function partially updates a belief.  <a href="#a413832fe24061c45091f0a24e7a7eee2">More...</a><br /></td></tr>
<tr class="separator:a413832fe24061c45091f0a24e7a7eee2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af9903a18de2b0961d2f9a58f18bed9e5"><td class="memTemplParams" colspan="2">template&lt;typename M , std::enable_if_t&lt; is_model_v&lt; M &gt;, int &gt;  = 0&gt; </td></tr>
<tr class="memitem:af9903a18de2b0961d2f9a58f18bed9e5"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespaceAIToolbox_1_1POMDP.html#a4522c5e35483fb30b2c43c271781e8bc">Belief</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceAIToolbox_1_1POMDP.html#af9903a18de2b0961d2f9a58f18bed9e5">updateBeliefPartial</a> (const M &amp;model, const <a class="el" href="namespaceAIToolbox_1_1POMDP.html#a4522c5e35483fb30b2c43c271781e8bc">Belief</a> &amp;b, const size_t a)</td></tr>
<tr class="memdesc:af9903a18de2b0961d2f9a58f18bed9e5"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function partially updates a belief.  <a href="#af9903a18de2b0961d2f9a58f18bed9e5">More...</a><br /></td></tr>
<tr class="separator:af9903a18de2b0961d2f9a58f18bed9e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0f00347484bfd228db82d264a889d649"><td class="memTemplParams" colspan="2">template&lt;typename M , std::enable_if_t&lt; is_model_v&lt; M &gt;, int &gt;  = 0&gt; </td></tr>
<tr class="memitem:a0f00347484bfd228db82d264a889d649"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceAIToolbox_1_1POMDP.html#a0f00347484bfd228db82d264a889d649">updateBeliefPartialUnnormalized</a> (const M &amp;model, const <a class="el" href="namespaceAIToolbox_1_1POMDP.html#a4522c5e35483fb30b2c43c271781e8bc">Belief</a> &amp;b, const size_t a, const size_t o, <a class="el" href="namespaceAIToolbox_1_1POMDP.html#a4522c5e35483fb30b2c43c271781e8bc">Belief</a> *bRet)</td></tr>
<tr class="memdesc:a0f00347484bfd228db82d264a889d649"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function terminates the unnormalized update of a partially updated belief.  <a href="#a0f00347484bfd228db82d264a889d649">More...</a><br /></td></tr>
<tr class="separator:a0f00347484bfd228db82d264a889d649"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad03a82580eea9bba77d72052b181168a"><td class="memTemplParams" colspan="2">template&lt;typename M , std::enable_if_t&lt; is_model_v&lt; M &gt;, int &gt;  = 0&gt; </td></tr>
<tr class="memitem:ad03a82580eea9bba77d72052b181168a"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespaceAIToolbox_1_1POMDP.html#a4522c5e35483fb30b2c43c271781e8bc">Belief</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceAIToolbox_1_1POMDP.html#ad03a82580eea9bba77d72052b181168a">updateBeliefPartialUnnormalized</a> (const M &amp;model, const <a class="el" href="namespaceAIToolbox_1_1POMDP.html#a4522c5e35483fb30b2c43c271781e8bc">Belief</a> &amp;b, const size_t a, const size_t o)</td></tr>
<tr class="memdesc:ad03a82580eea9bba77d72052b181168a"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function terminates the unnormalized update of a partially updated belief.  <a href="#ad03a82580eea9bba77d72052b181168a">More...</a><br /></td></tr>
<tr class="separator:ad03a82580eea9bba77d72052b181168a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3be3dce28e8d80fe6457ebbe0b5da9cb"><td class="memTemplParams" colspan="2">template&lt;typename M , std::enable_if_t&lt; is_model_v&lt; M &gt;, int &gt;  = 0&gt; </td></tr>
<tr class="memitem:a3be3dce28e8d80fe6457ebbe0b5da9cb"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceAIToolbox_1_1POMDP.html#a3be3dce28e8d80fe6457ebbe0b5da9cb">updateBeliefPartialNormalized</a> (const M &amp;model, const <a class="el" href="namespaceAIToolbox_1_1POMDP.html#a4522c5e35483fb30b2c43c271781e8bc">Belief</a> &amp;b, const size_t a, const size_t o, <a class="el" href="namespaceAIToolbox_1_1POMDP.html#a4522c5e35483fb30b2c43c271781e8bc">Belief</a> *bRet)</td></tr>
<tr class="memdesc:a3be3dce28e8d80fe6457ebbe0b5da9cb"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function terminates the normalized update of a partially updated belief.  <a href="#a3be3dce28e8d80fe6457ebbe0b5da9cb">More...</a><br /></td></tr>
<tr class="separator:a3be3dce28e8d80fe6457ebbe0b5da9cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0fe1545a75c1d70a6fd97cb876bff9e2"><td class="memTemplParams" colspan="2">template&lt;typename M , std::enable_if_t&lt; is_model_v&lt; M &gt;, int &gt;  = 0&gt; </td></tr>
<tr class="memitem:a0fe1545a75c1d70a6fd97cb876bff9e2"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespaceAIToolbox_1_1POMDP.html#a4522c5e35483fb30b2c43c271781e8bc">Belief</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceAIToolbox_1_1POMDP.html#a0fe1545a75c1d70a6fd97cb876bff9e2">updateBeliefPartialNormalized</a> (const M &amp;model, const <a class="el" href="namespaceAIToolbox_1_1POMDP.html#a4522c5e35483fb30b2c43c271781e8bc">Belief</a> &amp;b, const size_t a, const size_t o)</td></tr>
<tr class="memdesc:a0fe1545a75c1d70a6fd97cb876bff9e2"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function terminates the normalized update of a partially updated belief.  <a href="#a0fe1545a75c1d70a6fd97cb876bff9e2">More...</a><br /></td></tr>
<tr class="separator:a0fe1545a75c1d70a6fd97cb876bff9e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a49e94718a9c0e92e4c0da630aa5d3dc9"><td class="memTemplParams" colspan="2">template&lt;typename M , std::enable_if_t&lt; is_model_v&lt; M &gt;, int &gt;  = 0&gt; </td></tr>
<tr class="memitem:a49e94718a9c0e92e4c0da630aa5d3dc9"><td class="memTemplItemLeft" align="right" valign="top">double&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceAIToolbox_1_1POMDP.html#a49e94718a9c0e92e4c0da630aa5d3dc9">beliefExpectedReward</a> (const M &amp;model, const <a class="el" href="namespaceAIToolbox_1_1POMDP.html#a4522c5e35483fb30b2c43c271781e8bc">Belief</a> &amp;b, const size_t a)</td></tr>
<tr class="memdesc:a49e94718a9c0e92e4c0da630aa5d3dc9"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function computes an immediate reward based on a belief rather than a state.  <a href="#a49e94718a9c0e92e4c0da630aa5d3dc9">More...</a><br /></td></tr>
<tr class="separator:a49e94718a9c0e92e4c0da630aa5d3dc9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a29c6a60175a6d93b7ec845c2a2cec928"><td class="memTemplParams" colspan="2">template&lt;typename ActionRow &gt; </td></tr>
<tr class="memitem:a29c6a60175a6d93b7ec845c2a2cec928"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structAIToolbox_1_1POMDP_1_1VEntry.html">VEntry</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceAIToolbox_1_1POMDP.html#a29c6a60175a6d93b7ec845c2a2cec928">crossSumBestAtBelief</a> (const <a class="el" href="namespaceAIToolbox_1_1POMDP.html#a4522c5e35483fb30b2c43c271781e8bc">Belief</a> &amp;b, const ActionRow &amp;row, const size_t a, double *value=nullptr)</td></tr>
<tr class="memdesc:a29c6a60175a6d93b7ec845c2a2cec928"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function computes the best <a class="el" href="structAIToolbox_1_1POMDP_1_1VEntry.html">VEntry</a> for the input belief from the input VLists.  <a href="#a29c6a60175a6d93b7ec845c2a2cec928">More...</a><br /></td></tr>
<tr class="separator:a29c6a60175a6d93b7ec845c2a2cec928"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b1bf71cbc9a2c566437f1cda780c123"><td class="memTemplParams" colspan="2">template&lt;typename Projections &gt; </td></tr>
<tr class="memitem:a7b1bf71cbc9a2c566437f1cda780c123"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structAIToolbox_1_1POMDP_1_1VEntry.html">VEntry</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceAIToolbox_1_1POMDP.html#a7b1bf71cbc9a2c566437f1cda780c123">crossSumBestAtBelief</a> (const <a class="el" href="namespaceAIToolbox_1_1POMDP.html#a4522c5e35483fb30b2c43c271781e8bc">Belief</a> &amp;b, const Projections &amp;projs, double *value=nullptr)</td></tr>
<tr class="memdesc:a7b1bf71cbc9a2c566437f1cda780c123"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function computes the best <a class="el" href="structAIToolbox_1_1POMDP_1_1VEntry.html">VEntry</a> for the input belief across all actions.  <a href="#a7b1bf71cbc9a2c566437f1cda780c123">More...</a><br /></td></tr>
<tr class="separator:a7b1bf71cbc9a2c566437f1cda780c123"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:a30d62c33ae0e760503f3712b498b3e47"><td class="memTemplParams" colspan="2">template&lt;typename LP &gt; </td></tr>
<tr class="memitem:a30d62c33ae0e760503f3712b498b3e47"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceAIToolbox_1_1POMDP.html#a30d62c33ae0e760503f3712b498b3e47">is_witness_lp_v</a> = <a class="el" href="structAIToolbox_1_1POMDP_1_1is__witness__lp.html">is_witness_lp</a>&lt;<a class="el" href="classAIToolbox_1_1LP.html">LP</a>&gt;::value</td></tr>
<tr class="separator:a30d62c33ae0e760503f3712b498b3e47"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a14f2ade0c0d30091b74297fce650ddbf"><td class="memTemplParams" colspan="2">template&lt;typename M &gt; </td></tr>
<tr class="memitem:a14f2ade0c0d30091b74297fce650ddbf"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceAIToolbox_1_1POMDP.html#a14f2ade0c0d30091b74297fce650ddbf">is_generative_model_v</a> = <a class="el" href="structAIToolbox_1_1POMDP_1_1is__generative__model.html">is_generative_model</a>&lt;M&gt;::value</td></tr>
<tr class="separator:a14f2ade0c0d30091b74297fce650ddbf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c3d5eb7dc047b0b55379914b76fd132"><td class="memTemplParams" colspan="2">template&lt;typename M &gt; </td></tr>
<tr class="memitem:a7c3d5eb7dc047b0b55379914b76fd132"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceAIToolbox_1_1POMDP.html#a7c3d5eb7dc047b0b55379914b76fd132">is_model_v</a> = <a class="el" href="structAIToolbox_1_1POMDP_1_1is__model.html">is_model</a>&lt;M&gt;::value</td></tr>
<tr class="separator:a7c3d5eb7dc047b0b55379914b76fd132"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0a7899814376313aa6ee8dadecea379d"><td class="memTemplParams" colspan="2">template&lt;typename M &gt; </td></tr>
<tr class="memitem:a0a7899814376313aa6ee8dadecea379d"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceAIToolbox_1_1POMDP.html#a0a7899814376313aa6ee8dadecea379d">is_model_eigen_v</a> = <a class="el" href="structAIToolbox_1_1POMDP_1_1is__model__eigen.html">is_model_eigen</a>&lt;M&gt;::value</td></tr>
<tr class="separator:a0a7899814376313aa6ee8dadecea379d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abbf63587b8e90849d2501933a827061a"><td class="memTemplParams" colspan="2">template&lt;typename M &gt; </td></tr>
<tr class="memitem:abbf63587b8e90849d2501933a827061a"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceAIToolbox_1_1POMDP.html#abbf63587b8e90849d2501933a827061a">is_model_not_eigen_v</a> = <a class="el" href="structAIToolbox_1_1POMDP_1_1is__model__not__eigen.html">is_model_not_eigen</a>&lt;M&gt;::value</td></tr>
<tr class="separator:abbf63587b8e90849d2501933a827061a"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Typedef Documentation</h2>
<a id="a97f123407d50846293c4e9b46d7fbd49"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a97f123407d50846293c4e9b46d7fbd49">&#9670;&nbsp;</a></span>ActionNodes</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;bool UseEntropy&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceAIToolbox_1_1POMDP.html#a97f123407d50846293c4e9b46d7fbd49">AIToolbox::POMDP::ActionNodes</a> = typedef std::vector&lt;<a class="el" href="structAIToolbox_1_1POMDP_1_1ActionNode.html">ActionNode</a>&lt;UseEntropy&gt; &gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a4522c5e35483fb30b2c43c271781e8bc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4522c5e35483fb30b2c43c271781e8bc">&#9670;&nbsp;</a></span>Belief</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceAIToolbox_1_1POMDP.html#a4522c5e35483fb30b2c43c271781e8bc">AIToolbox::POMDP::Belief</a> = typedef <a class="el" href="namespaceAIToolbox.html#af4149b71e91dee03ad9d0c8c207eddf0">ProbabilityVector</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This represents a belief, which is a probability distribution over states. </p>

</div>
</div>
<a id="afba9c8e6204b8f6b341362af3991da75"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afba9c8e6204b8f6b341362af3991da75">&#9670;&nbsp;</a></span>BeliefNodes</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;bool UseEntropy&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceAIToolbox_1_1POMDP.html#afba9c8e6204b8f6b341362af3991da75">AIToolbox::POMDP::BeliefNodes</a> = typedef std::unordered_map&lt;size_t, <a class="el" href="classAIToolbox_1_1POMDP_1_1BeliefNode.html">BeliefNode</a>&lt;UseEntropy&gt; &gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a79664c416e1fbfe5d89acb9f94f35bee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a79664c416e1fbfe5d89acb9f94f35bee">&#9670;&nbsp;</a></span>SampleBelief</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceAIToolbox_1_1POMDP.html#a79664c416e1fbfe5d89acb9f94f35bee">AIToolbox::POMDP::SampleBelief</a> = typedef std::vector&lt;std::pair&lt;size_t, unsigned&gt; &gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ad867f06ad8946aa1b205a7f5f8fcb42e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad867f06ad8946aa1b205a7f5f8fcb42e">&#9670;&nbsp;</a></span>TrackBelief</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;bool UseEntropy&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceAIToolbox_1_1POMDP.html#ad867f06ad8946aa1b205a7f5f8fcb42e">AIToolbox::POMDP::TrackBelief</a> = typedef std::unordered_map&lt; size_t, <a class="el" href="structAIToolbox_1_1POMDP_1_1BeliefParticle.html">BeliefParticle</a>&lt;UseEntropy&gt;, std::hash&lt;size_t&gt;, std::equal_to&lt;size_t&gt; &gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ab1cada9fef241e48a9d14d36cb61dabb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab1cada9fef241e48a9d14d36cb61dabb">&#9670;&nbsp;</a></span>ValueFunction</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceAIToolbox_1_1POMDP.html#ab1cada9fef241e48a9d14d36cb61dabb">AIToolbox::POMDP::ValueFunction</a> = typedef std::vector&lt;<a class="el" href="namespaceAIToolbox_1_1POMDP.html#a5655ffd334a1e53622314eae70eab464">VList</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a5655ffd334a1e53622314eae70eab464"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5655ffd334a1e53622314eae70eab464">&#9670;&nbsp;</a></span>VList</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceAIToolbox_1_1POMDP.html#a5655ffd334a1e53622314eae70eab464">AIToolbox::POMDP::VList</a> = typedef std::vector&lt;<a class="el" href="structAIToolbox_1_1POMDP_1_1VEntry.html">VEntry</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a72aee7b57445d6b773012d9b54b85339"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a72aee7b57445d6b773012d9b54b85339">&#9670;&nbsp;</a></span>VObs</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceAIToolbox_1_1POMDP.html#a72aee7b57445d6b773012d9b54b85339">AIToolbox::POMDP::VObs</a> = typedef std::vector&lt;size_t&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="a49e94718a9c0e92e4c0da630aa5d3dc9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a49e94718a9c0e92e4c0da630aa5d3dc9">&#9670;&nbsp;</a></span>beliefExpectedReward()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename M , std::enable_if_t&lt; is_model_v&lt; M &gt;, int &gt;  = 0&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">double AIToolbox::POMDP::beliefExpectedReward </td>
          <td>(</td>
          <td class="paramtype">const M &amp;&#160;</td>
          <td class="paramname"><em>model</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceAIToolbox_1_1POMDP.html#a4522c5e35483fb30b2c43c271781e8bc">Belief</a> &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>a</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function computes an immediate reward based on a belief rather than a state. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">model</td><td>The <a class="el" href="namespaceAIToolbox_1_1POMDP.html">POMDP</a> model to use. </td></tr>
    <tr><td class="paramname">b</td><td>The belief to use. </td></tr>
    <tr><td class="paramname">a</td><td>The action performed from the belief.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The immediate reward. </dd></dl>

</div>
</div>
<a id="a5fe691ce2374490bf25dcb583d7c2baf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5fe691ce2374490bf25dcb583d7c2baf">&#9670;&nbsp;</a></span>bestConservativeAction()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename M , typename  = std::enable_if_t&lt;is_model_v&lt;M&gt;&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::tuple&lt;size_t, double&gt; AIToolbox::POMDP::bestConservativeAction </td>
          <td>(</td>
          <td class="paramtype">const M &amp;&#160;</td>
          <td class="paramname"><em>pomdp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceAIToolbox_1_1POMDP.html#a4522c5e35483fb30b2c43c271781e8bc">Belief</a> &amp;&#160;</td>
          <td class="paramname"><em>initialBelief</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceAIToolbox_1_1POMDP.html#a5655ffd334a1e53622314eae70eab464">VList</a> &amp;&#160;</td>
          <td class="paramname"><em>lbVList</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function obtains the best action with respect to the input VList. </p>
<p>This function pretty much does what the <a class="el" href="classAIToolbox_1_1POMDP_1_1Projecter.html" title="This class offers projecting facilities for Models. ">Projecter</a> class does. The difference is that while the <a class="el" href="classAIToolbox_1_1POMDP_1_1Projecter.html" title="This class offers projecting facilities for Models. ">Projecter</a> expands one step in the future every single entry in the input VList, this only does it to the input Belief.</p>
<p>This allows to both avoid a lot of work if we wouldn't need to reuse the <a class="el" href="classAIToolbox_1_1POMDP_1_1Projecter.html" title="This class offers projecting facilities for Models. ">Projecter</a> results a lot, and simplifies the crossSum step.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pomdp</td><td>The model to use. </td></tr>
    <tr><td class="paramname">initialBelief</td><td>The belief where the best action needs to be found. </td></tr>
    <tr><td class="paramname">lbVList</td><td>The alphavectors to use.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The best action in the input belief with respect to the input VList. </dd></dl>

</div>
</div>
<a id="a29c6a60175a6d93b7ec845c2a2cec928"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a29c6a60175a6d93b7ec845c2a2cec928">&#9670;&nbsp;</a></span>crossSumBestAtBelief() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ActionRow &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structAIToolbox_1_1POMDP_1_1VEntry.html">VEntry</a> AIToolbox::POMDP::crossSumBestAtBelief </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceAIToolbox_1_1POMDP.html#a4522c5e35483fb30b2c43c271781e8bc">Belief</a> &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ActionRow &amp;&#160;</td>
          <td class="paramname"><em>row</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>value</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function computes the best <a class="el" href="structAIToolbox_1_1POMDP_1_1VEntry.html">VEntry</a> for the input belief from the input VLists. </p>
<p>This function computes the best alphavector for the input belief. It assumes as input a list of VLists, one per observation. You can produce them with the <a class="el" href="classAIToolbox_1_1POMDP_1_1Projecter.html" title="This class offers projecting facilities for Models. ">Projecter</a> class, for example.</p>
<p>For each observation it will select the match with the best value, and use it to compute the output <a class="el" href="structAIToolbox_1_1POMDP_1_1VEntry.html">VEntry</a>.</p>
<p>The action is not used to perform computations here, but it is fed directly into the returned <a class="el" href="structAIToolbox_1_1POMDP_1_1VEntry.html">VEntry</a>.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">ActionRow</td><td>The type of the list of VLists. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">b</td><td>The belief to compute the <a class="el" href="structAIToolbox_1_1POMDP_1_1VEntry.html">VEntry</a> for. </td></tr>
    <tr><td class="paramname">row</td><td>The list of VLists, one per observation. </td></tr>
    <tr><td class="paramname">a</td><td>The action this Ventry stands for. </td></tr>
    <tr><td class="paramname">value</td><td>A pointer to double, which gets set to the value of the given belief with the generated <a class="el" href="structAIToolbox_1_1POMDP_1_1VEntry.html">VEntry</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The best <a class="el" href="structAIToolbox_1_1POMDP_1_1VEntry.html">VEntry</a> for the input belief. </dd></dl>

</div>
</div>
<a id="a7b1bf71cbc9a2c566437f1cda780c123"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7b1bf71cbc9a2c566437f1cda780c123">&#9670;&nbsp;</a></span>crossSumBestAtBelief() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Projections &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structAIToolbox_1_1POMDP_1_1VEntry.html">VEntry</a> AIToolbox::POMDP::crossSumBestAtBelief </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceAIToolbox_1_1POMDP.html#a4522c5e35483fb30b2c43c271781e8bc">Belief</a> &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Projections &amp;&#160;</td>
          <td class="paramname"><em>projs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>value</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function computes the best <a class="el" href="structAIToolbox_1_1POMDP_1_1VEntry.html">VEntry</a> for the input belief across all actions. </p>
<p>This function needs the projections of the previous timestep's VLists in order to work. It will then compute the best <a class="el" href="structAIToolbox_1_1POMDP_1_1VEntry.html">VEntry</a> for the input belief across all actions.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Projections</td><td>The type of the 2D array of VLists containing all the projections. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">b</td><td>The belief to compute the <a class="el" href="structAIToolbox_1_1POMDP_1_1VEntry.html">VEntry</a> for. </td></tr>
    <tr><td class="paramname">projs</td><td>The projections of the old VLists. </td></tr>
    <tr><td class="paramname">value</td><td>A pointer to double, which gets set to the value of the given belief with the generated <a class="el" href="structAIToolbox_1_1POMDP_1_1VEntry.html">VEntry</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The best <a class="el" href="structAIToolbox_1_1POMDP_1_1VEntry.html">VEntry</a> for the input belief. </dd></dl>

</div>
</div>
<a id="a5254fac18b477fde30cff6ccbb131a63"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5254fac18b477fde30cff6ccbb131a63">&#9670;&nbsp;</a></span>hash_value()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t AIToolbox::POMDP::hash_value </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structAIToolbox_1_1POMDP_1_1VEntry.html">VEntry</a> &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This function enables hashing of VEntries with boost::hash. </p>

</div>
</div>
<a id="a18f4d95909ab7eeee98d04317c5e88ac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a18f4d95909ab7eeee98d04317c5e88ac">&#9670;&nbsp;</a></span>makeSOSA()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename M , std::enable_if_t&lt; is_model_v&lt; M &gt;, int &gt;  = 0&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto AIToolbox::POMDP::makeSOSA </td>
          <td>(</td>
          <td class="paramtype">const M &amp;&#160;</td>
          <td class="paramname"><em>m</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function creates the SOSA table for the input <a class="el" href="namespaceAIToolbox_1_1POMDP.html">POMDP</a>. </p>
<p>The SOSA table is a way to represent the observation and transition functions in a single function, at the same time.</p>
<p>Each cell in this four-dimensional table contains the probability of getting to state s' while obtaining observation o when starting with state s and action a.</p>
<p>This table is less space-efficient than storing both tables separately, but it can save you some time if you need its values multiple times in a loop (for example in the <a class="el" href="classAIToolbox_1_1POMDP_1_1FastInformedBound.html" title="This class implements the Fast Informed Bound algorithm. ">FastInformedBound</a> algorithm).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">m</td><td>The input <a class="el" href="namespaceAIToolbox_1_1POMDP.html">POMDP</a> to extract the SOSA table from.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The SOSA table for the input pomdp. </dd></dl>

</div>
</div>
<a id="a3f341f4ae91af26c67abd8e650522fdf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3f341f4ae91af26c67abd8e650522fdf">&#9670;&nbsp;</a></span>makeValueFunction()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceAIToolbox_1_1POMDP.html#ab1cada9fef241e48a9d14d36cb61dabb">ValueFunction</a> AIToolbox::POMDP::makeValueFunction </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>S</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function creates a default ValueFunction. </p>
<p>The default ValueFunction contains a single VList with inside a single <a class="el" href="structAIToolbox_1_1POMDP_1_1VEntry.html">VEntry</a>: do action 0, with all value zeroes.</p>
<p>The VList is a necessary byproduct that is needed when computing the whole ValueFunction recursively via dynamic programming.</p>
<p>In the end, to act, it's not needed, but it's probably more hassle to remove the entry, and so we leave it there. So in general we always assume it's there.</p>
<p>Another peculiarity of the default <a class="el" href="structAIToolbox_1_1POMDP_1_1VEntry.html">VEntry</a> is that it's the only place where the observation id vector is empty, since nobody is ever supposed to go looking in there.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">S</td><td>The number of possible states.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A new ValueFunction. </dd></dl>

</div>
</div>
<a id="a3dd0669f710850fc93fe8f7b102fb1b6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3dd0669f710850fc93fe8f7b102fb1b6">&#9670;&nbsp;</a></span>operator<()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool AIToolbox::POMDP::operator&lt; </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structAIToolbox_1_1POMDP_1_1VEntry.html">VEntry</a> &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structAIToolbox_1_1POMDP_1_1VEntry.html">VEntry</a> &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function lexicographically sorts VEntries. </p>
<p>This is useful during testing in order to sort and compare a solution with the correct result.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>The left hand side of the comparison. </td></tr>
    <tr><td class="paramname">rhs</td><td>The right hand side of the comparison.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if lhs is less than rhs lexicographically, false otherwise. </dd></dl>

</div>
</div>
<a id="af460a8a2b997c9c93e620e9f805fcaf3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af460a8a2b997c9c93e620e9f805fcaf3">&#9670;&nbsp;</a></span>operator<<() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename M , std::enable_if_t&lt; is_model_v&lt; M &gt;, int &gt;  = 0&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; AIToolbox::POMDP::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const M &amp;&#160;</td>
          <td class="paramname"><em>model</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function prints any <a class="el" href="namespaceAIToolbox_1_1POMDP.html">POMDP</a> model to a file. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">M</td><td>The type of the model. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">os</td><td>The output stream. </td></tr>
    <tr><td class="paramname">model</td><td>The model to print.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The resulting output stream. </dd></dl>

</div>
</div>
<a id="a46eee8111107489e3d68d30055722ed8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a46eee8111107489e3d68d30055722ed8">&#9670;&nbsp;</a></span>operator<<() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; AIToolbox::POMDP::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classAIToolbox_1_1POMDP_1_1Policy.html">Policy</a> &amp;&#160;</td>
          <td class="paramname"><em>p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function prints the whole policy to a stream. </p>
<p>This function basically outputs the internal ValueFunction in a recoverable format.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">os</td><td>The stream where the policy is printed. </td></tr>
    <tr><td class="paramname">p</td><td>The policy that is begin printed.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The original stream. </dd></dl>

</div>
</div>
<a id="a45f5d972365404bca4ddfbef575b1bd0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a45f5d972365404bca4ddfbef575b1bd0">&#9670;&nbsp;</a></span>operator==()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool AIToolbox::POMDP::operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structAIToolbox_1_1POMDP_1_1VEntry.html">VEntry</a> &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structAIToolbox_1_1POMDP_1_1VEntry.html">VEntry</a> &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a3e6938312f6dd9d20f1f3767bb361a76"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3e6938312f6dd9d20f1f3767bb361a76">&#9670;&nbsp;</a></span>operator>>() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename M , typename &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::istream &amp; AIToolbox::POMDP::operator&gt;&gt; </td>
          <td>(</td>
          <td class="paramtype">std::istream &amp;&#160;</td>
          <td class="paramname"><em>is</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classAIToolbox_1_1POMDP_1_1Model.html">Model</a>&lt; M &gt; &amp;&#160;</td>
          <td class="paramname"><em>m</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function implements input from stream for the <a class="el" href="classAIToolbox_1_1POMDP_1_1Model.html" title="This class represents a Partially Observable Markov Decision Process. ">POMDP::Model</a> class. </p>
<p>Note that as all other input function, it does not actually change the input model if the reading fails.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">M</td><td>The underlying <a class="el" href="namespaceAIToolbox_1_1MDP.html">MDP</a> model. Needs to have operator&lt;&lt; implemented. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">is</td><td>The input stream. </td></tr>
    <tr><td class="paramname">m</td><td>The model to write into.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The input stream. </dd></dl>

</div>
</div>
<a id="a55c4ff8e7537e5d77f5edd0038705393"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a55c4ff8e7537e5d77f5edd0038705393">&#9670;&nbsp;</a></span>operator>>() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename M , typename &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::istream &amp; AIToolbox::POMDP::operator&gt;&gt; </td>
          <td>(</td>
          <td class="paramtype">std::istream &amp;&#160;</td>
          <td class="paramname"><em>is</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classAIToolbox_1_1POMDP_1_1SparseModel.html">SparseModel</a>&lt; M &gt; &amp;&#160;</td>
          <td class="paramname"><em>m</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function implements input from stream for the <a class="el" href="classAIToolbox_1_1POMDP_1_1SparseModel.html" title="This class represents a Partially Observable Markov Decision Process. ">POMDP::SparseModel</a> class. </p>
<p>Note that as all other input function, it does not actually change the input model if the reading fails.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">M</td><td>The underlying <a class="el" href="namespaceAIToolbox_1_1MDP.html">MDP</a> model. Needs to have operator&lt;&lt; implemented. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">is</td><td>The input stream. </td></tr>
    <tr><td class="paramname">m</td><td>The model to write into.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The input stream. </dd></dl>

</div>
</div>
<a id="a17b5a1ad1cf5759d34c6a8470089f9e1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a17b5a1ad1cf5759d34c6a8470089f9e1">&#9670;&nbsp;</a></span>operator>>() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::istream&amp; AIToolbox::POMDP::operator&gt;&gt; </td>
          <td>(</td>
          <td class="paramtype">std::istream &amp;&#160;</td>
          <td class="paramname"><em>is</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classAIToolbox_1_1POMDP_1_1Policy.html">Policy</a> &amp;&#160;</td>
          <td class="paramname"><em>p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function reads a policy from a file. </p>
<p>This function reads files that have been outputted through <a class="el" href="namespaceAIToolbox_1_1POMDP.html#af460a8a2b997c9c93e620e9f805fcaf3" title="This function prints any POMDP model to a file. ">operator&lt;&lt;()</a>. If not enough values can be extracted from the stream, the function stops and the input policy is not modified. In addition, it checks whether the probability values are within 0 and 1.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">is</td><td>The stream were the policy is being read from. </td></tr>
    <tr><td class="paramname">p</td><td>The policy that is being assigned.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The input stream. </dd></dl>

</div>
</div>
<a id="a184e91a2441d41ffc7c249c587bf415c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a184e91a2441d41ffc7c249c587bf415c">&#9670;&nbsp;</a></span>parseCassandra()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classAIToolbox_1_1POMDP_1_1Model.html">Model</a>&lt;<a class="el" href="classAIToolbox_1_1MDP_1_1Model.html">MDP::Model</a>&gt; AIToolbox::POMDP::parseCassandra </td>
          <td>(</td>
          <td class="paramtype">std::istream &amp;&#160;</td>
          <td class="paramname"><em>input</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function parses a <a class="el" href="namespaceAIToolbox_1_1POMDP.html">POMDP</a> from a Cassandra formatted stream. </p>
<p>This function may throw std::runtime_errors depending on whether the input is correctly formed or not.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">input</td><td>The input stream.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The parsed model. </dd></dl>

</div>
</div>
<a id="ac8532961013ec06fe6d47960b71ae822"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac8532961013ec06fe6d47960b71ae822">&#9670;&nbsp;</a></span>unwrap()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="namespaceAIToolbox_1_1MDP.html#ae6bfccca3b00146c82eb345ca8490b74">MDP::Values</a>&amp; AIToolbox::POMDP::unwrap </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structAIToolbox_1_1POMDP_1_1VEntry.html">VEntry</a> &amp;&#160;</td>
          <td class="paramname"><em>ve</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This function is used with transform iterators to obtain the Values of a <a class="el" href="structAIToolbox_1_1POMDP_1_1VEntry.html">VEntry</a>. </p>

</div>
</div>
<a id="a33a1c23c71b6afae16da4db1863bf68d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a33a1c23c71b6afae16da4db1863bf68d">&#9670;&nbsp;</a></span>updateBelief() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename M , std::enable_if_t&lt; is_model_v&lt; M &gt;, int &gt;  = 0&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void AIToolbox::POMDP::updateBelief </td>
          <td>(</td>
          <td class="paramtype">const M &amp;&#160;</td>
          <td class="paramname"><em>model</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceAIToolbox_1_1POMDP.html#a4522c5e35483fb30b2c43c271781e8bc">Belief</a> &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>o</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceAIToolbox_1_1POMDP.html#a4522c5e35483fb30b2c43c271781e8bc">Belief</a> *&#160;</td>
          <td class="paramname"><em>bRet</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a new belief reflecting changes after an action and observation for a particular <a class="el" href="classAIToolbox_1_1POMDP_1_1Model.html" title="This class represents a Partially Observable Markov Decision Process. ">Model</a>. </p>
<p>This function writes directly into the provided Belief pointer. It assumes that the pointer points to a correctly sized Belief. It does a basic nullptr check.</p>
<p>NOTE: This function assumes that the update and the normalization are possible, i.e. that from the input belief and action it is possible to receive the input observation.</p>
<p>If that cannot be guaranteed, use the <a class="el" href="namespaceAIToolbox_1_1POMDP.html#a6a6deb0f6f3d12bb59f0b9813604abc2" title="Creates a new belief reflecting changes after an action and observation for a particular Model...">updateBeliefUnnormalized()</a> function and do the normalization yourself (and check for it).</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">M</td><td>The type of the <a class="el" href="namespaceAIToolbox_1_1POMDP.html">POMDP</a> <a class="el" href="classAIToolbox_1_1POMDP_1_1Model.html" title="This class represents a Partially Observable Markov Decision Process. ">Model</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">model</td><td>The model used to update the belief. </td></tr>
    <tr><td class="paramname">b</td><td>The old belief. </td></tr>
    <tr><td class="paramname">a</td><td>The action taken during the transition. </td></tr>
    <tr><td class="paramname">o</td><td>The observation registered. </td></tr>
    <tr><td class="paramname">bRet</td><td>The output belief. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad19c9f085248dc19299d511194210843"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad19c9f085248dc19299d511194210843">&#9670;&nbsp;</a></span>updateBelief() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename M , std::enable_if_t&lt; is_model_v&lt; M &gt;, int &gt;  = 0&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceAIToolbox_1_1POMDP.html#a4522c5e35483fb30b2c43c271781e8bc">Belief</a> AIToolbox::POMDP::updateBelief </td>
          <td>(</td>
          <td class="paramtype">const M &amp;&#160;</td>
          <td class="paramname"><em>model</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceAIToolbox_1_1POMDP.html#a4522c5e35483fb30b2c43c271781e8bc">Belief</a> &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>o</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a new belief reflecting changes after an action and observation for a particular <a class="el" href="classAIToolbox_1_1POMDP_1_1Model.html" title="This class represents a Partially Observable Markov Decision Process. ">Model</a>. </p>
<p>This function needs to create a new belief since modifying a belief in place is not possible. This is because each cell update for the new belief requires all values from the previous belief.</p>
<p>NOTE: This function assumes that the update and the normalization are possible, i.e. that from the input belief and action it is possible to receive the input observation.</p>
<p>If that cannot be guaranteed, use the <a class="el" href="namespaceAIToolbox_1_1POMDP.html#a6a6deb0f6f3d12bb59f0b9813604abc2" title="Creates a new belief reflecting changes after an action and observation for a particular Model...">updateBeliefUnnormalized()</a> function and do the normalization yourself (and check for it).</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">M</td><td>The type of the <a class="el" href="namespaceAIToolbox_1_1POMDP.html">POMDP</a> <a class="el" href="classAIToolbox_1_1POMDP_1_1Model.html" title="This class represents a Partially Observable Markov Decision Process. ">Model</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">model</td><td>The model used to update the belief. </td></tr>
    <tr><td class="paramname">b</td><td>The old belief. </td></tr>
    <tr><td class="paramname">a</td><td>The action taken during the transition. </td></tr>
    <tr><td class="paramname">o</td><td>The observation registered. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a413832fe24061c45091f0a24e7a7eee2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a413832fe24061c45091f0a24e7a7eee2">&#9670;&nbsp;</a></span>updateBeliefPartial() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename M , std::enable_if_t&lt; is_model_v&lt; M &gt;, int &gt;  = 0&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void AIToolbox::POMDP::updateBeliefPartial </td>
          <td>(</td>
          <td class="paramtype">const M &amp;&#160;</td>
          <td class="paramname"><em>model</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceAIToolbox_1_1POMDP.html#a4522c5e35483fb30b2c43c271781e8bc">Belief</a> &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceAIToolbox_1_1POMDP.html#a4522c5e35483fb30b2c43c271781e8bc">Belief</a> *&#160;</td>
          <td class="paramname"><em>bRet</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function partially updates a belief. </p>
<p>This function is useful in case one needs to update a belief for all possible observations. In such a case, it is possible to avoid repeating the same operations by creating an intermediate belief, that only depends on the action and not on the observation.</p>
<p>From this intermediate result it will be then possible to obtain the end belief by supplying the same action and the desired observation.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">M</td><td>The type of the <a class="el" href="namespaceAIToolbox_1_1POMDP.html">POMDP</a> <a class="el" href="classAIToolbox_1_1POMDP_1_1Model.html" title="This class represents a Partially Observable Markov Decision Process. ">Model</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">model</td><td>The model used to update the belief. </td></tr>
    <tr><td class="paramname">b</td><td>The old belief. </td></tr>
    <tr><td class="paramname">a</td><td>The action taken during the transition. </td></tr>
    <tr><td class="paramname">bRet</td><td>The output belief. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af9903a18de2b0961d2f9a58f18bed9e5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af9903a18de2b0961d2f9a58f18bed9e5">&#9670;&nbsp;</a></span>updateBeliefPartial() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename M , std::enable_if_t&lt; is_model_v&lt; M &gt;, int &gt;  = 0&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceAIToolbox_1_1POMDP.html#a4522c5e35483fb30b2c43c271781e8bc">Belief</a> AIToolbox::POMDP::updateBeliefPartial </td>
          <td>(</td>
          <td class="paramtype">const M &amp;&#160;</td>
          <td class="paramname"><em>model</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceAIToolbox_1_1POMDP.html#a4522c5e35483fb30b2c43c271781e8bc">Belief</a> &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>a</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function partially updates a belief. </p>
<p>This function is useful in case one needs to update a belief for all possible observations. In such a case, it is possible to avoid repeating the same operations by creating an intermediate belief, that only depends on the action and not on the observation.</p>
<p>From this intermediate result it will be then possible to obtain the end belief by supplying the same action and the desired observation.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">M</td><td>The type of the <a class="el" href="namespaceAIToolbox_1_1POMDP.html">POMDP</a> <a class="el" href="classAIToolbox_1_1POMDP_1_1Model.html" title="This class represents a Partially Observable Markov Decision Process. ">Model</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">model</td><td>The model used to update the belief. </td></tr>
    <tr><td class="paramname">b</td><td>The old belief. </td></tr>
    <tr><td class="paramname">a</td><td>The action taken during the transition. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a3be3dce28e8d80fe6457ebbe0b5da9cb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3be3dce28e8d80fe6457ebbe0b5da9cb">&#9670;&nbsp;</a></span>updateBeliefPartialNormalized() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename M , std::enable_if_t&lt; is_model_v&lt; M &gt;, int &gt;  = 0&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void AIToolbox::POMDP::updateBeliefPartialNormalized </td>
          <td>(</td>
          <td class="paramtype">const M &amp;&#160;</td>
          <td class="paramname"><em>model</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceAIToolbox_1_1POMDP.html#a4522c5e35483fb30b2c43c271781e8bc">Belief</a> &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>o</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceAIToolbox_1_1POMDP.html#a4522c5e35483fb30b2c43c271781e8bc">Belief</a> *&#160;</td>
          <td class="paramname"><em>bRet</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function terminates the normalized update of a partially updated belief. </p>
<p>This function is useful in case one needs to update a belief for all possible observations. In such a case, it is possible to avoid repeating the same operations by creating an intermediate belief, that only depends on the action and not on the observation.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="namespaceAIToolbox_1_1POMDP.html#a413832fe24061c45091f0a24e7a7eee2" title="This function partially updates a belief. ">updateBeliefPartial</a></dd></dl>
<p>Note that the input action here must be the same one that produced the intermediate result.</p>
<p>NOTE: This function assumes that the update and the normalization are possible, i.e. that from the input belief and action it is possible to receive the input observation.</p>
<p>If that cannot be guaranteed, use the <a class="el" href="namespaceAIToolbox_1_1POMDP.html#a6a6deb0f6f3d12bb59f0b9813604abc2" title="Creates a new belief reflecting changes after an action and observation for a particular Model...">updateBeliefUnnormalized()</a> function and do the normalization yourself (and check for it).</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">M</td><td>The type of the <a class="el" href="namespaceAIToolbox_1_1POMDP.html">POMDP</a> <a class="el" href="classAIToolbox_1_1POMDP_1_1Model.html" title="This class represents a Partially Observable Markov Decision Process. ">Model</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">model</td><td>The model used to update the belief. </td></tr>
    <tr><td class="paramname">b</td><td>The intermediate belief. </td></tr>
    <tr><td class="paramname">a</td><td>The action taken during the transition. </td></tr>
    <tr><td class="paramname">o</td><td>The observation registered. </td></tr>
    <tr><td class="paramname">bRet</td><td>The output belief. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a0fe1545a75c1d70a6fd97cb876bff9e2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0fe1545a75c1d70a6fd97cb876bff9e2">&#9670;&nbsp;</a></span>updateBeliefPartialNormalized() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename M , std::enable_if_t&lt; is_model_v&lt; M &gt;, int &gt;  = 0&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceAIToolbox_1_1POMDP.html#a4522c5e35483fb30b2c43c271781e8bc">Belief</a> AIToolbox::POMDP::updateBeliefPartialNormalized </td>
          <td>(</td>
          <td class="paramtype">const M &amp;&#160;</td>
          <td class="paramname"><em>model</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceAIToolbox_1_1POMDP.html#a4522c5e35483fb30b2c43c271781e8bc">Belief</a> &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>o</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function terminates the normalized update of a partially updated belief. </p>
<p>This function is useful in case one needs to update a belief for all possible observations. In such a case, it is possible to avoid repeating the same operations by creating an intermediate belief, that only depends on the action and not on the observation.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="namespaceAIToolbox_1_1POMDP.html#a413832fe24061c45091f0a24e7a7eee2" title="This function partially updates a belief. ">updateBeliefPartial</a></dd></dl>
<p>Note that the input action here must be the same one that produced the intermediate result.</p>
<p>NOTE: This function assumes that the update and the normalization are possible, i.e. that from the input belief and action it is possible to receive the input observation.</p>
<p>If that cannot be guaranteed, use the <a class="el" href="namespaceAIToolbox_1_1POMDP.html#a6a6deb0f6f3d12bb59f0b9813604abc2" title="Creates a new belief reflecting changes after an action and observation for a particular Model...">updateBeliefUnnormalized()</a> function and do the normalization yourself (and check for it).</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">M</td><td>The type of the <a class="el" href="namespaceAIToolbox_1_1POMDP.html">POMDP</a> <a class="el" href="classAIToolbox_1_1POMDP_1_1Model.html" title="This class represents a Partially Observable Markov Decision Process. ">Model</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">model</td><td>The model used to update the belief. </td></tr>
    <tr><td class="paramname">b</td><td>The intermediate belief. </td></tr>
    <tr><td class="paramname">a</td><td>The action taken during the transition. </td></tr>
    <tr><td class="paramname">o</td><td>The observation registered. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a0f00347484bfd228db82d264a889d649"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0f00347484bfd228db82d264a889d649">&#9670;&nbsp;</a></span>updateBeliefPartialUnnormalized() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename M , std::enable_if_t&lt; is_model_v&lt; M &gt;, int &gt;  = 0&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void AIToolbox::POMDP::updateBeliefPartialUnnormalized </td>
          <td>(</td>
          <td class="paramtype">const M &amp;&#160;</td>
          <td class="paramname"><em>model</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceAIToolbox_1_1POMDP.html#a4522c5e35483fb30b2c43c271781e8bc">Belief</a> &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>o</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceAIToolbox_1_1POMDP.html#a4522c5e35483fb30b2c43c271781e8bc">Belief</a> *&#160;</td>
          <td class="paramname"><em>bRet</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function terminates the unnormalized update of a partially updated belief. </p>
<p>This function is useful in case one needs to update a belief for all possible observations. In such a case, it is possible to avoid repeating the same operations by creating an intermediate belief, that only depends on the action and not on the observation.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="namespaceAIToolbox_1_1POMDP.html#a413832fe24061c45091f0a24e7a7eee2" title="This function partially updates a belief. ">updateBeliefPartial</a></dd></dl>
<p>Note that the input action here must be the same one that produced the intermediate result.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">M</td><td>The type of the <a class="el" href="namespaceAIToolbox_1_1POMDP.html">POMDP</a> <a class="el" href="classAIToolbox_1_1POMDP_1_1Model.html" title="This class represents a Partially Observable Markov Decision Process. ">Model</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">model</td><td>The model used to update the belief. </td></tr>
    <tr><td class="paramname">b</td><td>The intermediate belief. </td></tr>
    <tr><td class="paramname">a</td><td>The action taken during the transition. </td></tr>
    <tr><td class="paramname">o</td><td>The observation registered. </td></tr>
    <tr><td class="paramname">bRet</td><td>The output belief. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad03a82580eea9bba77d72052b181168a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad03a82580eea9bba77d72052b181168a">&#9670;&nbsp;</a></span>updateBeliefPartialUnnormalized() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename M , std::enable_if_t&lt; is_model_v&lt; M &gt;, int &gt;  = 0&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceAIToolbox_1_1POMDP.html#a4522c5e35483fb30b2c43c271781e8bc">Belief</a> AIToolbox::POMDP::updateBeliefPartialUnnormalized </td>
          <td>(</td>
          <td class="paramtype">const M &amp;&#160;</td>
          <td class="paramname"><em>model</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceAIToolbox_1_1POMDP.html#a4522c5e35483fb30b2c43c271781e8bc">Belief</a> &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>o</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function terminates the unnormalized update of a partially updated belief. </p>
<p>This function is useful in case one needs to update a belief for all possible observations. In such a case, it is possible to avoid repeating the same operations by creating an intermediate belief, that only depends on the action and not on the observation.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="namespaceAIToolbox_1_1POMDP.html#a413832fe24061c45091f0a24e7a7eee2" title="This function partially updates a belief. ">updateBeliefPartial</a></dd></dl>
<p>Note that the input action here must be the same one that produced the intermediate result.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">M</td><td>The type of the <a class="el" href="namespaceAIToolbox_1_1POMDP.html">POMDP</a> <a class="el" href="classAIToolbox_1_1POMDP_1_1Model.html" title="This class represents a Partially Observable Markov Decision Process. ">Model</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">model</td><td>The model used to update the belief. </td></tr>
    <tr><td class="paramname">b</td><td>The intermediate belief. </td></tr>
    <tr><td class="paramname">a</td><td>The action taken during the transition. </td></tr>
    <tr><td class="paramname">o</td><td>The observation registered. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a6a6deb0f6f3d12bb59f0b9813604abc2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6a6deb0f6f3d12bb59f0b9813604abc2">&#9670;&nbsp;</a></span>updateBeliefUnnormalized() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename M , std::enable_if_t&lt; is_model_v&lt; M &gt;, int &gt;  = 0&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void AIToolbox::POMDP::updateBeliefUnnormalized </td>
          <td>(</td>
          <td class="paramtype">const M &amp;&#160;</td>
          <td class="paramname"><em>model</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceAIToolbox_1_1POMDP.html#a4522c5e35483fb30b2c43c271781e8bc">Belief</a> &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>o</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceAIToolbox_1_1POMDP.html#a4522c5e35483fb30b2c43c271781e8bc">Belief</a> *&#160;</td>
          <td class="paramname"><em>bRet</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a new belief reflecting changes after an action and observation for a particular <a class="el" href="classAIToolbox_1_1POMDP_1_1Model.html" title="This class represents a Partially Observable Markov Decision Process. ">Model</a>. </p>
<p>This function writes directly into the provided Belief pointer. It assumes that the pointer points to a correctly sized Belief. It does a basic nullptr check.</p>
<p>This function will not normalize the output, nor is guaranteed to return a non-completely-zero vector.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">M</td><td>The type of the <a class="el" href="namespaceAIToolbox_1_1POMDP.html">POMDP</a> <a class="el" href="classAIToolbox_1_1POMDP_1_1Model.html" title="This class represents a Partially Observable Markov Decision Process. ">Model</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">model</td><td>The model used to update the belief. </td></tr>
    <tr><td class="paramname">b</td><td>The old belief. </td></tr>
    <tr><td class="paramname">a</td><td>The action taken during the transition. </td></tr>
    <tr><td class="paramname">o</td><td>The observation registered. </td></tr>
    <tr><td class="paramname">bRet</td><td>The output belief. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aeadb8ad292520175aea2ad4b9173c5cd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeadb8ad292520175aea2ad4b9173c5cd">&#9670;&nbsp;</a></span>updateBeliefUnnormalized() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename M , std::enable_if_t&lt; is_model_v&lt; M &gt;, int &gt;  = 0&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceAIToolbox_1_1POMDP.html#a4522c5e35483fb30b2c43c271781e8bc">Belief</a> AIToolbox::POMDP::updateBeliefUnnormalized </td>
          <td>(</td>
          <td class="paramtype">const M &amp;&#160;</td>
          <td class="paramname"><em>model</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceAIToolbox_1_1POMDP.html#a4522c5e35483fb30b2c43c271781e8bc">Belief</a> &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>o</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a new belief reflecting changes after an action and observation for a particular <a class="el" href="classAIToolbox_1_1POMDP_1_1Model.html" title="This class represents a Partially Observable Markov Decision Process. ">Model</a>. </p>
<p>This function needs to create a new belief since modifying a belief in place is not possible. This is because each cell update for the new belief requires all values from the previous belief.</p>
<p>This function will not normalize the output, nor is guaranteed to return a non-completely-zero vector.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">M</td><td>The type of the <a class="el" href="namespaceAIToolbox_1_1POMDP.html">POMDP</a> <a class="el" href="classAIToolbox_1_1POMDP_1_1Model.html" title="This class represents a Partially Observable Markov Decision Process. ">Model</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">model</td><td>The model used to update the belief. </td></tr>
    <tr><td class="paramname">b</td><td>The old belief. </td></tr>
    <tr><td class="paramname">a</td><td>The action taken during the transition. </td></tr>
    <tr><td class="paramname">o</td><td>The observation registered. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a05e4fb4a18324709e70b42d66cf2054b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a05e4fb4a18324709e70b42d66cf2054b">&#9670;&nbsp;</a></span>weakBoundDistance()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double AIToolbox::POMDP::weakBoundDistance </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceAIToolbox_1_1POMDP.html#a5655ffd334a1e53622314eae70eab464">VList</a> &amp;&#160;</td>
          <td class="paramname"><em>oldV</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceAIToolbox_1_1POMDP.html#a5655ffd334a1e53622314eae70eab464">VList</a> &amp;&#160;</td>
          <td class="paramname"><em>newV</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function returns a weak measure of distance between two VLists. </p>
<p>The logic of the weak bound is the following: the variation between the old VList and the new one is equal to the maximum distance between a ValueFunction in the old VList with its closest match in the new VList. So the farthest from closest.</p>
<p>We define distance between two ValueFunctions as the maximum between their element-wise difference.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">oldV</td><td>The fist VList to compare. </td></tr>
    <tr><td class="paramname">newV</td><td>The second VList to compare.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The weak bound distance between the two arguments. </dd></dl>

</div>
</div>
<h2 class="groupheader">Variable Documentation</h2>
<a id="a14f2ade0c0d30091b74297fce650ddbf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a14f2ade0c0d30091b74297fce650ddbf">&#9670;&nbsp;</a></span>is_generative_model_v</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename M &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool AIToolbox::POMDP::is_generative_model_v = <a class="el" href="structAIToolbox_1_1POMDP_1_1is__generative__model.html">is_generative_model</a>&lt;M&gt;::value</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a0a7899814376313aa6ee8dadecea379d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0a7899814376313aa6ee8dadecea379d">&#9670;&nbsp;</a></span>is_model_eigen_v</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename M &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool AIToolbox::POMDP::is_model_eigen_v = <a class="el" href="structAIToolbox_1_1POMDP_1_1is__model__eigen.html">is_model_eigen</a>&lt;M&gt;::value</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="abbf63587b8e90849d2501933a827061a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abbf63587b8e90849d2501933a827061a">&#9670;&nbsp;</a></span>is_model_not_eigen_v</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename M &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool AIToolbox::POMDP::is_model_not_eigen_v = <a class="el" href="structAIToolbox_1_1POMDP_1_1is__model__not__eigen.html">is_model_not_eigen</a>&lt;M&gt;::value</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a7c3d5eb7dc047b0b55379914b76fd132"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7c3d5eb7dc047b0b55379914b76fd132">&#9670;&nbsp;</a></span>is_model_v</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename M &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool AIToolbox::POMDP::is_model_v = <a class="el" href="structAIToolbox_1_1POMDP_1_1is__model.html">is_model</a>&lt;M&gt;::value</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a30d62c33ae0e760503f3712b498b3e47"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a30d62c33ae0e760503f3712b498b3e47">&#9670;&nbsp;</a></span>is_witness_lp_v</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename LP &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool AIToolbox::POMDP::is_witness_lp_v = <a class="el" href="structAIToolbox_1_1POMDP_1_1is__witness__lp.html">is_witness_lp</a>&lt;<a class="el" href="classAIToolbox_1_1LP.html">LP</a>&gt;::value</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Fri Feb 1 2019 11:06:11 for AIToolbox by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
